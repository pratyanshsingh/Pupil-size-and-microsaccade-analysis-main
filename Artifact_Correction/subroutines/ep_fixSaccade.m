function [templates, outputLog, graphCounter, icaFlag] = ep_fixSaccade(inFile, startChunk, endChunk, badChans, eog, templateSource, saccadeFile, badDataCriteria, refChan, excludePoints, butterflyFig, graphCounter, numGraphs, theSubject, saccMethod, icaFlag)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [templates, outputLog, graphCounter, icaFlag] = ep_fixSaccade(inFile, startChunk, endChunk, badChans, eog, templateSource, saccadeFile, badDataCriteria, refChan, excludePoints, butterflyFig, graphCounter, numGraphs, theSubject, saccMethod, icaFlag)%%   Corrects eye position artifact based on the EOG channels.%	Reads in file chunks generated by chunkInputFile function.%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.%%Inputs%	inFile:     filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	startChunk: starting chunk (usually 1)%   endChunk:   ending chunk%   badChans:   list of bad channels to exclude from blink detection process.%   eog:        EOG channels.%   templateSource:   source of saccade templates (fileTemplate: load file.  autoTemplate: automatically generate saccade template.%                  bothTemplate: average together automatic and manual templates).%   saccadeFile:  file with saccade template.  Assumed to be in the same directory as the data file.%   badDataCriteria:  Criteria for detecting bad data.%       .saturation: followed by range of acceptable data values.  Time points with a channel outside this range will be excluded.%   refChan:    Array of current reference channels.%   excludePoints: time points to exclude, numbering end-to-end for single-trial data (cell array of number of chunks)%   butterflyFig:  the handle for the output figure.  Otherwise, will open a new figure.%   graphCounter: the current subplot for the summary figure.%   numGraphs: the total number of subgraphs in the summary figure.%   theSubject: which subject of the file is being processed.%   saccMethod: 'regression' for that approach or else the name of a rotation.%   icaFlag   : flag for single-step ICA procedure.  'none': not in use.  'needToSave': need to run ICA and then save temp file.  'saved': temp file already saved so read it in.%%   The input chunks are EP format data files.%%Outputs%	Saves files with eye position artifact removed, replacing the original chunked files.%   templates: the templates used for the correction, both file and auto if both used.  Returns empty if error occurs.%       .hSaccades%           .manual: manual horizontal saccade template from file (number of EEG channels,1)%           .auto: auto horizontal saccade template (number of EEG channels,1)%       .vSaccades%           .manual: manual horizontal saccade template from file (number of EEG channels,1)%           .auto: auto horizontal saccade template (number of EEG channels,1)%   outputLog: output messages from saccade fixing process%   graphCounter: the current subplot for the summary figure.%   icaFlag   : flag for single-step ICA procedure.  'none': not in use.  'needToSave': need to run ICA and then save temp file.  'saved': temp file already saved so read it in.%% History:%% by Joseph Dien (10/00)% jdien07@mac.com%% modified 6/22/01 JD% added bad channel and threshold parameters.  Also changed chunkNum to startChunk and endChunk.%% modified 5/27/02 JD% added baseline correct feature.  Fix to bad chans so they are zeroed even if no blink factors.%% bugfix 10/11/02 JD% added fix to baseline feature for when a blink occurs during the baseline% period.  Output files will now be baselined.  Also, added check for chans% with zero variability.%% modified 10/20/02 JD% since ICA removal sometimes degrades trials without blinks, will now% remove blink components only for trials where the largest feature has the% topography of a blink (correlates .9 with raw EEG).%% modified 12/06/02 JD% Can automatically generate individualized blink template.  Maxed out VEOG time% points dropped from correction and baseline process and left intact (to trigger% eyeblink rejection in averaging program) since they can't be corrected% properly.  Added output log.%% modified 02/04/03  JD% Can now specify blink template file name.  Saves topoplots of blink facs.%  Added bothTemplate option.%% bugfix 4/1/04 JD% Allow for spaces in file names.%% bugfix 11/15/05 JD% Fixed bug that crashed program when a customized blink template was% specified.%% bugfix 7/24/06 JD% Contents of blink template no longer prints out on screen.  Added some error checking.%% modified 3/22/07 JD% Finished autotemplate feature.  Also now takes into account possibility% of blink recoveries (with an inverse topography).  Also now handles% different montages through EEG_hardware function.%% modified 2/17/08 JD% Checks to see if binary version of runica is installed and uses it if available.%% modified 11/17/08 JD% Eliminated topoplot of blink factors. Made baseline specification more flexible.%% modified 12/13/08 JD% Increased scaling for blink plots to make them more visible.%% modified 2/11/09 JD% Dropped trialsize input field.  No longer zeroes bad channels.  Replaced% threshold field with full badDataCriteria field.%% modified 3/14/09 JD% Changed to use EP format data to provide more flexibility with I/O functions.%% modified 3/17/09 JD% Only subtracted blink activity (that met variance reduced criterion) is shown for blink data figure.%% bugfix 4/16/09 JD% Fixed crash when overall blink direction equaled exactly zero.%% bugfix &  modified 7/14/09 JD% Fixed bothTemplate option, which was functioning the same as autoTemplate, ignoring the file template.% Changed output from list of blink facs to list of blink trials.  No longer zeroes out bad channels.% Includes list of blink trials in the data chunk.  Output figure can now be passed from function call.% blink file assumed to be in the directory of the data file.  Uses updated blink template format.%% modified 8/28/09 JD% Modified to use new option for binary runICA to control the output file names so that they can be cleaned up% and so that unpredictable crash from bug causing strange file names can be circumvented.%% modified 9/4/09 JD% Added refChan input to deal with mean mastoid data where the presence of the two reference channels (correlated -1)% was causing ICA problems.%% bugfix 10/17/09 JD% Crash when only one VEOG channel.%% modified 10/28/09 JD% Added option to disable preprocessing figure for low memory situations.%% bugfix 11/20/09 JD% Replaced "union" commands with "unique" commands because certain situations caused the "union" command to crash in% Matlab 2007.%% bugfix 12/3/09 JD% Additional check for ICA failure (denoted by imaginary numbers for weights).%% modified 2/11/10 JD% Will now work with subject average files with multiple subjects.% BlinkTrial no longer initialized to zero.%% modified & bugfix 5/15/10 JD% Made more memory efficient by reducing resolution of the blink plots to no more than 10000 points regardless of size of data.% Fixed when data is mean mastoid, not setting second reference channel to be inverse of the first reference channel.% Fixed crashes when explicit reference channel is present.%%  modified 10/13/10 JD%  For continuous files, data now divided into one second epochs and can be artifact rejected in an epochwise fashion%  in same fashion as segmented data.%%  modified 10/28/10 JD%  Added support for HEOG saccade correction.%%  bugfix 11/3/10 JD%  Now handles mismatch where file template or data has implicit reference and the other one has explicit reference.%%  modified 1/20/11 JD%  Added support for manually specifying EOG channels in the preferences.  Missing EOG channel marked as a -1.%%  bugfix 6/6/11 JD%  Fixed crash when using saccade correction on file divided into multiple segments.%%  bugfix 6/12/11 JD%  Fixed crash when different numbers of factors correlate with left and right saccade templates.% % modified 1/25/12 JD% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.% % modified 9/22/13 JD% Restricted saccade correction to EEG channels.% % modified 11/19/13 JD% Adds saccade artifact channel and event marking onset latency of the saccade in each epoch.%% bugfix 1/8/14 JD% Fixed crash when there is more than one bad channel.%% bufix 3/11/14 JD% Handles decimal sampling rates gracefully.%% modified 3/18/14 JD% Changed uses of "temp" as a variable name to "tempVar" due to other Matlab programmers often using it as a function% name, resulting in collisions.% % modified 6/2/14 JD% Rereference an epoch after performing saccade correction%% bufix 6/6/14 JD% Fixed saccade correction can issue false error that template has wrong number of electrodes.% Fixed crash when correcting saccade in continuous file.%% bufix 6/12/14 JD% Fixed blank keys field of events being produced without .key (e.g., .keys.keyCod instead of .keys.key.keyCode)%% modified 7/16/14 JD% Simplified keys code field structure.%% modified 11/20/14 JD% Added vertical saccade correction.%% bugfix 8/14/15 JD% Fixed unable to save artifact correction summary figure starting with% Matlab 2014b in stand-alone mode.%% bugfix 8/26/15 JD% Fixed crash when running horizontal saccade correction but not vertical saccade correction.%% modified 9/20/16 JD% Improved saccade correction by treating as an eye position artifact rather than an episodic saccade artifact.% Added auto option for saccades.% Added template to output.% Added exclusion of blink points from eye position artifact estimation, instead interpolating these points by assuming no change in eye position during blinks.% Added support for boundary events.%% modified 1/3/17 JD% Added eyeTracker option to blink and saccade correction routines.%% modified 2/5/17 JD% Added Subtracted topography to template jpeg output.%% modified 4/21/17 JD% Excludes time points beyond a certain range from global bad channel detection, blink, and saccade routines.% Enabled saccade correction even when one or both HEOG channels are bad.% Fixed bug that mucked up correction scaling in the presence of a bad channel.%% bugfix 9/30/17 JD% Median corrects data prior to saturation check to ensure channels with merely high offsets are not treated as bad data.%% bugfix 10/5/17 JD% Fixed crashes due to Matlab changing their graphics objects AGAIN in 2017b.%% bugfix 10/20/17 JD% Eliminated x tick labels to address problem with subplots in summary% artifact figure getting squeezed by formatting problem on PCs.%% bugfix 11/26/17 JD% Fixed miscalculation of saccade correction in single-trial data.%% bugfix 10/5/17 JD% Fixed crash when preprocessing data containing impedance values.% Fixed crash when preprocessing multi-subject average files.%% bugfix 1/14/18 JD% Fixed crash when no good samples in an epoch.%% modified 2/4/18 JD% Made subplot specification for summary figure output more flexible.%% modified 4/8/18 JD% Consolidated summary figure for average files so no longer one per subject.%% bugfix 4/26/18 JD% Fixed crash when there are bad channels.%% bugfix 6/13/19 JD% Fixed crash when data has no events.% % modified 6/24/19 JD% Accelerates artifact correction by adding option to keep chunks in RAM.% Now excludes global bad channels from summary subplot.%% bugfix 9/7/19 JD% Fixed crash when there are non-EEG channels.% % bugfix & modified 3/17/20 JD% Now remaps file template if it is for a different electrode montage.% Fixed crash when using a file template and there are bad channels.% % bugfix & modified 5/30/20 JD% Added ICA options for CRD saccade artifact correction.% Fixed hSaccade and vSaccade outputs.%% modified 6/29/20 JD% Added ICA options for CRD saccade and spike potential artifact corrections.% Added eye artifact control to specify EMCP, MAAC, or single-step ICA options.% Fixed crash when using a saccade template file and there is a bad EOG channel or when it is from a different EEG montage.% % modified 7/16/20 JD% No longer changes voltages outside of saturation range into NaN.% % bugfix 8/18/20 JD% No longer changes excluded timepoints into NaN.% For ICA options, scales the saccade channels by the winv values.% For ICA options, interpolate the excluded points prior to subtracting from EEG data.% % bugfix 9/24/20 JD% better handles NaN values.% % bugfix 6/19/21 JD% Fixed not emptying unused templates, resulting in blank topos appearing in template figures.% % bugfix 4/4/22 JD% Fixed crashing if no good data.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2025  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPchunk EPchunkSP EPtictoctemplates=[];filterWidthMS=8; %width of the smoothing filter window in MS.msg='Fixing saccade artifacts.';disp(msg);outputLog{1}=msg;if ~exist('butterflyFig','var')    butterflyFig=figure('Name','Artifact Correction','NumberTitle','off');    colormap jet;    standAlone=1;else    standAlone=0;endtheEOG(1) = eog.LUVEOG;theEOG(2) = eog.RUVEOG;theEOG(3) = eog.LLVEOG;theEOG(4) = eog.RLVEOG;theEOG(5) = eog.LHEOG;theEOG(6) = eog.RHEOG;VEOG=[];goodVEOG=[];for i=1:4    if isempty(intersect(theEOG(i),badChans)) && (theEOG(i) ~= -1)        VEOG=[VEOG theEOG(i)];        goodVEOG(end+1)=i;    endendblinksign = [1 1 -1 -1]';blinksign=blinksign(goodVEOG,1);HEOG=[];for i=5:6    if isempty(intersect(theEOG(i),badChans)) && (theEOG(i) ~= -1)        HEOG=[HEOG theEOG(i)];    endend[fileDir, name, ext] = fileparts(inFile);hSaccManualTemplate=[];vSaccManualTemplate=[];hSaccAutoTemplate=[];vSaccAutoTemplate=[];if any(strcmp(templateSource, {'fileTemplate','bothTemplate'}))    ep_tictoc('ioStart');    eval(['load ''' saccadeFile '''']);    ep_tictoc('ioFinish');        if ~exist('EPsaccade','var')        msg='Not a saccade template.';        [msg]=ep_errorMsg({msg});        return    end        if ~exist('EPsaccade','var')        msg='No saccade template so horizontal saccade correction disabled.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        saccadeFileCorrect=0;    else        saccadeFileCorrect=1;        if (~isfield(EPsaccade,'vSaccade')) || ~any(EPsaccade.vSaccade.template)            msg='No vertical saccade template so vertical saccade correction disabled.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            vertSaccadeFileCorrect=0;        else            vertSaccadeFileCorrect=1;        end    end        if exist('EPchunk','var') && ~isempty(EPchunk)        if exist('EPchunkSP','var') && ~isempty(EPchunkSP) && isstruct(EPchunkSP{1})            dataChunk=EPchunkSP{1};        else            dataChunk=EPchunk{1};        end    else        ep_tictoc('ioStart');        eval(['load ''' deblank(inFile) '-' num2str(1) '.mat''']);        ep_tictoc('ioFinish');    end    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    EEGsaccChans=find(ismember({EPsaccade.eloc.type},{'EEG','REF'}));    nonHEOGbadChans=setdiff(badChans,[eog.LHEOG eog.RHEOG]); %HEOG bad chans will be interpolated    saccChans = setdiff(EEGsaccChans,nonHEOGbadChans);        if saccadeFileCorrect        hSaccManualTemplate=EPsaccade.hSaccade.template(:);        if size(hSaccManualTemplate,2) > 1            msg='Something is wrong with the saccade template.  It has the wrong dimensions.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end                %if the template is different from the dataset, remap the template        if (length(EPsaccade.eloc) ~= length(EEGchans)) || any([EPsaccade.eloc.theta]-[dataChunk.eloc.theta]) || any([EPsaccade.eloc.radius]-[dataChunk.eloc.radius])            newData=ep_interpChans(hSaccManualTemplate(saccChans), EPsaccade.eloc(saccChans), dataChunk.eloc(EEGchans));            ep_tictoc;if EPtictoc.stop;return;end            if isempty(newData)                return            else                hSaccManualTemplate=newData;            end        end        if vertSaccadeFileCorrect            vSaccManualTemplate=EPsaccade.vSaccade.template(:);            %if the template is different from the dataset, remap the template            if (length(EPsaccade.eloc) ~= length(EEGchans)) || any([EPsaccade.eloc.theta]-[dataChunk.eloc.theta]) || any([EPsaccade.eloc.radius]-[dataChunk.eloc.radius])                newData=ep_interpChans(vSaccManualTemplate(saccChans), EPsaccade.eloc(saccChans), dataChunk.eloc(EEGchans));                ep_tictoc;if EPtictoc.stop;return;end                if isempty(newData)                    return                else                    vSaccManualTemplate=newData;                end            end        end    endendif ~any(strcmp(templateSource, {'autoTemplate','bothTemplate','fileTemplate','eyeTracker'}))    msg='Template variable must be set to fileTemplate, autoTemplate, bothTemplate, or eyeTracker.';    outputLog{end+1}=msg;    disp(' ');    disp('**************************************************************');    disp(msg);    disp('**************************************************************');    disp(' ');    return;endbadChans = badChans(find(badChans));	%drop out bad channels set as being zerooutputLog=[];for iChunk = startChunk:endChunk    if endChunk > startChunk        msg=[deblank(inFile) '-' num2str(iChunk)];        disp(msg);        outputLog{end+1}=msg;    end    if exist('EPchunk','var') && ~isempty(EPchunk)        if exist('EPchunkSP','var') && ~isempty(EPchunkSP) && isstruct(EPchunkSP{iChunk})            dataChunk=EPchunkSP{iChunk};        else            dataChunk=EPchunk{iChunk};        end    else        ep_tictoc('ioStart');        eval(['load ''' deblank(inFile) '-' num2str(iChunk) '.mat''']);        ep_tictoc('ioFinish');    end        if strcmp(dataChunk.dataType,'continuous')        theSegment = 'one second epoch';    else        theSegment = 'trial';    end        numChans=length(dataChunk.chanNames);    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    trialdata=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);    chans = setdiff(EEGchans,badChans);    if length(dataChunk.facNames) > 1        msg='This function is not intended for application to factor data.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end        %     if ~ismember(1,blinksign) || ~ismember(-1,blinksign)%         msg='Needs at least one good upper and one good lower VEOG channel to fix saccade artifacts.';%         outputLog{end+1}=msg;%         disp(' ');%         disp('**************************************************************');%         disp(msg);%         disp('**************************************************************');%         disp(' ');%         return%     end        if iChunk ==startChunk        subtractedHsacTopo=zeros(numChans,1);        subtractedVsacTopo=zeros(numChans,1);    end        if strcmp(dataChunk.dataType,'continuous')        displayPeriod=size(dataChunk.data,2);    %Number of timepoints to graph in display.    else        displayPeriod=size(dataChunk.data,2)*size(dataChunk.data,3);    end    decimateSamples=ceil(max(1,displayPeriod/10000));    totalDisplayPeriod=displayPeriod*size(dataChunk.data,4);    goodPoints = find(any(~isnan(trialdata(chans,:))));%     goodPoints = find((max(trialdata(chans,:)-repmat(median(trialdata(chans,:)')',1,size(trialdata(chans,:),2))) < badDataCriteria.saturation(2)) & (min(trialdata(chans,:)-repmat(median(trialdata(chans,:)')',1,size(trialdata(chans,:),2))) > badDataCriteria.saturation(1)));        goodPoints=setdiff(goodPoints,excludePoints{iChunk});        if displayPeriod == 1        msg='There is only one time point and so the data cannot be blink/saccade corrected.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end        trialSize=size(dataChunk.data,2);        boundaryPoints=[];    for iTrial=1:size(dataChunk.data,3)        if ~isempty(dataChunk.events{iTrial})            boundaryPoints=[boundaryPoints; [dataChunk.events{iTrial}(find(strcmp('boundary',{dataChunk.events{iTrial}.type}))).sample]'+(iTrial-1)*trialSize];        end        if iTrial > 1            boundaryPoints=[boundaryPoints; (iTrial-1)*trialSize+1];        end    end        drawnow        hSaccEEGgp=trialdata(HEOG(1),goodPoints)-trialdata(HEOG(2),goodPoints);    vSaccEEGgp=mean(trialdata(VEOG(blinksign == -1),goodPoints),1)-mean(trialdata(VEOG(blinksign == 1),goodPoints),1);    if strcmp(templateSource, 'eyeTracker')        hSacc=trialdata(find(strcmp('XEY',dataChunk.chanTypes)),goodPoints);        vSacc=trialdata(find(strcmp('YEY',dataChunk.chanTypes)),goodPoints);        if isempty(hSacc) || isempty(vSacc)            msg='There is no apparent eye-tracker data.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end    else        hSacc=hSaccEEGgp;        vSacc=vSaccEEGgp;    end        numPoints=size(trialdata,2);    hSacc1=zeros(1,numPoints);    vSacc1=zeros(1,numPoints);    hSaccEEG1=zeros(1,numPoints);    vSaccEEG1=zeros(1,numPoints);        if isempty(boundaryPoints)        hSacc1=interp1([0 goodPoints size(trialdata,2)+1],[hSacc(1) hSacc hSacc(end)],[1:size(trialdata,2)]); %interpolate bad points        vSacc1=interp1([0 goodPoints size(trialdata,2)+1],[vSacc(1) vSacc vSacc(end)],[1:size(trialdata,2)]); %interpolate bad points        hSaccEEG1=interp1([0 goodPoints size(trialdata,2)+1],[hSaccEEGgp(1) hSaccEEGgp hSaccEEGgp(end)],[1:size(trialdata,2)]); %interpolate bad points        vSaccEEG1=interp1([0 goodPoints size(trialdata,2)+1],[vSaccEEGgp(1) vSaccEEGgp vSaccEEGgp(end)],[1:size(trialdata,2)]); %interpolate bad points    else        for iBreak=0:length(boundaryPoints)            ep_tictoc;if EPtictoc.stop;return;end            if iBreak ==0                startPoint=1; %full time point space                endPoint=boundaryPoints(1)-1; %full time point space            elseif iBreak == length(boundaryPoints)                startPoint=boundaryPoints(iBreak); %full time point space                endPoint=numPoints; %full time point space            else                startPoint=boundaryPoints(iBreak); %full time point space                endPoint=boundaryPoints(iBreak+1)-1; %full time point space            end            theGoodPoints=intersect(goodPoints,[startPoint:endPoint]);            if ~isempty(theGoodPoints)                theGoodPointStart=min(find(goodPoints >= startPoint)); %ordinal point in goodPoint space                theGoodPointEnd=max(find(goodPoints <= endPoint)); %ordinal point in goodPoint space                                %interpolate hSacc and vSacc from goodPoint space to full time point space                hSacc1(startPoint:endPoint)=interp1([startPoint-1 theGoodPoints endPoint+1],[hSacc(theGoodPointStart) hSacc(theGoodPointStart:theGoodPointEnd) hSacc(theGoodPointEnd)],[startPoint:endPoint]); %interpolate bad points                vSacc1(startPoint:endPoint)=interp1([startPoint-1 theGoodPoints endPoint+1],[vSacc(theGoodPointStart) vSacc(theGoodPointStart:theGoodPointEnd) vSacc(theGoodPointEnd)],[startPoint:endPoint]); %interpolate bad points                hSaccEEG1(startPoint:endPoint)=interp1([startPoint-1 theGoodPoints endPoint+1],[hSaccEEGgp(theGoodPointStart) hSaccEEGgp(theGoodPointStart:theGoodPointEnd) hSaccEEGgp(theGoodPointEnd)],[startPoint:endPoint]); %interpolate bad points                vSaccEEG1(startPoint:endPoint)=interp1([startPoint-1 theGoodPoints endPoint+1],[vSaccEEGgp(theGoodPointStart) vSaccEEGgp(theGoodPointStart:theGoodPointEnd) vSaccEEGgp(theGoodPointEnd)],[startPoint:endPoint]); %interpolate bad points            end        end    end    hSacc2=hSacc1;    hSaccIsnan=find(isnan(hSacc1));    goodSaccPoints=setdiff(goodPoints,hSaccIsnan);    if ~isempty(goodSaccPoints)        hSacc2(hSaccIsnan)=0; %hSacc2 is mean-corrected hSacc (based only on good points)        hSacc2(goodSaccPoints)=hSacc2(goodSaccPoints)-mean(hSacc2(goodSaccPoints));        vSacc2=vSacc1;        vSaccIsnan=find(isnan(vSacc1));        vSacc2(vSaccIsnan)=0;        hSaccAutoTemplate(chans,1)=(mean(trialdata(chans,goodSaccPoints).*repmat(hSacc2(goodSaccPoints),length(chans),1),2))'; %weight the time points by the estimated size of the saccade        sortedhSacc=sort(abs(hSacc2(goodSaccPoints)));        fixationGoodPoints=setdiff(find((abs(hSacc2) < sortedhSacc(round(length(sortedhSacc)/8)))),hSaccIsnan); %just the good time points where eyes were near the center line        if ~isempty(fixationGoodPoints)            goodFixSaccPoints=setdiff(fixationGoodPoints,vSaccIsnan);            vSacc2(goodFixSaccPoints)=vSacc2(goodFixSaccPoints)-mean(vSacc2(goodFixSaccPoints));            vSaccAutoTemplate(chans,1)=(mean(trialdata(chans,goodFixSaccPoints).*repmat(vSacc2(goodFixSaccPoints),length(chans),1),2,'omitnan'))';        else            vSacc2(goodSaccPoints)=vSacc2(goodSaccPoints)-mean(vSacc2(goodSaccPoints));            vSaccAutoTemplate(chans,1)=(mean(trialdata(chans,setdiff(goodPoints,vSaccIsnan)).*repmat(vSacc2(goodSaccPoints),length(chans),1),2,'omitnan'))';        end        switch templateSource            case 'fileTemplate'                hSaccadeTemplate=hSaccManualTemplate;                vSaccadeTemplate=vSaccManualTemplate;                hSaccAutoTemplate=[];                vSaccAutoTemplate=[];            case {'autoTemplate','eyeTracker'}                hSaccadeTemplate=hSaccAutoTemplate;                vSaccadeTemplate=vSaccAutoTemplate;            case 'bothTemplate'                hSaccadeTemplate=(hSaccManualTemplate+hSaccAutoTemplate)/2;                vSaccadeTemplate=(vSaccManualTemplate+vSaccAutoTemplate)/2;            otherwise                disp('template option not recognized.');                return        end        subtractedHsac=zeros(size(trialdata));        subtractedVsac=zeros(size(trialdata));        if strcmp(saccMethod,'regression')            filterWidth=filterWidthMS/round(1000/dataChunk.Fs);            if ~isempty(hSaccadeTemplate)                hSaccadesScale=abs(hSaccadeTemplate(find(chans==HEOG(2)))-hSaccadeTemplate(find(chans==HEOG(1))));                X=hSacc1(goodSaccPoints)';                Y=((hSaccadeTemplate(chans)/hSaccadesScale)'*trialdata(chans,goodSaccPoints))';                b=[ones(length(X),1) X]\Y;                subtractedHsac(chans,:)=pinv(hSaccadeTemplate(chans)'/hSaccadesScale)*(hSacc1*b(2)+b(1));                %             if isempty(boundaryPoints)                %                 %two-pass filter to avoid latency shifting                %                 filter1=filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(subtractedHsac(chans,1),1,filterWidth) subtractedHsac(chans,:) repmat(subtractedHsac(chans,end),1,filterWidth)]);                %                 filter1=filter1(:,1+filterWidth:end-filterWidth); %drop padding                %                 filter2=filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(filter1(chans,end),1,filterWidth) flip(filter1) repmat(filter1(chans,1),1,filterWidth)]);                %                 subtractedHsac(chans,:)=flip(filter2(:,1+filterWidth:end-filterWidth));                %             else                %                 for iBreak=0:length(boundaryPoints)                %                     ep_tictoc;if EPtictoc.stop;return;end                %                     if iBreak ==0                %                         startPoint=1; %full time point space                %                         endPoint=boundaryPoints(1)-1; %full time point space                %                     elseif iBreak == length(boundaryPoints)                %                         startPoint=boundaryPoints(iBreak); %full time point space                %                         endPoint=numPoints; %full time point space                %                     else                %                         startPoint=boundaryPoints(iBreak); %full time point space                %                         endPoint=boundaryPoints(iBreak+1)-1; %full time point space                %                     end                %                %                     %two-pass filter to avoid latency shifting                %                     filter1=filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(subtractedHsac(chans,startPoint),1,filterWidth) subtractedHsac(chans,startPoint:endPoint) repmat(subtractedHsac(chans,endPoint),1,filterWidth)]);                %                     filter1=filter1(:,1+filterWidth:end-filterWidth); %drop padding                %                     filter2=filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(filter1(:,end),1,filterWidth) flip(filter1) repmat(filter1(:,1),1,filterWidth)]);                %                     subtractedHsac(chans,startPoint:endPoint)=flip(filter2(:,1+filterWidth:end-filterWidth));                %                 end                %             end                trialdata=trialdata-subtractedHsac;            end            if ~isempty(vSaccadeTemplate)                vSaccadesScale=abs(mean(vSaccadeTemplate(find(ismember(chans,VEOG(blinksign == 1)))))-mean(vSaccadeTemplate(find(ismember(chans,VEOG(blinksign == -1))))));                if vSaccadesScale~=0                    X=vSacc1(goodSaccPoints)';                    Y=((vSaccadeTemplate(chans)/vSaccadesScale)'*trialdata(chans,goodSaccPoints))';                    b=[ones(length(X),1) X]\Y;                    subtractedVsac(chans,:)=pinv(vSaccadeTemplate(chans)'/vSaccadesScale)*(vSacc1*b(2)+b(1));                end                %             if isempty(boundaryPoints)                %                 %two-pass filter to avoid latency shifting                %                 filter1=filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(subtractedVsac(chans,1),1,filterWidth) subtractedVsac(chans,:) repmat(subtractedVsac(chans,end),1,filterWidth)]);                %                 filter1=filter1(:,1+filterWidth:end-filterWidth); %drop padding                %                 filter2=filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(filter1(chans,end),1,filterWidth) flip(filter1) repmat(filter1(chans,1),1,filterWidth)]);                %                 subtractedVsac(chans,:)=flip(filter2(:,1+filterWidth:end-filterWidth));                %             else                %                 for iBreak=0:length(boundaryPoints)                %                     ep_tictoc;if EPtictoc.stop;return;end                %                     if iBreak ==0                %                         startPoint=1; %full time point space                %                         endPoint=boundaryPoints(1)-1; %full time point space                %                     elseif iBreak == length(boundaryPoints)                %                         startPoint=boundaryPoints(iBreak); %full time point space                %                         endPoint=numPoints; %full time point space                %                     else                %                         startPoint=boundaryPoints(iBreak); %full time point space                %                         endPoint=boundaryPoints(iBreak+1)-1; %full time point space                %                     end                %                %                     %two-pass filter to avoid latency shifting                %                     filter1=filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(subtractedVsac(chans,startPoint),1,filterWidth) subtractedVsac(chans,startPoint:endPoint) repmat(subtractedVsac(chans,endPoint),1,filterWidth)]);                %                     filter1=filter1(:,1+filterWidth:end-filterWidth); %drop padding                %                     filter2=filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(filter1(:,end),1,filterWidth) flip(filter1) repmat(filter1(:,1),1,filterWidth)]);                %                     subtractedVsac(chans,startPoint:endPoint)=flip(filter2(:,1+filterWidth:end-filterWidth));                %                 end                %             end                trialdata=trialdata-subtractedVsac;            end            subtractedSaccades=subtractedHsac+subtractedVsac;        else            if (isscalar(refChan)) && std(trialdata(refChan(1),:)','omitnan') == 0 && ismember(refChan(1),chans)                chans(chans==refChan(1))=[];     %temporarily take first reference site out of ICA                refFlag=refChan(1);            else                refFlag=[];            end            NUM_FAC=length(chans);            dataRank=rank(trialdata(chans,goodPoints));            msg=['The rank of the saccade data was: ' num2str(dataRank)];            disp(msg);            outputLog{end+1}=msg;            if dataRank < NUM_FAC                msg=['Dropping ' num2str(NUM_FAC-dataRank) ' dimensions due to singular data matrix (bridged channels can cause this, or simply very similar channels).'];                disp(msg);                outputLog{end+1}=msg;                NUM_FAC = dataRank;            end            saccTrialData=nan(size(trialdata));            saccTrialData(chans,goodPoints)=trialdata(chans,goodPoints);            if strcmp(icaFlag,'saved')                load([fileDir filesep 'ICAresults']);            else                switch saccMethod                    case {'Infomax','Extended-Infomax'}                        rotOpt=1;                        rng(0,'twister'); %sets random number generator to standardized start to ensure replicability of Infomax results.                        [FactorResults] = ep_doPCA('asis', saccMethod, rotOpt, 'SVD', 'COV', NUM_FAC, saccTrialData(chans,:)', 'N');                    case 'SOBI'                        rotOpt=floor(400/(1000/dataChunk.Fs));                        %for SOBI, the data needs to be organized into a 3D matrix with trials so that the time lags don't get extended past epoch limits.  Even for continuous, will do as one second epochs to handle bad points.                        if strcmp(dataChunk.dataType,'continuous')                            saccTrialData=reshape(saccTrialData(:,1:size(saccTrialData,2)-rem(size(saccTrialData,2),dataChunk.Fs)),numChans,dataChunk.Fs,[]); %for bad timepoint exclusion to work, need to split up continuous recording into one second epochs                            for iEvent=1:length(dataChunk.events{1})                                if strcmp('boundary',dataChunk.events{1}(iEvent).type)                                    saccTrialData(:,:,floor((dataChunk.events{1}(iEvent).sample-1)/dataChunk.Fs)+1)=NaN; %if a boundary event lands in the middle of an epoch, exclude the entire epoch                                end                            end                        else                            numPoints=length(dataChunk.timeNames);                            numSubs=length(dataChunk.subNames);                            numCells=length(dataChunk.cellNames);                            saccTrialData=reshape(saccTrialData,numChans,numPoints,[]);                            for iSub=1:numSubs                                for iCell=1:numCells                                    if ~isempty(dataChunk.events(iSub,iCell))                                        if any(strcmp('boundary',{dataChunk.events{iSub,iCell}.type}))                                            saccTrialData(:,:,((iSub-1)*numSubs*numCells+(iCell-1)*numCells)+1)=NaN; %if a boundary event lands in the middle of an epoch, exclude the entire epoch                                        end                                    end                                end                            end                        end                        [FactorResults] = ep_doPCA('asis', saccMethod, rotOpt, 'SVD', 'COV', NUM_FAC, saccTrialData(chans,:,:), 'N');                        %             [H]=sobi(saccTrialData(chans,:,:),NUM_FAC,rotOpt);                        %             FactorResults.varSD=mean(reshape(saccTrialData(chans,:,:),length(chans),[])');                        %             FactorResults.FacPat=H;                        %             FactorResults.FacScr=reshape(saccTrialData(chans,:,:),length(chans),[])'*pinv(H)';                    otherwise                        [FactorResults] = ep_doPCA('asis', saccMethod, [], 'SVD', 'COV', NUM_FAC, saccTrialData(chans,:)', 'N');                end                if strcmp(icaFlag,'needToSave')                    save([fileDir filesep 'ICAresults'],'FactorResults');                    icaFlag='saved';                end            end            if isempty(FactorResults)                msg=['Error computing saccade factor.'];                outputLog{end+1}=msg;                disp(' ');                disp('**************************************************************');                disp(msg);                disp('**************************************************************');                disp(' ');                return            end            winv=diag(FactorResults.varSD)*FactorResults.FacPat;            activations=FactorResults.FacScr';            if any(strcmp(templateSource,{'fileTemplate','bothTemplate'}))                corrs = corrcoef([hSaccManualTemplate(chans) winv]);                hSaccManFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);                if isempty(hSaccManFacs)                    msg=['No manual horizontal saccade facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];                else                    msg=['The highest manual horizontal saccade fac correlation (of ' num2str(length(hSaccManFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];                end                disp(msg);                outputLog{end+1}=msg;            else                hSaccManFacs=[];            end            if any(strcmp(templateSource,{'fileTemplate','bothTemplate'}))                corrs = corrcoef([vSaccManualTemplate(chans) winv]);                vSaccManFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);                if isempty(vSaccManFacs)                    msg=['No manual vertical saccade facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];                else                    msg=['The highest manual vertical saccade fac correlation (of ' num2str(length(vSaccManFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];                end                disp(msg);                outputLog{end+1}=msg;            else                vSaccManFacs=[];            end            if any(strcmp(templateSource,{'autoTemplate','bothTemplate'}))                corrs = corrcoef([hSaccAutoTemplate(chans)' winv]);                hSaccAutoFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);                if isempty(hSaccAutoFacs)                    msg=['No auto horizontal saccade facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];                else                    msg=['The highest auto horizontal saccade fac correlation (of ' num2str(length(hSaccAutoFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];                end                disp(msg);                outputLog{end+1}=msg;            else                hSaccAutoFacs=[];            end            if any(strcmp(templateSource,{'autoTemplate','bothTemplate'}))                corrs = corrcoef([vSaccAutoTemplate(chans)' winv]);                vSaccAutoFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);                if isempty(vSaccAutoFacs)                    msg=['No auto vertical saccade facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];                else                    msg=['The highest auto vertical saccade fac correlation (of ' num2str(length(vSaccAutoFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];                end                disp(msg);                outputLog{end+1}=msg;            else                vSaccAutoFacs=[];            end            saccFacs=unique([hSaccManFacs,vSaccManFacs,hSaccAutoFacs,vSaccAutoFacs]);            hSaccEEG1=zeros(1,size(activations,2));            vSaccEEG1=zeros(1,size(activations,2));            if ~isempty(saccFacs)	%if there are saccade factors, subtract them out                winvFull = zeros(numChans,size(winv,2));                for iChan = 1:length(chans)                    winvFull(chans(iChan),:)=winv(iChan,:);                end                tempVar = zeros(size(activations,1),1);                tempVar(saccFacs) = 1;                subtractedSaccades = (winvFull * diag(tempVar) * (activations-repmat(median(activations(:,goodPoints)')',1,size(activations,2))));                subtractedSaccadesInterp=zeros(size(trialdata));                %interpolate excluded and bad time points                for iChan=1:length(chans)                    ep_tictoc;if EPtictoc.stop;return;end                    theChan=chans(iChan);                    if isempty(boundaryPoints)                        subtractedSaccadesInterp(theChan,:)=interp1([0 goodPoints size(trialdata,2)+1],[subtractedSaccades(theChan,1) subtractedSaccades(theChan,:) subtractedSaccades(theChan,end)],[1:size(trialdata,2)]); %interpolate bad points                    else                        for iBreak=0:length(boundaryPoints)                            if iBreak ==0                                startPoint=1; %full time point space                                endPoint=boundaryPoints(1)-1; %full time point space                            elseif iBreak == length(boundaryPoints)                                startPoint=boundaryPoints(iBreak); %full time point space                                endPoint=numPoints; %full time point space                            else                                startPoint=boundaryPoints(iBreak); %full time point space                                endPoint=boundaryPoints(iBreak+1)-1; %full time point space                            end                            theGoodPoints=intersect(goodPoints,[startPoint:endPoint]);                            if ~isempty(theGoodPoints)                                %interpolate subtractedSaccades from goodPoint space to full time point space                                subtractedSaccadesInterp(theChan,startPoint:endPoint)=interp1([startPoint-1 theGoodPoints endPoint+1],[subtractedSaccades(theChan,theGoodPoints(1)) subtractedSaccades(theChan,theGoodPoints) subtractedSaccades(theChan,theGoodPoints(end))],[startPoint:endPoint]); %interpolate bad points                            end                        end                    end                end                trialdata=trialdata-subtractedSaccadesInterp;                HsaccFacs=unique([hSaccManFacs,hSaccAutoFacs]);                if ~isempty(HsaccFacs)                    tempVar = zeros(size(activations,1),1);                    tempVar(HsaccFacs) = 1;                    subtractedHsac=(winvFull * diag(tempVar) * (activations-repmat(median(activations(:,goodPoints)')',1,size(activations,2))));                    hSaccEEG1=((winvFull(HEOG(1),:)-winvFull(HEOG(2),:)) * diag(tempVar) * (activations-repmat(median(activations(:,goodPoints)')',1,size(activations,2))));                end                VsaccFacs=unique([vSaccManFacs,vSaccAutoFacs]);                if ~isempty(VsaccFacs)                    tempVar = zeros(size(activations,1),1);                    tempVar(VsaccFacs) = 1;                    subtractedVsac=(winvFull * diag(tempVar) * (activations-repmat(median(activations(:,goodPoints)')',1,size(activations,2))));                    vSaccEEG1=((mean(winvFull(VEOG(blinksign == -1),:))-mean(winvFull(VEOG(blinksign == 1),:))) * diag(tempVar) * (activations-repmat(median(activations(:,goodPoints)')',1,size(activations,2))));                end            else                subtractedSaccades=zeros(size(trialdata));            end            if ~isempty(refFlag)                chans(end+1)=refFlag;            end        end    else        subtractedSaccades=zeros(size(trialdata));    end        if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})        if any(any(subtractedSaccades))            figure(butterflyFig{iChunk});            theTitle='subtracted saccades';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,subtractedSaccades,chans,theSubject);            subplot(numGraphs,1,graphCounter), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        theTitle='with saccades subtracted';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialdata,chans,theSubject);            subplot(numGraphs,1,graphCounter+1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        else            figure(butterflyFig{iChunk});            theTitle='no saccades to subtract that were detected';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,subtractedSaccades,chans,theSubject);            subplot(numGraphs,1,graphCounter), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        theTitle='no saccades subtracted';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialdata,chans,theSubject);            subplot(numGraphs,1,graphCounter+1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                    end                drawnow    end        %rereference the data.    if ~isempty(refChan)        referenceData=mean(trialdata(refChan,:),1);        for iChan=1:length(EEGchans)            theChan=EEGchans(iChan);            trialdata(theChan,:)=trialdata(theChan,:)-referenceData;        end    end        dataChunk.data(:,:,:,theSubject)=reshape(trialdata,size(dataChunk.data));        saccChan=find(strcmp('Hsaccade',dataChunk.chanNames));    if isempty(saccChan)        EPadd.chanNames{1}='Hsaccade';        EPadd.chanTypes{1}='REG';        EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));        EPadd.data(:,:,:,theSubject)=reshape(hSaccEEG1,1,size(dataChunk.data,2),[]);        if isfield(dataChunk,'interpChans')            interpChans=dataChunk.interpChans;            dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            dataChunk.interpChans=interpChans;        else            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');        end    else        dataChunk.data(saccChan,:,:,theSubject)=reshape(hSaccEEG1,1,size(dataChunk.data,2),[]);    end        saccChan=find(strcmp('Vsaccade',dataChunk.chanNames));    if isempty(saccChan)        EPadd.chanNames{1}='Vsaccade';        EPadd.chanTypes{1}='REG';        EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));        EPadd.data(:,:,:,theSubject)=reshape(vSaccEEG1,1,size(dataChunk.data,2),[]);        if isfield(dataChunk,'interpChans')            interpChans=dataChunk.interpChans;            dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            dataChunk.interpChans=interpChans;        else            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');        end    else        dataChunk.data(saccChan,:,:,theSubject)=reshape(vSaccEEG1,1,size(dataChunk.data,2),[]);    end        if isempty(dataChunk)        disp('Warning: No file saved due to program error.');    end    if exist('EPchunk','var') && ~isempty(EPchunk)        if exist('EPchunkSP','var') && ~isempty(EPchunkSP)            EPchunkSP{iChunk}=dataChunk;        else            EPchunk{iChunk}=dataChunk;        end    else        ep_tictoc('ioStart');        eval (['save ''' inFile '-' num2str(iChunk) '.mat'' dataChunk']);        ep_tictoc('ioFinish');    end    if standAlone        try            MATLABver=ver('MATLAB');            [a b]=strtok(MATLABver.Version,'.');            b=b(2:end);            if ~isprop(butterflyFig,'Number')                eval (['print -f' num2str(butterflyFig{iChunk}) ' -djpeg ''' inFile '''-' num2str(iChunk) 'EOG.jpg']);            else                eval (['print -f' num2str(butterflyFig{iChunk}.Number) ' -djpeg ''' inFile '''-' num2str(iChunk) 'EOG.jpg']);            end        catch            disp('Couldn''t save a copy of the artifact correction figure.  Perhaps your version of Matlab is not current.');        end        close(butterflyFig{iChunk});    end    subtractedHsacTopo=subtractedHsacTopo+mean(subtractedHsac,2,'omitnan');    subtractedVsacTopo=subtractedVsacTopo+mean(subtractedVsac,2,'omitnan');endtemplates.hSaccades.manual=zeros(length(EEGchans),1);templates.vSaccades.manual=zeros(length(EEGchans),1);if any(strcmp(templateSource, {'fileTemplate','bothTemplate'}))    if ~isempty(hSaccManualTemplate)        templates.hSaccades.manual(chans,1)=hSaccManualTemplate(chans);    end    if ~isempty(vSaccManualTemplate)        templates.vSaccades.manual(chans,1)=vSaccManualTemplate(chans);    endelse    templates.hSaccades.manual=[];    templates.vSaccades.manual=[];endtemplates.hSaccades.auto=zeros(length(EEGchans),1);templates.vSaccades.auto=zeros(length(EEGchans),1);if any(strcmp(templateSource, {'autoTemplate','bothTemplate','eyeTracker'}))    if ~isempty(hSaccAutoTemplate)        templates.hSaccades.auto(chans,1)=hSaccAutoTemplate(chans);    end    if ~isempty(vSaccAutoTemplate)        templates.vSaccades.auto(chans,1)=vSaccAutoTemplate(chans);    endelse    templates.hSaccades.auto=[];    templates.vSaccades.auto=[];endtemplates.hSaccades.hSaccadesTopo=subtractedHsacTopo(EEGchans,:);templates.vSaccades.vSaccadesTopo=subtractedVsacTopo(EEGchans,:);if ~isempty(butterflyFig)    graphCounter=graphCounter+2;end