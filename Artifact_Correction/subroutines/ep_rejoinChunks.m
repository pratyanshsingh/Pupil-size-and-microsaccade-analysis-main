function ep_rejoinChunks(inFileName, outFileName, outputFormat, chunkNum, eventSuffix, subjectSpecSuffix, theFunctionArgs)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ep_rejoinChunks(inFileName, outFileName, outputFormat, chunkNum) - rejoins file chunks into a full session file%%	Reads in file chunks generated by chunkInputFile function and writes them out%	as a reconstituted session file of the desired type.%%Inputs%	inFileName: filename (not including the .mat suffix or chunk number.  e.g., "NT5-01") and sourcepath.%	outFileName: Output filesname and sourcepath.  No suffix.%   outputFormat: The file format for the written out file.%	chunkNum: Number of chunks for subject%   eventSuffix: Suffix for event files if needed (e.g., "_evt.txt")%   subjectSpecSuffix : The suffix added to subject spec text files (e.g., "_sub.txt").%   theFunctionArgs: the arguments used for the artifact correction function call for addition to the .history field.%%	Inputs file chunks for each subject.%%Outputs%	Saves reconstituted session file.%% History:%% by Joseph Dien (8/00)% jdien07@mac.com%% modified 5/26/02 JD% output set to always be bigendian no matter what computer is running this code.%% bugfix 11/24/02 JD% closes output file when done.%% modified 5/27/03 JD% Renamed rejoinEGISchunks for greater clarity.%% bugfix 4/1/04 JD% Allow for spaces in file names.%% bugfix 3/22/07 JD% Eliminated warnings about rounding to 16 bits.%% modified 2/17/08 JD% Eliminated file type option for OS 9 macs as obsolete.%% modified (9/9/08) JD% Automatically sets File Type and Creator Type if on an OS X Mac%% modified (11/20/08) JD% Automatically sets montage type if on an OS X Mac.% Modified to accept chunks generated by chunkInputFile and thus a wider range of file formats.%% modified and bugfix (1/31/09) JD% allows for data with multiple events per trial but only one at stimulus onset.%% modified 3/14/09 JD% Changed to use EP format data to provide more flexibility with I/O functions.% and changed name to rejoinChunks.%% modified 6/22/09 JD% Added bad data fields from preprocessing.%% modified 9/22/09 JD% Modified to handle continuous files.%% bugfix 10/31/09 JD% Crash for non-continuous data files.  Thanks to Tim Curran.%% bugfix 11/2/09 JD% Crash for non-continuous data files that do not contain analysis fields when there is more than one chunk.%% modified 2/11/10 JD% analysis fields no longer optional.% %  modified 10/17/10 JD%  Added support for saccadeTrials and saccadeOnset fields.%% bugfix 6/12/12 JD% Fixed continuous files not handling .analysis fields correctly, resulting in crashes in later functions.%% bufix 3/11/14 JD% Handles decimal sampling rates gracefully.%%  bufix 4/8/14 JD%  Fixed retaining only editing information (in .analysis field) for first subject for average files, leading to crashes%  down the line.%% modified 7/29/14 JD% Adds are stripped out if the output file format is not ept.%% modified 9/17/14 JD% Adding event output for files that don't support events.%% bufix 5/13/16 JD% When combining chunks from continuous data, copy over events that were added during the preprocessing process to chunks other than the first one.%% modified 11/5/16 JD% Added support for writing out subject spec text files.%% bugfix 1/29/18 JD% Fixed not chunking single-trial data correctly, leading to crashes.%% modified 5/13/18 JD% Added updating of .history field.% % modified 6/23/19 JD% Accelerates artifact correction by adding option to keep chunks in RAM.% % modified 10/3/21 JD% Upgraded history field to provide more information on changes.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2025  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPchunk EPmainfor iChunk = 1:chunkNum    if exist('EPchunk','var') && ~isempty(EPchunk)        dataChunk=EPchunk{iChunk};    else        ep_tictoc('ioStart');        eval(['load ''' deblank(inFile) '-' num2str(iChunk) '.mat''']);        ep_tictoc('ioFinish');    end        if iChunk == 1        EPdata=dataChunk;    else        if strcmp('continuous',EPdata.dataType)            newNumPoints=length(dataChunk.timeNames);            oldNumPoints=length(EPdata.timeNames);            EPdata.data(:,end+1:end+newNumPoints,:,:,:,:)=dataChunk.data;            EPdata.timeNames(end+1:end+newNumPoints)=dataChunk.timeNames;            numChunkTrials=floor(size(dataChunk.data,2)/ceil(dataChunk.Fs)); %for last chunk, extra points will be attached to final segment            %events for continuous data will be the same across chunks except for new events added by artifact processing so find the last point of commonality and then take all the events after that            for iEvent=1:length(dataChunk.events{1})                if (iEvent > length(EPdata.events{1})) || (dataChunk.events{1}(iEvent).sample ~= EPdata.events{1}(iEvent).sample) || ~strcmp(dataChunk.events{1}(iEvent).value,EPdata.events{1}(iEvent).value)                    for iEvent2=iEvent:length(dataChunk.events{1})                        EPdata.events{1}(end+1)=dataChunk.events{1}(iEvent2);                        EPdata.events{1}(end).sample=EPdata.events{1}(end).sample+oldNumPoints;                    end                    break                end            end        else            numChunkTrials=length(dataChunk.cellNames);            EPdata.data(:,:,end+1:end+numChunkTrials,:,:,:)=dataChunk.data;            EPdata.events(:,end+1:end+numChunkTrials)=dataChunk.events;            EPdata.cellNames(end+1:end+numChunkTrials)=dataChunk.cellNames;            EPdata.cellTypes(end+1:end+numChunkTrials)=dataChunk.cellTypes;            EPdata.avgNum(end+1:end+numChunkTrials)=dataChunk.avgNum;            EPdata.subNum(end+1:end+numChunkTrials)=dataChunk.subNum;            EPdata.covNum(end+1:end+numChunkTrials)=dataChunk.covNum;            EPdata.recTime(end+1:end+numChunkTrials)=dataChunk.recTime;            EPdata.trialNames(end+1:end+numChunkTrials)=dataChunk.trialNames;            EPdata.trialSpecs(end+1:end+numChunkTrials,:)=dataChunk.trialSpecs;        end                EPdata.analysis.badChans(:,end+1:end+numChunkTrials,:)=dataChunk.analysis.badChans;        EPdata.analysis.badTrials(:,end+1:end+numChunkTrials)=dataChunk.analysis.badTrials;        EPdata.analysis.blinkTrial(:,end+1:end+numChunkTrials)=dataChunk.analysis.blinkTrial;        EPdata.analysis.saccadeTrial(:,end+1:end+numChunkTrials)=dataChunk.analysis.saccadeTrial;        EPdata.analysis.saccadeOnset(:,end+1:end+numChunkTrials)=dataChunk.analysis.saccadeOnset;        EPdata.analysis.moveTrial(:,end+1:end+numChunkTrials)=dataChunk.analysis.moveTrial;    endendif ~strcmp(outputFormat,'ep_mat')    EPdata=ep_stripAdds(EPdata);endtheDescription=['Artifact corrected the file ' outFileName '.'];EPdata.history=ep_addHistory(EPdata.history, EPmain.preferences.records, theDescription, EPmain.handles.hMainWindow, EPmain.preferences, EPmain.preferences.EPver,{outFileName});[err]=ep_writeData(EPdata,outFileName,eventSuffix,subjectSpecSuffix,outputFormat);