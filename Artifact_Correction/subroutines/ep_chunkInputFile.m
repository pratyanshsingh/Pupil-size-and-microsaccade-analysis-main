function [chunkNum] = ep_chunkInputFile(data, fnameout, chunkSize)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [chunkNum] = ep_chunkInputFile(data, fnameout, chunkSize)%                         writes out EP format data in chunks.%%   writes out data in chunks of chunkSize samples in length, except for%   the final two which are the size of the remaining samples divided in two.%	This is done to ensure that each chunk will be of sufficent size to%	characterize blinks with ICA.  Output file consists of the data structure%   with relevant fields (e.g., data, cellNames, etc. subset into chunks).%%Inputs%  EPdata         : Structured array with the data and accompanying information.  See readData.%	fnameout: Filename of output file.%	chunkSize: Number of samples to put in each sub file.%%Outputs%	chunkNum: Array of number of trials in each chunk.%% History:%% by Joseph Dien (10/00)% jdien07@mac.com%% modified 5/26/02 JD% added cross-platform endian support.  chunks will no longer cut trials in half.  % Correction made so filenames with a period do not cause errors.%% modified 10/11/02 JD% Moved chunk size check into this function so would not have to manually% specify trial size in blinkCorrection script.%% modified 10/20/02 JD% chunkSize does not have to be exact.  Program will figure exact number.%% modified 5/27/03 JD% Changed name to segmentEGISses from readEGISses for clarity's sake.  Fixed size% of last chunk when the last two are different sizes to avoid cutting a trial% in two.%% bugfix 4/1/04 JD% Allow for spaces in file names.%% modified (8/20/08) JD% Changed format of rd_PCAegis_hdr_v call.  Cleaned up endian code.%% modified (11/18/08) JD% Changed to use FieldTrip I/O in order to be able to read more formats.% Changed name to chunkInputFile to reflect this more general function.%% bugfix (11/24/08) JD% size of last chunk for multiple chunks not being figured correctly.%% modified (1/31/09) JD% allows for data with multiple events per trial but only one at stimulus onset.%% modified (2/9/09) JD% Dropped trialsize output field.%% modified 3/14/09 JD% Changed to use EP format data to provide more flexibility with I/O functions.%% modified 9/22/09 JD% Modified to handle continuous files.% Size of last two chunks for multiple chunks not being figured correctly.%% bugfix 10/31/09 JD% Crash when only one chunk and less trials than maximum allowed by chunk size.% Crash when more than two chunks.%% bugfix 11/2/09 JD% When there are multiple chunks, the last two are miscalculated such that they are data from earlier chunks.% Thanks to Siri Kamp.%% bugfix 11/10/09 JD% When there are multiple chunks, crash when there is an odd number of trials.%% bugfix 3/9/10 JD% When there are multiple chunks, crash when there is an odd number of trials.% %  modified 10/17/10 JD%  Added support for saccadeTrials and saccadeOnset fields.%% bugfix 6/12/12 JD% Fixed continuous files not handling .analysis fields correctly, resulting in crashes in later functions.%%  bufix 3/11/14 JD%  Handles decimal sampling rates gracefully.%%  bufix 4/8/14 JD%  Fixed retaining only editing information (in .analysis field) for first subject for average files, leading to crashes%  down the line.%% bugfix 12/14/15 JD% Fixed crash for continuous data.%% bugfix 1/29/18 JD% Fixed not chunking single-trial data correctly, leading to crashes.% % modified 2/3/18 JD% Changed chunkNum output to array of chunk sizes.%% bugfix 4/1/18 JD% Fixed not chunking average data correctly, leading to crashes.%% bugfix 11/3/18 JD% Fixed crash when chunking and there are no trial specs.% % modified 6/23/19 JD% Accelerates artifact correction by adding option to keep chunks in RAM.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2008  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPchunk EPchunkSP EPmainEPchunk=cell(0);if strcmp(data.dataType,'continuous')    numTrials=floor(size(data.data,2)/ceil(data.Fs)); %excess time points are tacked onto final epoch    trialSize = min(ceil(data.Fs),size(data.data,2)); %one second epochselse    numTrials = length(data.cellNames);    trialSize = length(data.timeNames);endnumChunkTrials = floor(chunkSize/trialSize);   %number of trials in a chunknumFiles = ceil(numTrials/numChunkTrials);if numChunkTrials > numTrials    numChunkTrials = numTrials;endif (mod(numTrials,numChunkTrials) ~= 0) && (numFiles > 1)    lastSize1 = floor((numTrials - ((numFiles-2)*numChunkTrials))/2); %divide the remaining trials evenly amongst the final two chunks    lastSize2 = ceil((numTrials - ((numFiles-2)*numChunkTrials))/2);else    lastSize1 = numChunkTrials;    lastSize2 = numChunkTrials;end%% Read in and write out the data%trialCounter=0;chunkNum=[];for iChunk = 1:numFiles    if iChunk == (numFiles-1)        nTrials = lastSize1;    elseif iChunk == (numFiles)        nTrials = lastSize2;    else        nTrials = numChunkTrials;    end    dataChunk = data;        if strcmp(dataChunk.dataType,'continuous')        if iChunk == (numFiles)            dataChunk.data=dataChunk.data(:,1+(trialCounter*trialSize):end,:,:,:,:);            dataChunk.timeNames=dataChunk.timeNames(1+(trialCounter*trialSize):end);        else            dataChunk.data=dataChunk.data(:,1+(trialCounter*trialSize):(nTrials*trialSize)+(trialCounter*trialSize),:,:,:,:);            dataChunk.timeNames=dataChunk.timeNames(1+(trialCounter*trialSize):(nTrials*trialSize)+(trialCounter*trialSize));        end    else        dataChunk.data=dataChunk.data(:,:,1+trialCounter:trialCounter+nTrials,:,:,:);        if ~isempty(dataChunk.trialNames)            dataChunk.trialNames=dataChunk.trialNames(1+trialCounter:trialCounter+nTrials);        end        if ~isempty(dataChunk.trialSpecs)            dataChunk.trialSpecs=dataChunk.trialSpecs(1+trialCounter:trialCounter+nTrials,:,:);        end        dataChunk.cellNames=dataChunk.cellNames(1+trialCounter:trialCounter+nTrials);        dataChunk.cellTypes=dataChunk.cellTypes(1+trialCounter:trialCounter+nTrials);        dataChunk.avgNum=dataChunk.avgNum(:,1+trialCounter:trialCounter+nTrials);        dataChunk.subNum=dataChunk.subNum(:,1+trialCounter:trialCounter+nTrials);        dataChunk.covNum=dataChunk.covNum(:,1+trialCounter:trialCounter+nTrials);        dataChunk.recTime=dataChunk.recTime(1+trialCounter:trialCounter+nTrials);        dataChunk.events=dataChunk.events(:,1+trialCounter:trialCounter+nTrials); %all the continuous chunks will contain the full set of events    end    chunkNum(end+1)=numel(dataChunk.data(1,:,:,:,:,:,:,:));        dataChunk.analysis.badChans=dataChunk.analysis.badChans(:,1+trialCounter:trialCounter+nTrials,:);    dataChunk.analysis.badTrials=dataChunk.analysis.badTrials(:,1+trialCounter:trialCounter+nTrials);    dataChunk.analysis.blinkTrial=dataChunk.analysis.blinkTrial(:,1+trialCounter:trialCounter+nTrials);    dataChunk.analysis.saccadeTrial=dataChunk.analysis.saccadeTrial(:,1+trialCounter:trialCounter+nTrials);    dataChunk.analysis.saccadeOnset=dataChunk.analysis.saccadeOnset(:,1+trialCounter:trialCounter+nTrials);    dataChunk.analysis.moveTrial=dataChunk.analysis.moveTrial(:,1+trialCounter:trialCounter+nTrials);        if EPmain.read.numEEG >=numFiles        EPchunk{iChunk}=dataChunk;    else        ep_tictoc('ioStart');        eval (['save ''' fnameout '''-' num2str(iChunk) '.mat dataChunk']);        ep_tictoc('ioFinish');    end    trialCounter=trialCounter+nTrials;end