function [totsaccadeTrialNum, templates, outputLog, graphCounter, icaFlag] = ep_fixSaccadePotential(inFile, outFile, startChunk, endChunk, badDataCriteria, badChans, eog, templateSource, saccadeFile, refChan, excludePoints, butterflyFig, graphCounter, numGraphs, theSubject, SPmethod, icaFlag, scanFlag)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [templates, outputLog, graphCounter, icaFlag] = ep_fixSaccadePotential(inFile, outFile, startChunk, endChunk, badDataCriteria, badChans, eog, templateSource, saccadeFile, refChan, excludePoints, butterflyFig, graphCounter, numGraphs, theSubject, SPmethod, icaFlag, scanFlag)%%	Reads in file chunks generated by chunkInputFile function and corrects and marks saccade potentials.%   A canonical saccade potential is used to automatically construct a custom template based on all the chunks which is then used%   to perform a full correction run.%%Inputs%	inFile:     filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	outFile:    filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	startChunk: starting chunk (usually 1)%   endChunk:   ending chunk%   badDataCriteria:  Criteria for detecting bad data.%       .window:    moving average window for smoothing%       .minmax:    difference from minimum to maximum for bad channel%       .trialminmax:  difference from minimum to maximum for bad trial%       .badnum:    percent of bad channels exceeded to declare bad trial, rounding down%       .hminmax:   difference from minimum to maximum for bad horizontal EOG%       .neighbors: number of electrodes considered to be neighbors%       .badchan:   maximum microvolt difference allowed from best matching neighbor%       .maxneighbor:   maximum microvolt difference allowed from best matching neighbor%       .blink:     threshold correlation with blink template, 0 to 1%       .saccade:     threshold correlation with saccade template, 0 to 1%       .saccademin:  µv Saccade Fac is the minimum HEOG voltage difference required to constitute a possible saccade.%       .detrend:   1 to detrend%       .badtrials: percentage of good trials chan is bad to declare a channel globally bad%       .replace:   1 to interpolate bad channels from neighbors.%       .noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad)%       .movefacs  : number of factors to retain during movement correction.%       .channelMode: 'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing.%       .trialMode: 'fix' to fix bad trial data and 'none' to do nothing.%       .saturation: followed by range of acceptable data values.  Time points with a channel outside this range will be excluded.%   badChans:   list of global bad channels to exclude from saccade potential detection process.%   eog:        EOG channels.%   templateSource:   source of saccade templates (fileTemplate: load file.  autoTemplate: automatically generate saccade potential template.%                  bothTemplate: check automatic template and then manual template).%   saccadeFile:  file with saccade templates.  Assumed to be in the same directory as the data file.%   refChan:    Array of current reference channels.%   excludePoints: time points to exclude, numbering end-to-end for single-trial data (cell array of number of chunks)%   butterflyFig:  the handle for the output figure.  Otherwise, will open a new figure.%   graphCounter: the current subplot for the summary figure.%   numGraphs: the total number of subgraphs in the summary figure.%   theSubject: which subject of the file is being processed.%   SPmethod  : 'vector' for vector template method else name of ICA rotation.%   icaFlag   : flag for single-step ICA procedure.  'none': not in use.  'needToSave': need to run ICA and then save temp file.  'saved': temp file already saved so read it in.%   scanFlag  : flag for precorrection scan to identify blink points.%%   The input chunks are EP format data files.%%Outputs%	Saves files with saccade potential removed, replacing the original chunked files.%   templates: the templates used for the correction, both file and auto if both used.  Returns empty if error occurs.%       .sacPot%           .manual: manual template from file (number of EEG channels,1)%           .auto: auto template (number of EEG channels,1)%   outputLog: output messages from saccade potential fixing process%   graphCounter: the current subplot for the summary figure.%   icaFlag   : flag for single-step ICA procedure.  'none': not in use.  'needToSave': need to run ICA and then save temp file.  'saved': temp file already saved so read it in.%% History:%% by Joseph Dien (2/5/17)% jdien07@mac.com%% modified 4/18/17 JD% Excludes time points beyond a certain range from global bad channel detection, blink, and saccade routines.%% bugfix 10/4/17 JD% Median corrects data prior to saturation check to ensure channels with merely high offsets are not treated as bad data.% Saccade Potential correction works with sampling rates other than 250 Hz.%   `% bugfix 10/5/17 JD% Fixed crashes due to Matlab changing their graphics objects AGAIN in 2017b.%% bugfix 10/20/17 JD% Eliminated x tick labels to address problem with subplots in summary% artifact figure getting squeezed by formatting problem on PCs.%% bugfix 10/5/17 JD% Fixed crash when preprocessing data containing impedance values.% Fixed crash when preprocessing multi-subject average files.%% bugfix 12/13/17 JD% Fixed saccade potential preprocessing crashing when channels marked as being missing in preprocessing preferences with a -1.% Fixed bugs causing saccade potential to not work as effectively for single-trial data.%% modified 2/4/18 JD% Made subplot specification for summary figure output more flexible.%% modified 4/8/18 JD% Consolidated summary figure for average files so no longer one per subject.%% bugfix 11/2/18 JD% Fixed crash when no saccade potentials detected.%% bugfix 1/13/19 JD% Fixed not identifying Cz channel correctly.  My figuring of EEGlab MNI coordinate of Cz wrong so back to original coordinate.%% bugfix 6/13/19 JD% Fixed crash when data has no events.% % modified 7/7/19 JD% Accelerates artifact correction by adding option to keep chunks in RAM.% Now excludes global bad channels from summary subplot.%% bugfix 9/17/19 JD% Fixed crash when there is a global bad channel.% Fixed only summary plot output for first chunk when template formation fails.%% bugfix 10/29/19 JD% Fixed crash when the events structure is empty.%% bugfix 11/3/19 JD% Fixed crash when there are bad channels.%% bugfix 1/30/20 JD% Fixed not correcting single-trial data correctly.% Improved auto spike potential correction with the use of a grand average template since it seems to be pretty consistent across subjects.% Now corrects the subsequent Pz positivity as well as the initial Pz negativity% Fixed not rereferencing data to Pz when using manual template.% % modified 2/4/20 JD% Now remaps file template if it is for a different electrode montage.% % bugfix 3/27/20 JD% Fixed crash.% % modified & bugfix 6/11/20 JD% Fixed not using outFile name when saving EPchunk to disk rather than to RAM.% Added ICA options for SP artifact correction.% Added eye artifact control to specify EMCP, MAAC, or single-step ICA options.% % modified 7/16/20 JD% No longer changes voltages outside of saturation range into NaN.%% bugfix 9/21/20 JD% Fixed crash when chunking data.% % modified 10/14/20 JD% When using "vector" method and original reference is unknown, now provides alert that the data are now in Cz reference and updates the file's reference information accordingly.% % modified 11/8/20 JD% Added scanFlag flag.%% bugfix 11/19/20 JD% Fixed crash when merging files with subject specs.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2025  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPchunk EPchunkSP EPtictoctemplates=[];msg='Starting saccadic spike potentials routine.';disp(msg);outputLog{1}=msg;totsaccadeTrialNum=[];badChans=badChans(:); %make sure it's a column vectortemplateSPthresh=badDataCriteria.sacpot;SPminSep=80; %ms minimum separation between saccade potentialsif ~exist('butterflyFig','var')    butterflyFig=figure('Name','Artifact Correction','NumberTitle','off');    colormap jet;    standAlone=1;else    standAlone=0;endif ~isempty(butterflyFig)    graphCounter=graphCounter+2;endtheEOG(1) = eog.LUVEOG;theEOG(2) = eog.RUVEOG;theEOG(3) = eog.LLVEOG;theEOG(4) = eog.RLVEOG;theEOG(5) = eog.LHEOG;theEOG(6) = eog.RHEOG;VEOG=[];goodVEOG=[];for i=1:4    if isempty(intersect(theEOG(i),badChans)) && (theEOG(i) ~= -1)        VEOG=[VEOG theEOG(i)];        goodVEOG(end+1)=i;    endendblinksign = [1 1 -1 -1]';blinksign=blinksign(goodVEOG,1);HEOG=[];for i=5:6    if isempty(intersect(theEOG(i),badChans)) && (theEOG(i) ~= -1)        HEOG=[HEOG theEOG(i)];    endend[fileDir, name, ext] = fileparts(inFile);if exist('EPchunk','var') && ~isempty(EPchunk)    if exist('EPchunkSP','var') && ~isempty(EPchunkSP) && isstruct(EPchunkSP{1})        dataChunk=EPchunkSP{1};    else        dataChunk=EPchunk{1};    endelse    ep_tictoc('ioStart');    eval(['load ''' deblank(inFile) '-' num2str(1) '.mat''']);    ep_tictoc('ioFinish');endnumChans=length(dataChunk.chanNames);numSubs=length(dataChunk.subNames);EEGchans=find(strcmp('EEG',dataChunk.chanTypes));chans = setdiff(EEGchans,badChans);if dataChunk.Fs < 200    msg='The sampling rate needs to be at least 200 Hz to correct saccade potentials.';    outputLog{end+1}=msg;    disp(' ');    disp('**************************************************************');    disp(msg);    disp('**************************************************************');    disp(' ');    returnendeloc=dataChunk.eloc;[czChan, theOrder] = ep_findChan(dataChunk.eloc, dataChunk.implicit, dataChunk.chanNames, dataChunk.ced, badChans, 'Cz', dataChunk.montage);if (czChan ==0) || isempty(czChan)    msg='No good chans so aborting saccade potential correction.';    outputLog{end+1}=msg;    disp(' ');    disp('**************************************************************');    disp(msg);    disp('**************************************************************');    disp(' ');    returnendVEOG(end+1)=czChan;blinksign(end+1)=0;numVEOG=length(VEOG);if theOrder > 1    msg=['Cz is a bad channel so instead using channel ' eloc(VEOG(end)).labels '.'];elseif strcmpi(eloc(VEOG(end)).labels,'cz')    msg=['Channel Cz identified.'];else    msg=['Channel ' eloc(VEOG(end)).labels ' is identified as being the closest good channel to Cz.'];endoutputLog{end+1}=msg;disp(msg);cannonicalSPthresh=25; %microvolt threshold for detecting an SP when constructing the automatic templatefourMS=ceil(4/(1000/(dataChunk.Fs))); %how many samples provides at least 4 msoutputLog=[];SPmanualTemplate=[];SPautoTemplateL=[];SPautoTemplateR=[];if any(strcmp(templateSource, {'fileTemplate','bothTemplate'}))    [fileDir, name, ext] = fileparts(inFile);    ep_tictoc('ioStart');    eval(['load ''' saccadeFile '''']);    ep_tictoc('ioFinish');        if ~exist('EPsacPot','var')        errMsg{1}='Not a saccade template.';        [msg]=ep_errorMsg(errMsg);        return    end        if ~isfield(EPsacPot,'sacPot')        errMsg{1}='No saccadic spike potential template in spike potential template file.';        [msg]=ep_errorMsg(errMsg);        return    end        SPmanualTemplate=EPsacPot.sacPot.template;    %if the template is different from the dataset, remap the template    if (length(EPsacPot.eloc) ~= length(EEGchans)) || any([EPsacPot.eloc.theta]-[dataChunk.eloc.theta]) || any([EPsacPot.eloc.radius]-[dataChunk.eloc.radius])        newData=ep_interpChans(SPmanualTemplate, EPsacPot.eloc, dataChunk.eloc(EEGchans));        ep_tictoc;if EPtictoc.stop;return;end        if isempty(newData)            return        else            SPmanualTemplate=newData;        end    endendif any(strcmp(templateSource, {'autoTemplate','bothTemplate','eyeTracker'}))    priorPoints=0;    for iChunk = startChunk:endChunk        if endChunk > startChunk            msg=[deblank(inFile) '-' num2str(iChunk)];            disp(msg);            outputLog{end+1}=msg;        end        if exist('EPchunk','var') && ~isempty(EPchunk)            if exist('EPchunkSP','var') && ~isempty(EPchunkSP) && isstruct(EPchunkSP{iChunk})                dataChunk=EPchunkSP{iChunk};            else                dataChunk=EPchunk{iChunk};            end        else            ep_tictoc('ioStart');            eval(['load ''' deblank(inFile) '-' num2str(iChunk) '.mat''']);            ep_tictoc('ioFinish');        end                if strcmp(dataChunk.dataType,'continuous')            theSegment = 'one second epoch';        else            theSegment = 'trial';        end                if length(dataChunk.facNames) > 1            msg='This function is not intended for application to factor data.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end                trialdata=dataChunk.data(:,:,:,theSubject);        contData=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);                if strcmp(dataChunk.dataType,'continuous')            displayPeriod=size(trialdata,2);    %Number of timepoints to graph in display.        else            displayPeriod=size(trialdata,2)*size(trialdata,3);        end        decimateSamples=ceil(max(1,displayPeriod/10000));        totalDisplayPeriod=displayPeriod*size(dataChunk.data,4);                if displayPeriod == 1            msg='There is only one time point and so the data cannot be saccadic spike potential corrected.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end                if iChunk ==1            autoCountL=0;            autoCountR=0;            SPautoTemplateL=zeros(length(EEGchans),1);            SPautoTemplateR=zeros(length(EEGchans),1);        end                if strcmp(dataChunk.dataType,'continuous')            numTrials=1; %excess time points are tacked onto final epoch            trialSize = length(dataChunk.timeNames);        else            trialSize = length(dataChunk.timeNames);            numTrials = length(dataChunk.cellNames);        end                goodPoints = find(any(~isnan(trialdata(chans,:))));%         goodPoints = find((max(contData(chans,:)-repmat(median(contData(chans,:)')',1,size(contData(chans,:),2))) < badDataCriteria.saturation(2)) & (min(contData(chans,:)-repmat(median(contData(chans,:)')',1,size(contData(chans,:),2))) > badDataCriteria.saturation(1)));                goodPoints=setdiff(goodPoints,excludePoints{iChunk});                %automatically construct a custom template        if strcmp(templateSource, 'eyeTracker') && ~isempty(dataChunk.events{1})            saccadeSamps=round([dataChunk.events{1}(find(strcmp('saccadeET',{dataChunk.events{1}.value}))).sample]);            saccadeSamps=saccadeSamps-priorPoints;            saccadeSamps=saccadeSamps((saccadeSamps > 0) & (saccadeSamps <= size(contData,2))); %only saccadeET events in the current data chunk.            SPautoTemplate=mean(contData(chans,saccadeSamps+1*fourMS),2)-mean(contData(chans,saccadeSamps),2);            autoCount=1;        elseif length(HEOG) ~= 2            disp('Need both HEOG channels to form custom template');        else            boundaryPoints=[];            for iTrial=1:size(dataChunk.data,3)                ep_tictoc;if EPtictoc.stop;return;end                if ~isempty(dataChunk.events{iTrial})                    boundaryPoints=[dataChunk.events{iTrial}(find(strcmp('boundary',{dataChunk.events{iTrial}.type}))).sample];                end                diffData=diff(dataChunk.data(VEOG,:,iTrial,theSubject),1,2);                theData=squeeze(diffData(:,:,1,1))-repmat(diffData(numVEOG,:,1,1),numVEOG,1); %rereference to Cz                theData=theData(1:numVEOG-1,:); %drop Cz, which is now a flat line                pointList=[];                trialGoodPoints=find((goodPoints >= (((iTrial-1)*trialSize)+1)) & (goodPoints <= (iTrial*trialSize)));                for iPoint=1:size(theData,2)-2                    if ismember(iPoint,trialGoodPoints) && ismember(iPoint+(2*fourMS),trialGoodPoints) && ~any(ismember([iPoint:iPoint+(2*fourMS)],boundaryPoints))                        if all(theData(:,iPoint) <= -cannonicalSPthresh) && all(theData(:,iPoint+(2*fourMS)) >= cannonicalSPthresh) %in the VEOG channels, look for a negative spike where iPoint is just as it starts and iPoint+2 is the peak (diff = Xt1 - Xt)                            if isempty(pointList) || (pointList(end) < (iPoint-(fourMS)*2))                                putativeSP=(trialdata(chans,iPoint+fourMS,iTrial,theSubject)-trialdata(VEOG(end),iPoint+fourMS,iTrial,theSubject))-(trialdata(chans,iPoint,iTrial,theSubject)-trialdata(VEOG(end),iPoint,iTrial,theSubject)); %Cz referenced                                if all(putativeSP < 100) %must be less than 100 uv to exclude blinks and other artifacts                                    EOGx=min([dataChunk.eloc(goodVEOG(1:end-1)).X]);                                    if max(putativeSP([goodVEOG(1:end-1)])) < min(putativeSP(find(ismember(chans,find(EOGx>[dataChunk.eloc.X])))))                                        pointList(end+1)=iPoint;                                        thePoints=[4*fourMS:12*fourMS]+iPoint;                                        SPdir=[ones(length(thePoints),1),thePoints']\(trialdata(eog.LHEOG,thePoints,iTrial)-trialdata(eog.RHEOG,thePoints,iTrial))'; %CRD is positive towards direction of gaze                                        if SPdir(2) > 0                                            autoCountL=autoCountL+1;                                            SPautoTemplateL(chans)=SPautoTemplateL(chans)+(trialdata(chans,iPoint+fourMS,iTrial,theSubject)-trialdata(chans,iPoint,iTrial,theSubject));                                        else                                            autoCountR=autoCountR+1;                                            SPautoTemplateR(chans)=SPautoTemplateR(chans)+(trialdata(chans,iPoint+fourMS,iTrial,theSubject)-trialdata(chans,iPoint,iTrial,theSubject));                                        end                                    end                                end                            end                        end                    end                end            end        end        priorPoints=priorPoints+size(trialdata,2);    end    if (autoCountL == 0) && (autoCountR == 0)        msg='No automatic template could be formed.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        if any(strcmp(templateSource, {'autoTemplate','eyeTracker'}))            if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})                for iChunk = startChunk:endChunk                    if numSubs > 1                        theTitle='subtracted saccade potentials';                    else                        theTitle='no saccade potentials to subtract that were detected';                    end                    plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,zeros(size(contData)),chans,theSubject);                    figure(butterflyFig{iChunk});                    subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);                    title(theTitle,'Interpreter','none');                    axis([1 totalDisplayPeriod -200 200])                    set(gca,'XTickLabel','','XTick',[]);                                        if numSubs > 1                        theTitle='with saccade potentials subtracted';                    else                        theTitle='no saccade potentials subtracted';                    end                    plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,contData,chans,theSubject);                    subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);                    title(theTitle,'Interpreter','none');                    axis([1 totalDisplayPeriod -200 200])                    set(gca,'XTickLabel','','XTick',[]);                end            end            return;        elseif strcmp(templateSource, 'bothTemplate')            templateSource='fileTemplate';        end    else        if autoCountL == 0            msg='No left automatic template could be formed so will use flipped right template.';            disp(msg);            outputLog{end+1}=msg;                        autoCountL=autoCountR;            oldElocs=dataChunk.eloc;            newElocs=oldElocs;            for iEloc=1:length(newElocs)                newElocs(iEloc).theta=-newElocs(iEloc).theta; %flip L/R            end            newData=ep_interpChans(SPautoTemplateR(chans), oldElocs(chans), newElocs(chans));            ep_tictoc;if EPtictoc.stop;return;end            if isempty(newData)                return            else                SPautoTemplateL(chans)=newData;            end        end        if autoCountR == 0            msg='No right automatic template could be formed so will use flipped left template.';            disp(msg);            outputLog{end+1}=msg;                        autoCountR=autoCountL;            oldElocs=dataChunk.eloc;            newElocs=oldElocs;            for iEloc=1:length(newElocs)                newElocs(iEloc).theta=-newElocs(iEloc).theta; %flip L/R            end            newData=ep_interpChans(SPautoTemplateL(chans), oldElocs(chans), newElocs(chans));            ep_tictoc;if EPtictoc.stop;return;end            if isempty(newData)                return            else                SPautoTemplateR(chans)=newData;            end        end        SPautoTemplateL(chans)=SPautoTemplateL(chans)./autoCountL;        SPautoTemplateR(chans)=SPautoTemplateR(chans)./autoCountR;        SPautoTemplateL(chans)=SPautoTemplateL(chans)-SPautoTemplateL(find(VEOG(end)==EEGchans));        SPautoTemplateR(chans)=SPautoTemplateR(chans)-SPautoTemplateR(find(VEOG(end)==EEGchans));    endend%use the template to better detect saccade potentialssubtractedSacPotTopo=zeros(length(EEGchans),1);for iChunk = startChunk:endChunk        if startChunk ~= endChunk        if exist('EPchunk','var') && ~isempty(EPchunk)            if exist('EPchunkSP','var') && ~isempty(EPchunkSP) && isstruct(EPchunkSP{iChunk})                dataChunk=EPchunkSP{iChunk};            else                dataChunk=EPchunk{iChunk};            end        else            ep_tictoc('ioStart');            eval(['load ''' deblank(inFile) '-' num2str(iChunk) '.mat''']);            ep_tictoc('ioFinish');        end    end        if length(dataChunk.facNames) > 1        msg='This function is not intended for application to factor data.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end        trialdata=dataChunk.data(:,:,:,theSubject);    contData=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);        if strcmp(dataChunk.dataType,'continuous')        displayPeriod=size(trialdata,2);    %Number of timepoints to graph in display.    else        displayPeriod=size(trialdata,2)*size(trialdata,3);    end    totalDisplayPeriod=displayPeriod*size(dataChunk.data,4);    decimateSamples=ceil(max(1,totalDisplayPeriod/10000));    if displayPeriod == 1        msg='There is only one time point and so the data cannot be saccadic spike potential corrected.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end        %     if strcmp(dataChunk.dataType,'continuous')    %         numTrials=floor(size(trialdata,2)/ceil(dataChunk.Fs)); %excess time points are tacked onto final epoch    %         trialSize = min(ceil(dataChunk.Fs),size(trialdata,2)); %one second epochs    %     else    %         trialSize = length(dataChunk.timeNames);    %         numTrials = length(dataChunk.cellNames);    %     end        if strcmp(dataChunk.dataType,'continuous')        numTrials=1; %excess time points are tacked onto final epoch        trialSize = length(dataChunk.timeNames);    else        trialSize = length(dataChunk.timeNames);        numTrials = length(dataChunk.cellNames);    end    goodPoints = find(any(~isnan(contData(chans,:))));%     goodPoints = find((max(contData(chans,:)-repmat(median(contData(chans,:)')',1,size(contData(chans,:),2))) < badDataCriteria.saturation(2)) & (min(contData(chans,:)-repmat(median(contData(chans,:)')',1,size(contData(chans,:),2))) > badDataCriteria.saturation(1)));        goodPoints=setdiff(goodPoints,excludePoints{iChunk});        if strcmp(SPmethod,'vector')                count=0;        SPwaveAL=zeros(size(trialdata,3),size(trialdata,2)-1);        SPwaveAR=zeros(size(trialdata,3),size(trialdata,2)-1);        SPwaveM=zeros(size(trialdata,3),size(trialdata,2)-1);        subtractedSPs =zeros(size(trialdata));        sacPotEOG=zeros(1,size(trialdata,2),size(trialdata,3));        EEGchansNoHEOG=setdiff(chans,[eog.LHEOG eog.RHEOG]);        chansNoHEOG=find(~ismember(chans,[eog.LHEOG eog.RHEOG]));        saccadeTrialNum{iChunk}=dataChunk.analysis.saccadeTrial;        saccadeOnsetNum{iChunk}=dataChunk.analysis.saccadeOnset;        if any(strcmp(templateSource, {'autoTemplate','bothTemplate','eyeTracker'}))            saccadesScaleAL=abs(SPautoTemplateL(find(VEOG(end)==EEGchans))-mean(SPautoTemplateL(find(ismember(EEGchans,VEOG(blinksign == -1))))));            saccadesScaleAR=abs(SPautoTemplateR(find(VEOG(end)==EEGchans))-mean(SPautoTemplateR(find(ismember(EEGchans,VEOG(blinksign == -1))))));        end        if any(strcmp(templateSource,{'fileTemplate','bothTemplate'}))            saccadesScaleM=abs(SPmanualTemplate(find(VEOG(end)==EEGchans))-mean(SPmanualTemplate(find(ismember(EEGchans,VEOG(blinksign == -1))))));        end        fprintf('%60s\n',' ' );        for iTrial=1:size(dataChunk.data,3)            ep_tictoc;if EPtictoc.stop;return;end            fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Working on Segment# '], iTrial, numTrials))            if any(strcmp(templateSource, {'autoTemplate','bothTemplate','eyeTracker'}))                SPwaveAL(iTrial,:)=(-SPautoTemplateL(chansNoHEOG)'*squeeze(diff(dataChunk.data(EEGchansNoHEOG,:,iTrial,theSubject)-repmat(dataChunk.data(VEOG(end),:,iTrial,theSubject),length(EEGchansNoHEOG),1),1,2)))/(length(EEGchansNoHEOG)*saccadesScaleAL);  %drop HEOG channels from template as they are too variable                SPwaveAR(iTrial,:)=(-SPautoTemplateR(chansNoHEOG)'*squeeze(diff(dataChunk.data(EEGchansNoHEOG,:,iTrial,theSubject)-repmat(dataChunk.data(VEOG(end),:,iTrial,theSubject),length(EEGchansNoHEOG),1),1,2)))/(length(EEGchansNoHEOG)*saccadesScaleAR);  %drop HEOG channels from template as they are too variable            end            if any(strcmp(templateSource,{'fileTemplate','bothTemplate'}))                SPwaveM(iTrial,:)=(-SPmanualTemplate(chansNoHEOG)'*squeeze(diff(dataChunk.data(EEGchansNoHEOG,:,iTrial,theSubject)-repmat(dataChunk.data(VEOG(end),:,iTrial,theSubject),length(EEGchansNoHEOG),1),1,2)))/(length(EEGchansNoHEOG)*saccadesScaleM);  %drop HEOG channels from template as they are too variable            end            if ~isempty(dataChunk.events{iTrial})                boundaryPoints=[dataChunk.events{iTrial}(find(strcmp('boundary',{dataChunk.events{iTrial}.type}))).sample];            else                boundaryPoints=[];            end            pointList2=[];            for iPoint=1:size(trialdata,2)-(6*fourMS)-1                if all(ismember(iPoint:iPoint+(3*fourMS),goodPoints)) && ~any(ismember(iPoint:iPoint+(3*fourMS),boundaryPoints))                    SPdur=0; %duration of the SP in 4ms increments                    if any(strcmp(templateSource, {'autoTemplate','bothTemplate','eyeTracker'}))                        if SPwaveAL(iTrial,iPoint) < SPwaveAR(iTrial,iPoint)                            SPwaveA=SPwaveAL;                            SPTemplate=SPautoTemplateL;                        else                            SPwaveA=SPwaveAR;                            SPTemplate=SPautoTemplateR;                        end                        if (SPwaveA(iTrial,iPoint) <= -(templateSPthresh/2)) && (SPwaveA(iTrial,iPoint+(2*fourMS)) >= templateSPthresh) %the second time points has a larger threshold because the onset of the saccade makes the voltages more variable so more conservative threshold needed.                            SPdur=2;                        elseif (SPwaveA(iTrial,iPoint) <= -(templateSPthresh/2)) && (SPwaveA(iTrial,iPoint+(1*fourMS)) >= templateSPthresh)                            SPdur=1;                        end                    end                    if any(strcmp(templateSource,{'fileTemplate','bothTemplate'})) && (SPdur == 0)                        if (SPwaveM(iTrial,iPoint) <= -(templateSPthresh/2)) && (SPwaveM(iTrial,iPoint+(2*fourMS)) >= templateSPthresh)                            SPdur=2;                        elseif (SPwaveM(iTrial,iPoint) <= -(templateSPthresh/2)) && (SPwaveM(iTrial,iPoint+(1*fourMS)) >= templateSPthresh)                            SPdur=1;                        end                        SPTemplate=SPmanualTemplate;                    end                    if SPdur > 0                        B=[ones(1,3*fourMS+1);1:3*fourMS+1]'\[mean(trialdata(VEOG(blinksign == 1),iPoint+1+(3*fourMS):iPoint+1+(6*fourMS),iTrial),1)]'; %correction factor for effects of vertical saccades on the saccade potential                        %ensure the upper VEOG channels actually have the appropriate temporal morphology                        if mean(mean(trialdata(VEOG(blinksign == 1),[iPoint iPoint+1+(SPdur*fourMS)],iTrial))) - mean(mean(trialdata(VEOG(blinksign == 1),iPoint+1:iPoint+(SPdur*fourMS),iTrial))) -B(2)/2  >= (templateSPthresh/10)                            if isempty(pointList2) || (pointList2(end) < (iPoint-(fourMS*SPminSep/4))) %enforce minimum spacing for SacPot events                                pointList2(end+1)=iPoint;                                count=count+1;                                saccadeTrialNum{iChunk}(theSubject,iTrial)=1;                                if ~saccadeOnsetNum{iChunk}(theSubject,iTrial)                                    saccadeOnsetNum{iChunk}(theSubject,iTrial)=iPoint+1; %assumes no more than one saccade per trial.  If more than only the first one will be recorded.                                end                                if strcmp(dataChunk.dataType,'continuous')                                    dataChunk.events{theSubject,iTrial}(end+1).sample=iPoint+1;                                    dataChunk.events{theSubject,iTrial}(end).type='artifact';                                    dataChunk.events{theSubject,iTrial}(end).value='SacPot';                                    dataChunk.events{theSubject,iTrial}(end).duration=0;                                    dataChunk.events{theSubject,iTrial}(end).keys=struct('code','','data','','datatype','','description','');                                else                                    dataChunk.events{theSubject,iTrial}(end+1).sample=iPoint+1;                                    dataChunk.events{theSubject,iTrial}(end).type='artifact';                                    dataChunk.events{theSubject,iTrial}(end).value='SacPot';                                    dataChunk.events{theSubject,iTrial}(end).duration=0;                                    dataChunk.events{theSubject,iTrial}(end).keys=struct('code','','data','','datatype','','description','');                                end                                for iDur=1:(SPdur+1)*fourMS %correct the subsequent Pz positivity as well as the initial Pz negativity                                    %SPamp=mean(diff(trialdata(VEOG(blinksign == 1),[iPoint iPoint+iDur]),1,2))/mean(SPTemplate(VEOG(blinksign == 1)));                                    SPamp=[ones(length(EEGchansNoHEOG),1),SPTemplate(chansNoHEOG)]\[diff(trialdata(EEGchansNoHEOG,[iPoint iPoint+iDur],iTrial),1,2)];                                    trialdata(chans,iPoint+iDur,iTrial)=trialdata(chans,iPoint+iDur,iTrial)-(SPTemplate(chans)*SPamp(2)+SPamp(1));                                    sacPotEOG(1,iPoint+iDur,iTrial)=SPamp(2);                                    subtractedSPs(chans,iPoint+iDur,iTrial)=SPTemplate(chans)*SPamp(2)+SPamp(1);                                end                            end                        end                    end                end            end        end        fprintf('%60s\n',' ' );            else        if (length(refChan) == 1) && std(contData(refChan(1),:)','omitnan') == 0 && ismember(refChan(1),chans)            chans(chans==refChan(1))=[];     %temporarily take first reference site out of ICA            refFlag=refChan(1);        else            refFlag=[];        end                pointList2=[]; %ICA method doesn't result in identifying specific SPs        saccadeTrialNum{iChunk}=dataChunk.analysis.saccadeTrial;        saccadeOnsetNum{iChunk}=dataChunk.analysis.saccadeOnset;                NUM_FAC=length(chans);        dataRank=rank(contData(chans,goodPoints));        msg=['The rank of the saccade data was: ' num2str(dataRank)];        disp(msg);        outputLog{end+1}=msg;        if dataRank < NUM_FAC            msg=['Dropping ' num2str(NUM_FAC-dataRank) ' dimensions due to singular data matrix (bridged channels can cause this, or simply very similar channels).'];            disp(msg);            outputLog{end+1}=msg;            NUM_FAC = dataRank;        end        saccTrialData=nan(size(contData));        saccTrialData(chans,goodPoints)=contData(chans,goodPoints);                if strcmp(icaFlag,'saved')            load([fileDir filesep 'ICAresults']);        else            switch SPmethod                case {'Infomax','Extended-Infomax'}                    rotOpt=1;                    rng(0,'twister'); %sets random number generator to standardized start to ensure replicability of Infomax results.                    [FactorResults] = ep_doPCA('asis', SPmethod, rotOpt, 'SVD', 'COV', NUM_FAC, saccTrialData(chans,:)', 'N');                case 'SOBI'                    rotOpt=floor(400/(1000/dataChunk.Fs));                    %for SOBI, the data needs to be organized into a 3D matrix with trials so that the time lags don't get extended past epoch limits.  Even for continuous, will do as one second epochs to handle bad points.                    if strcmp(dataChunk.dataType,'continuous')                        saccTrialData=reshape(saccTrialData(:,1:size(saccTrialData,2)-rem(size(saccTrialData,2),dataChunk.Fs)),numChans,dataChunk.Fs,[]); %for bad timepoint exclusion to work, need to split up continuous recording into one second epochs                        for iEvent=1:length(dataChunk.events{1})                            if strcmp('boundary',dataChunk.events{1}(iEvent).type)                                saccTrialData(:,:,floor((dataChunk.events{1}(iEvent).sample-1)/dataChunk.Fs)+1)=NaN; %if a boundary event lands in the middle of an epoch, exclude the entire epoch                            end                        end                    else                        numPoints=length(dataChunk.timeNames);                        numSubs=length(dataChunk.subNames);                        numCells=length(dataChunk.cellNames);                        saccTrialData=reshape(saccTrialData,numChans,numPoints,[]);                        for iSub=1:numSubs                            for iCell=1:numCells                                if ~isempty(dataChunk.events(iSub,iCell))                                    if any(strcmp('boundary',{dataChunk.events{iSub,iCell}.type}))                                        saccTrialData(:,:,((iSub-1)*numSubs*numCells+(iCell-1)*numCells)+1)=NaN; %if a boundary event lands in the middle of an epoch, exclude the entire epoch                                    end                                end                            end                        end                    end                    [FactorResults] = ep_doPCA('asis', SPmethod, rotOpt, 'SVD', 'COV', NUM_FAC, saccTrialData(chans,:,:), 'N');                                        %             [H]=sobi(saccTrialData(chans,:,:),NUM_FAC,rotOpt);                    %             FactorResults.varSD=mean(reshape(saccTrialData(chans,:,:),length(chans),[])');                    %             FactorResults.FacPat=H;                    %             FactorResults.FacScr=reshape(saccTrialData(chans,:,:),length(chans),[])'*pinv(H)';                otherwise                    [FactorResults] = ep_doPCA('asis', SPmethod, [], 'SVD', 'COV', NUM_FAC, saccTrialData(chans,:)', 'N');            end            if strcmp(icaFlag,'needToSave')                save([fileDir filesep 'ICAresults'],'FactorResults');                icaFlag='saved';            end        end        if isempty(FactorResults)            msg=['Error computing blink factor.'];            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return        end        winv=diag(FactorResults.varSD)*FactorResults.FacPat;        activations=FactorResults.FacScr';                if any(strcmp(templateSource,{'fileTemplate','bothTemplate'}))            corrs = corrcoef([SPmanualTemplate(chans) winv]);            SPmanFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);            if isempty(SPmanFacs)                msg=['No manual SP facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];            else                msg=['The highest manual SP fac correlation (of ' num2str(length(SPmanFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];            end            disp(msg);            outputLog{end+1}=msg;        else            SPmanFacs=[];        end                SPautoTemplate=(SPautoTemplateL+SPautoTemplateR)/2;        if any(strcmp(templateSource,{'autoTemplate','bothTemplate'}))            corrs = corrcoef([SPautoTemplate(chans)' winv]);            SPautoFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);            if isempty(SPautoFacs)                msg=['No auto SP facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];            else                msg=['The highest auto SP fac correlation (of ' num2str(length(SPautoFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];            end            disp(msg);            outputLog{end+1}=msg;        else            SPautoFacs=[];        end                SPfacs=unique([SPmanFacs,SPautoFacs]);                if ~isempty(SPfacs)	%if there are saccade factors, subtract them out            winvFull = zeros(numChans,size(winv,2));            for iChan = 1:length(chans)                winvFull(chans(iChan),:)=winv(iChan,:);            end                        tempVar = zeros(size(activations,1),1);            tempVar(SPfacs) = 1;            subtractedSPs = (winvFull * diag(tempVar) * (activations-repmat(median(activations(:,goodPoints)')',1,size(activations,2))));            contData=contData-subtractedSPs;        else            subtractedSPs=zeros(size(contData));        end        sacPotEOG=squeeze(mean(subtractedSPs,1));        if ~isempty(refFlag)            chans(end+1)=refFlag;        end        trialData=reshape(contData,numChans,[],numTrials);        sacPotEOG=reshape(sacPotEOG,1,[],numTrials);    end    if ~scanFlag        theStr='corrected';        theStr2='correction';    else        theStr='detected';        theStr2='detection';    end        if (strcmp(SPmethod,'vector') && ~isempty(pointList2)) || (~strcmp(SPmethod,'vector') && ~isempty(SPfacs))                if strcmp(SPmethod,'vector')            if count == 1                msg=['One saccadic spike potential ' theStr '.'];            else                msg=[num2str(count) ' saccadic spike potentials ' theStr '.'];            end        else            msg=['ICA approach does not readily allow for estimating number of saccadic spike potentials ' theStr '.'];        end                disp(msg);        outputLog{end+1}=msg;                if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})            figure(butterflyFig{iChunk});            theTitle='subtracted saccadic spike potentials';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,subtractedSPs,chans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        theTitle='with saccadic spike potentials subtracted';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,contData,chans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title('with saccade potentials subtracted','Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end    else        msg=['Nothing matches saccadic spike potential template so no ' theStr2 ' performed.'];        disp(msg);        outputLog{end+1}=msg;                if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})            figure(butterflyFig{iChunk});            if numSubs > 1                theTitle='subtracted saccadic spike potentials';            else                theTitle='no saccadic spike potentials to subtract that were detected';            end            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,zeros(size(contData)),chans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title('no saccadic spike potentials to subtract that were detected','Interpreter','none');                        if numSubs > 1                theTitle='with saccadic spike potentials subtracted';            else                theTitle='no saccadic spike potentials subtracted';            end            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,contData,chans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title('no saccadic spike potentials subtracted','Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end    end        drawnow        goodPoints=[1:size(contData,2)];        %rereference the data.    if ~isempty(refChan)        for iTrial = 1:numTrials            epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            if ~isempty(epoch)                referenceData=mean(trialdata(refChan,epoch),1);                for iChan=1:length(EEGchans)                    theChan=EEGchans(iChan);                    trialdata(theChan,epoch)=trialdata(theChan,epoch)-referenceData;                end            end        end    elseif strcmp(SPmethod,'vector')        msg=['Current reference scheme unknown so not possible to rereference back to it at the completion of this step.  Data are now Cz-referenced.'];        disp(msg);        outputLog{end+1}=msg;        dataChunk.reference.current=czChan;        dataChunk.reference.type='REG';    end        dataChunk.analysis.saccadeTrial(theSubject,:)=saccadeTrialNum{iChunk};	dataChunk.analysis.saccadeOnset(theSubject,:)=saccadeOnsetNum{iChunk};    dataChunk.data(:,:,:,theSubject)=trialdata;        SacPotChan=find(strcmp('SacPot',dataChunk.chanNames));    if isempty(SacPotChan)        EPadd.chanNames{1}='SacPot';        EPadd.chanTypes{1}='REG';        EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));        EPadd.data(:,:,:,theSubject)=sacPotEOG;        if isfield(dataChunk,'interpChans')            interpChans=dataChunk.interpChans;            dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            dataChunk.interpChans=interpChans;        else            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');        end    else        dataChunk.data(saccChan,:,:,theSubject)=sacPotEOG;    end        if isempty(dataChunk)        disp('Warning: No file saved due to program error.');    else        if exist('EPchunk','var') && ~isempty(EPchunk)            if exist('EPchunkSP','var') && ~isempty(EPchunkSP)                EPchunkSP{iChunk}=dataChunk;            else                EPchunk{iChunk}=dataChunk;            end        else            ep_tictoc('ioStart');            eval (['save ''' outFile '-' num2str(iChunk) '.mat'' dataChunk']);            ep_tictoc('ioFinish');        end    end    if standAlone        try            MATLABver=ver('MATLAB');            [a b]=strtok(MATLABver.Version,'.');            b=b(2:end);            if ~isprop(butterflyFig,'Number')                eval (['print -f' num2str(butterflyFig{iChunk}) ' -djpeg ''' inFile '-' num2str(iChunk) 'EOG.jpg''']);            else                eval (['print -f' num2str(butterflyFig{iChunk}.Number) ' -djpeg ''' inFile '-' num2str(iChunk) 'EOG.jpg''']);            end        catch            disp('Couldn''t save a copy of the artifact correction figure.  Perhaps your version of Matlab is not current.');        end    end    subtractedSacPotTopo=subtractedSacPotTopo+mean(subtractedSPs(EEGchans,:),2,'omitnan');endfor iChunk = startChunk:endChunk    totsaccadeTrialNum=[totsaccadeTrialNum saccadeTrialNum{iChunk}];endif any(strcmp(templateSource, {'fileTemplate','bothTemplate'}))    templates.sacPot.manual=SPmanualTemplate;else    templates.sacPot.manual=[];endif any(strcmp(templateSource, {'autoTemplate','bothTemplate','eyeTracker'}))    templates.sacPot.autoL(chans,1)=SPautoTemplateL(chans);    templates.sacPot.autoR(chans,1)=SPautoTemplateR(chans);else    templates.sacPot.autoL=[];    templates.sacPot.autoR=[];endtemplates.sacPot.sacPotTopo=subtractedSacPotTopo;