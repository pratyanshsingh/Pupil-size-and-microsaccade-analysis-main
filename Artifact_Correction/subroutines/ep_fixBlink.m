function [totblinkTrialNum, blinkPoints, templates, outputLog, graphCounter, icaFlag] = ep_fixBlink(inFile, outFile, startChunk, endChunk, badDataCriteria, badChans, eog, blinkSource, sacSource, blinkFile, saccadeFile, baseline, refChan, butterflyFig, graphCounter, numGraphs, theSubject, blinkRotation, icaFlag, scanFlag, eogMethod)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [totblinkTrialNum, blinkPoints, templates, outputLog, graphCounter, icaFlag] = ep_fixBlink(inFile, outFile, startChunk, endChunk, badDataCriteria, badChans, eog, blinkSource, sacSource, blinkFile, saccadeFile, baseline, refChan, butterflyFig, graphCounter, numGraphs, theSubject, blinkRotation, icaFlag, scanFlag, eogMethod)%%	Removes blink artifacts using ICA.  Reads in file chunks generated by chunkInputFile function.  Function runs through all the files given and outputs them as fixed chunks.  chunks will still need to be rejoined.%%Inputs%	inFile:     filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	outFile:    filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	startChunk: starting chunk (usually 1)%   endChunk:   ending chunk%   badDataCriteria:  Criteria for detecting bad data.%       .window:    moving average window for smoothing%       .minmax:    difference from minimum to maximum for bad channel%       .trialminmax:  difference from minimum to maximum for bad trial%       .badnum:    percent of bad channels exceeded to declare bad trial, rounding down%       .hminmax:   difference from minimum to maximum for bad horizontal EOG%       .neighbors: number of electrodes considered to be neighbors%       .badchan:   maximum microvolt difference allowed from best matching neighbor%       .maxneighbor:   maximum microvolt difference allowed from best matching neighbor%       .blink:     threshold correlation with blink template, 0 to 1%       .saccade:     threshold correlation with saccade template, 0 to 1%       .saccademin:  µv Saccade Fac is the minimum HEOG voltage difference required to constitute a possible saccade.%       .detrend:   1 to detrend%       .badtrials: percentage of good trials chan is bad to declare a channel globally bad%       .replace:   1 to interpolate bad channels from neighbors.%       .noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad)%       .movefacs  : number of factors to retain during movement correction.%       .channelMode: 'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing.%       .trialMode: 'fix' to fix bad trial data and 'none' to do nothing.%       .saturation: followed by range of acceptable data values.  Time points with a channel outside this range will be excluded.%   badChans:   list of bad channels to exclude from blink detection process.%   eog:        EOG channels.%   blinkSource:   source of blink template (fileTemplate: load 'blinks' file.  autoTemplate: automatically generate blink template.%                  bothTemplate: use both file and automatic template at the same time).%   sacSource     :   source of saccade template (fileTemplate: load 'blinks' file.  autoTemplate and bothTemplate options not available).%   blinkFile:  file with blink template.  Assumed to be in the same directory as the data file.%   saccadeFile: file with saccade template.  Assumed to be in the same directory as the data file.%   baseline:   array of sample numbers to permanently baseline correct the trials with.  [] means don't correct.%   refChan:    Array of current reference channels.%   butterflyFig:  the handle for the output figure.  Otherwise, will open a new figure.%   graphCounter: the current subplot for the summary figure.%   numGraphs: the total number of subgraphs in the summary figure.%   theSubject: which subject of the file is being processed.%   blinkRotation: the rotation for the blink correction procedure..%   icaFlag   : flag for single-step ICA procedure.  'none': not in use.  'needToSave': need to run ICA and then save temp file.  'saved': temp file already saved so read it in.%   scanFlag  : flag for precorrection scan to identify blink points.%   eogMethod : Type of correction procedure.  'EMCP' means EMCP.%%   The input chunks are EP format data files.%%Outputs%	totblinkTrialNum: Total list of blink trials.%   blinkPoints: Array of points that fall within blink periods, numbering end-to-end for single-trial data. (cell array of number of chunks)%   templates: the templates used for the correction, both file and auto if both used.%       .blinks%           .manual: manual template from file (number of EEG channels,1)%           .auto: auto template (number of EEG channels,1)%   outputLog: output messages from blink fixing process%   icaFlag   : flag for single-step ICA procedure.  'none': not in use.  'needToSave': need to run ICA and then save temp file.  'saved': temp file already saved so read it in.%%	Saves files with blinks removed, replacing the original chunked files.%   If baseline option is used (provides better results, particularly when%   there are large DC swings in the recordings), then the output will be%   baselined.%% History:%% by Joseph Dien (10/00)% jdien07@mac.com%% modified 6/22/01 JD% added bad channel and threshold parameters.  Also changed chunkNum to startChunk and endChunk.%% modified 5/27/02 JD% added baseline correct feature.  Fix to bad chans so they are zeroed even if no blink factors.%% bugfix 10/11/02 JD% added fix to baseline feature for when a blink occurs during the baseline% period.  Output files will now be baselined.  Also, added check for chans% with zero variability.%% modified 10/20/02 JD% since ICA removal sometimes degrades trials without blinks, will now% remove blink components only for trials where the largest feature has the% topography of a blink (correlates .9 with raw EEG).%% modified 12/06/02 JD% Can automatically generate individualized blink template.  Maxed out VEOG time% points dropped from correction and baseline process and left intact (to trigger% eyeblink rejection in averaging program) since they can't be corrected% properly.  Added output log.%% modified 02/04/03  JD% Can now specify blink template file name.  Saves topoplots of blink facs.%  Added bothTemplate option.%% bugfix 4/1/04 JD% Allow for spaces in file names.%% bugfix 11/15/05 JD% Fixed bug that crashed program when a customized blink template was% specified.%% bugfix 7/24/06 JD% Contents of blink template no longer prints out on screen.  Added some error checking.%% modified 3/22/07 JD% Finished autotemplate feature.  Also now takes into account possibility% of blink recoveries (with an inverse topography).  Also now handles% different montages through EEG_hardware function.%% modified 2/17/08 JD% Checks to see if binary version of runica is installed and uses it if available.%% modified 11/17/08 JD% Eliminated topoplot of blink factors. Made baseline specification more flexible.%% modified 12/13/08 JD% Increased scaling for blink plots to make them more visible.%% modified 2/11/09 JD% Dropped trialsize input field.  No longer zeroes bad channels.  Replaced% threshold field with full badDataCriteria field.%% modified 3/14/09 JD% Changed to use EP format data to provide more flexibility with I/O functions.%% modified 3/17/09 JD% Only subtracted blink activity (that met variance reduced criterion) is shown for blink data figure.%% bugfix 4/16/09 JD% Fixed crash when overall blink direction equaled exactly zero.%% bugfix &  modified 7/14/09 JD% Fixed bothTemplate option, which was functioning the same as autoTemplate, ignoring the file template.% Changed output from list of blink facs to list of blink trials.  No longer zeroes out bad channels.% Includes list of blink trials in the data chunk.  Output figure can now be passed from function call.% blink file assumed to be in the directory of the data file.  Uses updated blink template format.%% modified 8/28/09 JD% Modified to use new option for binary runICA to control the output file names so that they can be cleaned up% and so that unpredictable crash from bug causing strange file names can be circumvented.%% modified 9/4/09 JD% Added refChan input to deal with mean mastoid data where the presence of the two reference channels (correlated -1)% was causing ICA problems.%% bugfix 10/17/09 JD% Crash when only one VEOG channel.%% modified 10/28/09 JD% Added option to disable preprocessing figure for low memory situations.%% bugfix 11/20/09 JD% Replaced "union" commands with "unique" commands because certain situations caused the "union" command to crash in% Matlab 2007.%% bugfix 12/3/09 JD% Additional check for ICA failure (denoted by imaginary numbers for weights).%% modified 2/11/10 JD% Will now work with subject average files with multiple subjects.% BlinkTrial no longer initialized to zero.%% modified & bugfix 5/15/10 JD% Made more memory efficient by reducing resolution of the blink plots to no more than 10000 points regardless of size of data.% Fixed when data is mean mastoid, not setting second reference channel to be inverse of the first reference channel.% Fixed crashes when explicit reference channel is present.%% modified 10/13/10 JD% For continuous files, data now divided into one second epochs and can be artifact rejected in an epochwise fashion% in same fashion as segmented data.%% modified 10/17/10 JD% Added support for HEOG saccade correction.%% bugfix 11/3/10 JD% Now handles mismatch where file template or data has implicit reference and the other one has explicit reference.%% bugfix 12/8/10 JD% No longer aborts blink correction when number of electrode coordinates in blink file and in data match (including implicits).%% modified 1/20/11 JD% Added support for manually specifying EOG channels in the preferences.  Missing EOG channel marked as a -1.%% bugfix 2/3/11 JD% Fixed crash when autoTemplate or bothTemplate selected.%% modified 1/25/12 JD% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.% Stop dropping reference channels from templates (assume ref chans same for both data and template).%% modified 9/22/13 JD% Restricted blink correction to EEG channels.%% bugfix 11/18/13 JD% Fixed crash when there is more than one bad channel.%% modified 12/24/13 JD% Adds blink artifact channel and event marking peak latency of the blink in each epoch.% Checks for semi-singular data matrix and drops dimensions as needed to improve quality of solution.%% bufix 3/11/14 JD% Handles decimal sampling rates gracefully.%% modified 3/18/14 JD% Changed uses of "temp" as a variable name to "tempVar" due to other Matlab programmers often using it as a function% name, resulting in collisions.%% modified 6/2/14 JD% Rereference an epoch after performing blink correction.%% bufix 6/6/14 JD% Fixed blink correction can issue false error that template has wrong number of electrodes.% Fixed crash when correcting blink in continuous file.% Always add blink channel to avoid inter-chunk incompatibility.%% bufix 6/12/14 JD% Fixed blank keys field of events being produced without .key (e.g., .keys.keyCod instead of .keys.key.keyCode)%% modified 7/16/14 JD% Simplified keys code field structure.%% bugfix 8/14/15 JD% Fixed unable to save artifact correction summary figure starting with% Matlab 2014b in stand-alone mode.%% modified 2/16/16 JD% Disabled check to see if subtracting blink factors increased overall variance since semi-singularity correction seems to be controlling the noise problem.% Fixing keeping data points straight when there are saturated data points.% No longer baseline correcting each one-second epoch in continuous data when baseline parameter is specified.  Instead just baseline correcting start of the continuous data.% Improved event marking of blink peaks.% Blink artifact channel now difference between upper and lower EOG channels.%% bugfix 3/8/16 JD% Fix to semi-singularity check, which was dropping too many channels.%% bugfix 4/21/16 JD% Fixed crash when correcting single-trial data.% Fixed crash when no blinks were detected.%% bugfix 5/5/16 JD% Really disabled check to see if subtracting blink factors increased overall variance (oops).%% bugfix 9/4/16 JD% Fixed blink detection algorithm was adding lower VEOG channels rather than subtracting them (making it a little less sensitive than it should have been).%% modified 10/2/16 JD% Added blink_start and blink_end events.% Added blinkPoints and templates output.% Changed runica call so that always initialized with same seed so that ICA results are fully replicable.% Added support for boundary events.% NaN out eye-tracker data during blinks.%% modified 1/3/17 JD% Added eyeTracker option to blink and saccade correction routines.%% modified 2/1/17 JD% Eliminated semi-singularity check.%% modified 2/5/17 JD% Added Subtracted topography to template jpeg output.%% bugfix and modified 4/5/17 JD% Fixed blink detection algorithm was not computing blink direction correctly, making it less sensitive.% Made autotemplate algorithm more robust to vertical saccades, at the cost of needing actual blinks, not just blink recovery artifact, to be present in the data.%% modified 4/24/17 JD% Excludes time points beyond a certain range from global bad channel detection, blink, and saccade routines.% Improved blink autotemplate routine by adding additional criteria for blink candidates including slope and symmetry of UVEOG channels.  Also mean correction of channels.%% bugfix 8/8/17 JD% Fixed crash that could occur when there are bad time points that exceed the saturation threshold and the dataset is segmented.%% bugfix 10/1/17 JD% Median corrects data prior to saturation check to ensure channels with merely high offsets are not treated as bad data.% Fixed autotemplate option missing blinks when sampling rate not 250Hz.  Also loosened blink criteria to handle slow blinks.%% bugfix 10/5/17 JD% Fixed crashes due to Matlab changing their graphics objects AGAIN in 2017b.%% bugfix 11/2/17 JD% Eliminated x tick labels to address problem with subplots in summary% artifact figure getting squeezed by formatting problem on PCs.% Adding rank check prior to ICA.%% bugfix 12/1/17 JD% Fixed crash in blink correction when chunking and there are events.%% bugfix 12/8/17 JD% Fixed crash when preprocessing data containing impedance values.% Fixed crash when preprocessing multi-subject average files.% Fixed crash when 1000 is not evenly divisible by the sampling rate.% Fixed crash when there is an event with an empty .value field.%% bugfix 1/13/18 JD% Fixed crash when sample length did not divide evenly into 100.%% bugfix 1/30/18 JD% Fixed crash when there is an event with an empty .value field.%% modified 2/4/18 JD% Made subplot specification for summary figure output more flexible.%% modified 4/8/18 JD% Consolidated summary figure for average files so no longer one per subject.%% bugfix 11/3/18 JD% Fixed crash for multi-subject files.%% bugfix 12/5/18 JD% Fixed crash for single-trial data where a blink occurs at the end of an epoch.% Fixed .sample field for blink_start and blink_end events.%% modified 7/7/19 JD% Accelerates artifact correction by adding option to keep chunks in RAM.% Now excludes global bad channels from summary subplot.%% bugfix 10/29/19 JD% Fixed crash when the events structure is empty.%% bugfix 1/23/20 JD% Fixed crash when 'saccadeET','fixationET' events occur during a blink period.%% modified 2/21/20 JD% Now remaps file template if it is for a different electrode montage.%% modified 4/7/20 JD% Added preferences setting to set rotation type for blink correction and added support for SOBI and extended-Infomax.%% bugfix 4/28/20 JD% Fixed crash when data contained bad time points and using auto option for blinks.%% bugfix 5/19/20 JD% Modified to accommodate pre-existing NaN values.%% modified 6/11/20 JD% Added eye artifact control to specify EMCP, MAAC, or single-step ICA options.%% bugfix & modified 9/24/20 JD% Fixed blink_start, blink, and blink_end events having the wrong samples recorded.  Also blinkPoints having the wrong samples output.% No longer changes voltages outside of saturation range into NaN.% Made fixes to event markings of blinks and threshold to 300 from 100.% Changed minimum separation of blink peaks to 100 ms from 300 ms to handle double blinks better.% Changed blinkEOG from mean to median to be more robust to the effect of the blink deflection.% For segmented data, also median correcting the epoch as otherwise blinks happening in the baseline muck up the start/end thresholds.% Also filtering and detrending segmented data to make blink event marking more robust against noise and drifts and vertical CRD offsets.% Added minimum blink width parameter to make the blink start and end estimates more robust.% Added scanFlag.% Correlations for manual blink templates now exclude HEOG channels just like for auto blink templates.% Added EMCP option.% Improved blink correction performance when an EOG channel was bad and had to be temporarily interpolated.%% bugfix 11/4/20 JD% Fixed crash when multiple boundary events are present in continuous data.%% bugfix 6/13/21 JD% Fixed crash when boundary point is beyond last good point.%% bugfix 8/5/22 JD% Fixed crash when sampling rate higher than 1000.%% bugfix 12/3/23 JD% Fixed detection of blinks via manual templates made less effective by bad channels and reference channels that were not the final channel.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2025  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPchunk EPchunkSP EPtictocif ~isempty(butterflyFig)    if strcmp(eogMethod,'EMCP')        graphCounter=graphCounter+4;    else        graphCounter=graphCounter+2;    endendmsg='Starting eyeblinks routine.';disp(msg);outputLog{1}=msg;blinkPoints=cell(endChunk-startChunk+1,1);totblinkTrialNum=[];badChans=badChans(:); %make sure it's a column vectortemplates=[];icaFlag='';if ~exist('butterflyFig','var')    butterflyFig=figure('Name','Artifact Correction','NumberTitle','off');    colormap jet;    standAlone=1;else    standAlone=0;endtheEOG(1) = eog.LUVEOG;theEOG(2) = eog.RUVEOG;theEOG(3) = eog.LLVEOG;theEOG(4) = eog.RLVEOG;theEOG(5) = eog.LHEOG;theEOG(6) = eog.RHEOG;blinkThreshold=300; %minimum microvolts to count as a blinkblinkwindowMS=100; %minimum separation for blinks in ms.slopeLengthMS=100; %for auto template, number of ms to look for slope on either side of putative blink peak.slopeThresh=2; %criterion for sufficient slope for putative blinkblinkSymm=100; %upper VEOG of blinks need to be within this range of each other to be included in automatic blink templates.blinkLengthMinMS=20; %minimum width of blink event when computing start and end of blink.filterWidthMS=20; %width of the smoothing filter window in MS.blinkEdgeThreshold=blinkThreshold/4;% noisier=0;VEOG=[];goodVEOG=[];for iChan=1:4    if isempty(intersect(theEOG(iChan),badChans)) && (theEOG(iChan) ~= -1)        VEOG=[VEOG theEOG(iChan)];        goodVEOG(end+1)=iChan;    endendHEOG=[];for i=5:6    if isempty(intersect(theEOG(i),badChans)) && (theEOG(i) ~= -1)        HEOG=[HEOG theEOG(i)];    endend[fileDir, name, ext] = fileparts(inFile);blinkManualTemplateAC=[];blinkAutoTemplate=[];if any(strcmp(blinkSource, {'fileTemplate','bothTemplate'}))    ep_tictoc('ioStart');    eval(['load ''' blinkFile '''']);    ep_tictoc('ioFinish');        if ~exist('EPblink','var')        msg{1}='Not a blink template.';        [msg]=ep_errorMsg(msg);        return    end        if exist('EPchunk','var') && ~isempty(EPchunk)        if exist('EPchunkSP','var') && ~isempty(EPchunkSP) && isstruct(EPchunkSP{1})            dataChunk=EPchunkSP{1};        else            dataChunk=EPchunk{1};        end    else        ep_tictoc('ioStart');        eval(['load ''' deblank(inFile) '-' num2str(1) '.mat''']);        ep_tictoc('ioFinish');    end        EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    EEGblinkChans=find(ismember({EPblink.eloc.type},{'EEG','REF'}));        blinkManualTemplateAC=EPblink.template;    if size(blinkManualTemplateAC,1) > 1        blinkManualTemplateAC = blinkManualTemplateAC'; %for some reason I had decided to have the templates be row vectors.    end    if size(blinkManualTemplateAC,1) > 1        msg='Something is wrong with the blink template.  It has the wrong dimensions.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end    %if the template is different from the dataset, remap the template    if (length(EPblink.eloc) ~= length(EEGchans)) || any([EPblink.eloc.theta]-[dataChunk.eloc.theta]) || any([EPblink.eloc.radius]-[dataChunk.eloc.radius])        newData=ep_interpChans(blinkManualTemplateAC', EPblink.eloc(EEGblinkChans), dataChunk.eloc(EEGchans));        ep_tictoc;if EPtictoc.stop;return;end        if isempty(newData)            return        else            blinkManualTemplateAC=newData;        end        blinkManualTemplateAC=blinkManualTemplateAC';    endendsigns = [ 1 1 -1 -1;1 1 -1 -1; -1 -1 1 1; -1 -1 1 1];signs=signs(goodVEOG,:);signs=signs(:,goodVEOG);blinksign = [1 1 -1 -1]';blinksign=blinksign(goodVEOG,1);if strcmp(eogMethod,'EMCP')    msg='Templates are not used for EMCP so they will be used solely for diagnostic purposes.';    outputLog{end+1}=msg;    disp(' ');    disp(msg);else    if ~any(strcmp(blinkSource, {'autoTemplate','bothTemplate','fileTemplate','eyeTracker'}))        msg='Template variable must be set to fileTemplate, autoTemplate, bothTemplate, or eyeTracker.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    endendbadChans = badChans(find(badChans));	%drop out bad channels set as being zeroif length(refChan) == 2    badChans = unique([badChans;refChan(2)]);     %temporarily take second reference site out of ICAendwarning off GLREN:doubleBufferSlow; %Turn off warning message about doublebuffer not available.priorPoints=0;for iChunk = startChunk:endChunk    if endChunk > startChunk        msg=[deblank(inFile) '-' num2str(iChunk)];        disp(msg);        outputLog{end+1}=msg;    end        if exist('EPchunk','var') && ~isempty(EPchunk)        if exist('EPchunkSP','var') && ~isempty(EPchunkSP) && isstruct(EPchunkSP{iChunk})            dataChunk=EPchunkSP{iChunk};        else            dataChunk=EPchunk{iChunk};        end    else        ep_tictoc('ioStart');        eval(['load ''' deblank(inFile) '-' num2str(iChunk) '.mat''']);        ep_tictoc('ioFinish');    end        if strcmp(dataChunk.dataType,'continuous')        theSegment = 'one second epoch';    else        theSegment = 'trial';    end        numChans=length(dataChunk.chanNames);    numSubs=length(dataChunk.subNames);    numPoints=length(dataChunk.timeNames);    numCells=length(dataChunk.cellNames);    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    if length(dataChunk.facNames) > 1        msg='This function is not intended for application to factor data.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end        if iChunk ==startChunk        subtractedBlinksTopo=zeros(length(EEGchans),1);    end        ETchans=find(ismember(dataChunk.chanTypes,{'PPL';'XEY';'YEY'}));        trialData=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);        if strcmp(dataChunk.dataType,'continuous')        displayPeriod=size(dataChunk.data,2);    %Number of timepoints to graph in display.    else        displayPeriod=size(dataChunk.data,2)*size(dataChunk.data,3);    end    decimateSamples=ceil(max(1,displayPeriod/10000));    totalDisplayPeriod=displayPeriod*size(dataChunk.data,4);        if displayPeriod == 1        msg='There is only one time point and so the data cannot be blink/saccade corrected.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end        if strcmp(dataChunk.dataType,'continuous')        numTrials=floor(size(trialData,2)/ceil(dataChunk.Fs)); %excess time points are tacked onto final epoch        trialSize = min(ceil(dataChunk.Fs),size(trialData,2)); %one second epochs    else        trialSize = length(dataChunk.timeNames);        numTrials = length(dataChunk.cellNames);    end        if (length(refChan) == 1) && std(trialData(refChan(1),:)','omitnan') == 0        badChans = unique([badChans; refChan(1)]);     %temporarily take first reference site out of ICA    end        chans = setdiff(EEGchans,badChans);    EEGchansNoHEOG=find(~ismember(chans,[eog.LHEOG eog.RHEOG]));    goodPoints = find(any(~isnan(trialData(chans,:))));    %     goodPoints = find((max(trialData(chans,:)-repmat(median(trialData(chans,:)','omitnan')',1,size(trialData(chans,:),2))) < badDataCriteria.saturation(2)) & (min(trialData(chans,:)-repmat(median(trialData(chans,:)','omitnan')',1,size(trialData(chans,:),2))) > badDataCriteria.saturation(1)));    slopeLength=round(slopeLengthMS/(1000/dataChunk.Fs));        if ~isempty(baseline)			%subtract out baselines before performing ICA        if strcmp(dataChunk.dataType,'continuous')            baseMeans = mean(trialData(EEGchans,baseline),2);            trialData(EEGchans,:)=trialData(EEGchans,:)-diag(baseMeans)*ones(length(EEGchans),size(trialData,2));        else            for iTrial = 1:numTrials                epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));                base=(iTrial-1)*trialSize+baseline;                goodBase=goodPoints(find(ismember(base,goodPoints)));                if ~isempty(epoch) && ~isempty(goodBase)                    baseMeans = mean(trialData(EEGchans,goodBase),2);                    trialData(EEGchans,epoch)=trialData(EEGchans,epoch)-diag(baseMeans)*ones(length(EEGchans),length(epoch));                end            end        end    end        if standAlone && ~isempty(butterflyFig) && ishandle(butterflyFig(theSubject,iChunk))        if ~isempty(butterflyFig)            figure(butterflyFig(theSubject,iChunk));            [pathstr, fileName, ext]=fileparts(inFile);            subplot(3,1,1), plot([1:decimateSamples:displayPeriod],trialData([badChans; chans],1:decimateSamples:displayPeriod));            axis([1 displayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title([deblank(fileName) '-' num2str(iChunk)],'Interpreter','none');        end                if ~isempty(baseline)			%subtract out baselines before performing ICA            if ~isempty(butterflyFig)                subplot(3,1,2), plot([1:decimateSamples:displayPeriod],trialData([badChans; chans],1:decimateSamples:displayPeriod));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                title('with baselines subtracted','Interpreter','none');            end        else            if ~isempty(butterflyFig)                subplot(3,1,3), plot([1:decimateSamples:displayPeriod],trialData([badChans; chans],1:decimateSamples:displayPeriod));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                title('no baseline subtraction specified','Interpreter','none');            end        end    end        if strcmp(eogMethod,'EMCP')        blinkData=squeeze(dataChunk.data(:,:,:,theSubject));        VEOGdata=mean(blinkData(VEOG(blinksign ==1),:,:),1)-mean(blinkData(VEOG(blinksign ==-1),:,:),1); %add VEOG difference wave        HEOGdata=blinkData(eog.LHEOG,:,:)-blinkData(eog.RHEOG,:,:); %add HEOG difference wave        [fzChan, theOrder] = ep_findChan(dataChunk.eloc, dataChunk.implicit, dataChunk.chanNames, dataChunk.ced, badChans, 'Fz', dataChunk.montage);        blinkData=blinkData(chans,:,:);        numGoodChans=length(chans);        blinkData(end+1,:,:)=VEOGdata;        blinkData(end+1,:,:)=HEOGdata;                parameters.verbose=1;                                   %0=no output to screen (for background jobs), 1=print progress to screen        parameters.beckman=0;                                   %0=not from Neuroscan lab, 1=from Neuroscan lab        parameters.digitizingRate=1000/dataChunk.Fs;            %Digitizing period (ms)        parameters.VEOG_CHANNEL=size(blinkData,1)-1;            %position of VEOG in rawData */        parameters.HEOG_CHANNEL=size(blinkData,1);              %position of HEOG in rawData */        parameters.FZ_CHANNEL=fzChan;                           %position of Fz channel in rawData.        parameters.eegChannels=length(chans)+2;                 %Number of EEG channels plus VEOG and HEOG.        parameters.criteria=badDataCriteria.saturation(2);      %Microvolt number that is deemed out-of-range.        cellList=unique(dataChunk.cellNames);        binData=zeros(length(dataChunk.cellNames),1);        for iCell=1:length(dataChunk.cellNames)            binData(iCell)=find(strcmp(dataChunk.cellNames{iCell},cellList));        end                [subBlinksGC, subSaccsGC, ~, ~, corRawData, msg, blink, saccade] = EMCP(permute(blinkData,[3,2,1]), binData, parameters, []);        outputLog(end+1:end+length(msg))=msg;                subBlinksGC=permute(subBlinksGC,[3 2 1]);        subBlinksGC=subBlinksGC(1:numGoodChans,:,:);        subtractedBlinks=zeros(numChans,numPoints,numCells);        subtractedBlinks(chans,:,:)=subBlinksGC;                subSaccsGC=permute(subSaccsGC,[3 2 1]);        subSaccsGC=subSaccsGC(1:numGoodChans,:,:);        subtractedSaccades=zeros(numChans,numPoints,numCells);        subtractedSaccades(chans,:,:)=subSaccsGC;                corRawData=permute(corRawData,[3 2 1]);        corRawData=corRawData(1:numGoodChans,:,:);                winv=mean(reshape(subtractedBlinks(chans,:,:),length(chans),[]),2); %mean scalp topography of the EMCP estimated blinks.        saccHwinv=saccade.heogFactor(1:numGoodChans); %mean scalp topography of the EMCP estimated horizontal CRD.        saccVwinv=saccade.veogFactor(1:numGoodChans); %mean scalp topography of the EMCP estimated vertical CRD.                hSaccEEG=subtractedSaccades(HEOG(1),:,:)-subtractedSaccades(HEOG(2),:,:);        vSaccEEG=mean(subtractedSaccades(VEOG(blinksign == -1),:,:),1)-mean(subtractedSaccades(VEOG(blinksign == 1),:,:),1);                blinkfacs=1;                if ~any(strcmp(sacSource, 'none'))                        %saccade template            [fileDir, name, ext] = fileparts(inFile);            ep_tictoc('ioStart');            eval(['load ''' saccadeFile '''']);            ep_tictoc('ioFinish');                        if ~exist('EPsaccade','var')                msg='Not a saccade template.';                [msg]=ep_errorMsg({msg});                return            end                        if ~exist('EPsaccade','var')                msg='No saccade template so not computing correlation with EMCP.';                outputLog{end+1}=msg;                disp(' ');                disp('**************************************************************');                disp(msg);                disp('**************************************************************');                disp(' ');                saccadeFileCorrect=0;            else                saccadeFileCorrect=1;                if (~isfield(EPsaccade,'vSaccade')) || ~any(EPsaccade.vSaccade.template)                    msg='No vertical saccade template so not computing correlation with EMCP.';                    outputLog{end+1}=msg;                    disp(' ');                    disp('**************************************************************');                    disp(msg);                    disp('**************************************************************');                    disp(' ');                    vertSaccadeFileCorrect=0;                else                    vertSaccadeFileCorrect=1;                end            end                        EEGsaccChans=find(ismember({EPsaccade.eloc.type},{'EEG','REF'}));            nonHEOGbadChans=setdiff(badChans,[eog.LHEOG eog.RHEOG]); %HEOG bad chans will be interpolated            saccChans = setdiff(EEGsaccChans,nonHEOGbadChans);                        if saccadeFileCorrect                hSaccManualTemplate=EPsaccade.hSaccade.template(:);                if size(hSaccManualTemplate,2) > 1                    msg='Something is wrong with the saccade template.  It has the wrong dimensions.';                    outputLog{end+1}=msg;                    disp(' ');                    disp('**************************************************************');                    disp(msg);                    disp('**************************************************************');                    disp(' ');                    return;                end                %if the template is different from the dataset, remap the template                if (length(EPsaccade.eloc) ~= length(EEGchans)) || any([EPsaccade.eloc.theta]-[dataChunk.eloc.theta]) || any([EPsaccade.eloc.radius]-[dataChunk.eloc.radius])                    newData=ep_interpChans(hSaccManualTemplate(saccChans), EPsaccade.eloc(saccChans), dataChunk.eloc(EEGchans));                    ep_tictoc;if EPtictoc.stop;return;end                    if isempty(newData)                        return                    else                        hSaccManualTemplate=newData;                    end                end                if vertSaccadeFileCorrect                    vSaccManualTemplate=EPsaccade.vSaccade.template(:);                    %if the template is different from the dataset, remap the template                    if (length(EPsaccade.eloc) ~= length(EEGchans)) || any([EPsaccade.eloc.theta]-[dataChunk.eloc.theta]) || any([EPsaccade.eloc.radius]-[dataChunk.eloc.radius])                        newData=ep_interpChans(vSaccManualTemplate(saccChans), EPsaccade.eloc(saccChans), dataChunk.eloc(EEGchans));                        ep_tictoc;if EPtictoc.stop;return;end                        if isempty(newData)                            return                        else                            vSaccManualTemplate=newData;                        end                    end                end            end                        if any(strcmp(sacSource,{'fileTemplate','bothTemplate'}))                corrs = corrcoef([hSaccManualTemplate(chans) saccHwinv]);                hSaccManFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);                if isempty(hSaccManFacs)                    msg=['No manual horizontal saccade facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];                else                    msg=['The highest manual horizontal saccade fac correlation (of ' num2str(length(hSaccManFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];                end                disp(msg);                outputLog{end+1}=msg;            else                hSaccManFacs=[];            end                        if any(strcmp(sacSource,{'fileTemplate','bothTemplate'}))                corrs = corrcoef([vSaccManualTemplate(chans) saccVwinv]);                vSaccManFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);                if isempty(vSaccManFacs)                    msg=['No manual vertical saccade facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];                else                    msg=['The highest manual vertical saccade fac correlation (of ' num2str(length(vSaccManFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];                end                disp(msg);                outputLog{end+1}=msg;            else                vSaccManFacs=[];            end                        if any(strcmp(sacSource,{'autoTemplate','bothTemplate'}))                corrs = corrcoef([hSaccAutoTemplate(chans)' saccHwinv]);                hSaccAutoFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);                if isempty(hSaccAutoFacs)                    msg=['No auto horizontal saccade facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];                else                    msg=['The highest auto horizontal saccade fac correlation (of ' num2str(length(hSaccAutoFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];                end                disp(msg);                outputLog{end+1}=msg;            else                hSaccAutoFacs=[];            end                        if any(strcmp(sacSource,{'autoTemplate','bothTemplate'}))                corrs = corrcoef([vSaccAutoTemplate(chans)' saccVwinv]);                vSaccAutoFacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink, 1);                if isempty(vSaccAutoFacs)                    msg=['No auto vertical saccade facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];                else                    msg=['The highest auto vertical saccade fac correlation (of ' num2str(length(vSaccAutoFacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];                end                disp(msg);                outputLog{end+1}=msg;            else                vSaccAutoFacs=[];            end                    end    else        NUM_FAC=length(chans);        dataRank=rank(trialData(chans,goodPoints));        msg=['The rank of the blink data was: ' num2str(dataRank)];        disp(msg);        outputLog{end+1}=msg;        if dataRank < NUM_FAC            msg=['Dropping ' num2str(NUM_FAC-dataRank) ' dimensions due to singular data matrix (bridged channels can cause this, or simply very similar channels).'];            disp(msg);            outputLog{end+1}=msg;            NUM_FAC = dataRank;        end                blinkTrialData=nan(size(trialData));        blinkTrialData(chans,goodPoints)=trialData(chans,goodPoints);                if strcmp(icaFlag,'saved')            load([fileDir filesep 'ICAresults']);        else            switch blinkRotation                case {'Infomax','Extended-Infomax'}                    rotOpt=1;                    rng(0,'twister'); %sets random number generator to standardized start to ensure replicability of Infomax results.                    [FactorResults] = ep_doPCA('asis', blinkRotation, rotOpt, 'SVD', 'COV', NUM_FAC, blinkTrialData(chans,:)', 'N');                case 'SOBI'                    rotOpt=floor(400/(1000/dataChunk.Fs));                    %for SOBI, the data needs to be organized into a 3D matrix with trials so that the time lags don't get extended past epoch limits.  Even for continuous, will do as one second epochs to handle bad points.                    if strcmp(dataChunk.dataType,'continuous')                        blinkTrialData=reshape(blinkTrialData(:,1:size(blinkTrialData,2)-rem(size(blinkTrialData,2),dataChunk.Fs)),numChans,dataChunk.Fs,[]); %for bad timepoint exclusion to work, need to split up continuous recording into one second epochs                        for iEvent=1:length(dataChunk.events{1})                            if strcmp('boundary',dataChunk.events{1}(iEvent).type)                                blinkTrialData(:,:,floor((dataChunk.events{1}(iEvent).sample-1)/dataChunk.Fs)+1)=NaN; %if a boundary event lands in the middle of an epoch, exclude the entire epoch                            end                        end                    else                        numPoints=length(dataChunk.timeNames);                        numSubs=length(dataChunk.subNames);                        numCells=length(dataChunk.cellNames);                        blinkTrialData=reshape(blinkTrialData,numChans,numPoints,[]);                        for iSub=1:numSubs                            for iCell=1:numCells                                if ~isempty(dataChunk.events(iSub,iCell))                                    if any(strcmp('boundary',{dataChunk.events{iSub,iCell}.type}))                                        blinkTrialData(:,:,((iSub-1)*numSubs*numCells+(iCell-1)*numCells)+1)=NaN; %if a boundary event lands in the middle of an epoch, exclude the entire epoch                                    end                                end                            end                        end                    end                    [FactorResults] = ep_doPCA('asis', blinkRotation, rotOpt, 'SVD', 'COV', NUM_FAC, blinkTrialData(chans,:,:), 'N');                                        %             [H]=sobi(blinkTrialData(chans,:,:),NUM_FAC,rotOpt);                    %             FactorResults.varSD=mean(reshape(blinkTrialData(chans,:,:),length(chans),[])');                    %             FactorResults.FacPat=H;                    %             FactorResults.FacScr=reshape(blinkTrialData(chans,:,:),length(chans),[])'*pinv(H)';                otherwise                    [FactorResults] = ep_doPCA('asis', blinkRotation, [], 'SVD', 'COV', NUM_FAC, blinkTrialData(chans,:)', 'N');            end            if strcmp(icaFlag,'needToSave')                save([fileDir filesep 'ICAresults'],'FactorResults');                icaFlag='saved';            end        end        if isempty(FactorResults)            msg=['Error computing blink factor.'];            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return        end        winv=diag(FactorResults.varSD)*FactorResults.FacPat;        activations=FactorResults.FacScr';    end        %generate automatic blink template    if any(strcmp(blinkSource,{'autoTemplate','bothTemplate','eyeTracker'}))        chanMeans=mean(trialData','omitnan')';        blinkTimes = zeros(numTrials,1);        if strcmp(blinkSource,'eyeTracker') && ~isempty(dataChunk.events{1})            blinkSamps=round([dataChunk.events{1}(find(strcmp('blinkStartET',{dataChunk.events{1}.value}))).sample]);            blinkSamps=blinkSamps-priorPoints;            blinkSamps=blinkSamps((blinkSamps > 0) & (blinkSamps <= size(trialData,2))); %only saccadeET events in the current data chunk.        end                for iTrial = 1:numTrials %check each trial for presence of blink            if strcmp(dataChunk.dataType,'continuous') && (iTrial == numTrials)                epoch=goodPoints(find(goodPoints>((iTrial-1)*trialSize))); %excess time points are tacked onto final epoch            else                epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            end            if ~isempty(epoch)                blinkFlag=0;                blinkSignal = sum(diag(blinksign)*(trialData(VEOG,epoch))-repmat(chanMeans(VEOG),1,length(epoch)))';                [maxamp maxpoint] = max(blinkSignal);                if strcmp(blinkSource,'eyeTracker')                    if any(ismember(blinkSamps,epoch))                        blinkFlag=1;                    end                elseif ((epoch(maxpoint)-slopeLength) > 0) && ((epoch(maxpoint)+slopeLength) <= size(trialData,2))                    badBlink=0;                    if ~isfield(dataChunk,'interpChans') || ~any(ismember(dataChunk.interpChans.chans,VEOG)) %if any VEOG channels were interpolated, it can mess up these blink checks.                        if all(ismember([1 2],goodVEOG)) && (abs((trialData(eog.LUVEOG,epoch(maxpoint))-chanMeans(eog.LUVEOG))-(trialData(eog.RUVEOG,epoch(maxpoint))-chanMeans(eog.RUVEOG))) > blinkSymm)                            badBlink=1; %upper VEOG not symmetrical enough to be counted for autoblink template                        end                        if all(ismember([1 3],goodVEOG)) && (abs((trialData(eog.LUVEOG,epoch(maxpoint))-chanMeans(eog.LUVEOG))-(trialData(eog.LLVEOG,epoch(maxpoint))-chanMeans(eog.LLVEOG))) < blinkThreshold)                            badBlink=1; %difference between upper and lower EOG too small to count as a blink.                        end                        if all(ismember([2 4],goodVEOG)) && (abs((trialData(eog.RUVEOG,epoch(maxpoint))-chanMeans(eog.RUVEOG))-(trialData(eog.RLVEOG,epoch(maxpoint))-chanMeans(eog.RLVEOG))) < blinkThreshold)                            badBlink=1; %difference between upper and lower EOG too small to count as a blink.                        end                    end                    if ~badBlink                        blinkSignal = sum(diag(blinksign)*(trialData(VEOG,epoch(maxpoint)-slopeLength:epoch(maxpoint))-repmat(chanMeans(VEOG),1,slopeLength+1)))';                        b1=[ones(slopeLength+1,1), [1:slopeLength+1]']\blinkSignal;                        blinkSignal = sum(diag(blinksign)*trialData(VEOG,epoch(maxpoint):epoch(maxpoint)+slopeLength)-repmat(chanMeans(VEOG),1,slopeLength+1))';                        b2=[ones(slopeLength+1,1), [1:slopeLength+1]']\blinkSignal;                        if (b1(2) > slopeThresh) && (b2(2) < -slopeThresh)                            %if this really is a peak point and with reasonable slopes                            blinkFlag=1;                        end                    end                end                if blinkFlag                    if sign(maxamp) ~= 0                        blinkTimes(iTrial)=epoch(maxpoint); %timepoint of blink activity                    end                end            end        end                blinkTimes=blinkTimes(find(blinkTimes)); %compact array to eliminate trials with no blinks        if ~isempty(blinkTimes)            if isscalar(blinkTimes)                msg=['1 blink ' theSegment ' used for template generation.'];            else                msg=[num2str(length(blinkTimes)) ' blink ' theSegment 's used for template generation.'];            end            disp(msg);            outputLog{end+1}=msg;            if isscalar(blinkTimes)                autoBlinksGC=trialData(chans,blinkTimes)';            else                autoBlinksGC=mean(trialData(chans,blinkTimes)');            end            autoBlinksGC=autoBlinksGC-chanMeans(chans)';            corrs = corrcoef([autoBlinksGC(EEGchansNoHEOG)' winv(EEGchansNoHEOG,:)]); %not including HEOG since too variable            blinkfacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink);            if isempty(blinkfacs)                msg=['No automatic blink facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];            else                msg=['The highest automatic blink fac correlation (of ' num2str(length(blinkfacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];            end            disp(msg);            outputLog{end+1}=msg;        else            msg='No blinks auto-detected to form the blink template.';            disp(msg);            outputLog{end+1}=msg;            autoBlinksGC=zeros(1,length(chans));            blinkfacs=[];            corrs=[];        end        blinkAutoTemplate{iChunk}(:,1)=autoBlinksGC;    end        if strcmp(blinkSource,'fileTemplate')        corrs = corrcoef([blinkManualTemplateAC(chans(EEGchansNoHEOG))' winv(EEGchansNoHEOG,:)]); %not including HEOG since too variable        blinkfacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink);        if isempty(blinkfacs)            msg=['No manual blink facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];        else            msg=['The highest manual blink fac correlation (of ' num2str(length(blinkfacs)) ') was: ' num2str(max(abs(corrs(2:end,1))))];        end        disp(msg);        outputLog{end+1}=msg;        autoBlinksGC=[];    end        if strcmp(blinkSource,'bothTemplate')        corrs = corrcoef([blinkManualTemplateAC(chans(EEGchansNoHEOG))' winv(EEGchansNoHEOG,:)]); %not including HEOG since too variable        blinkfacs2 = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink);        if isempty(blinkfacs2)            msg=['No manual blink facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];        else            msg=['The highest manual blink fac correlation (of ' num2str(length(blinkfacs2)) ') was: ' num2str(max(abs(corrs(2:end,1))))];        end        disp(msg);        outputLog{end+1}=msg;        blinkfacs = unique([blinkfacs, blinkfacs2]);    end        %eval(['save ' inFile '-blinkFacs.mat corrs autoBlinksGC winv chans EEGchansNoHEOG;']);        blinkTrialNum{iChunk}=dataChunk.analysis.blinkTrial;    blinkEOG=zeros(1,size(trialData,2));    if ~isempty(blinkfacs) || strcmp(eogMethod,'EMCP')	%if there are blink factors, subtract them out                if strcmp(eogMethod,'EMCP')            blinkdata=reshape(subtractedBlinks,numChans,[]);        else            winvFull = zeros(numChans,size(winv,2));            for iChan = 1:length(chans)                winvFull(chans(iChan),:)=winv(iChan,:);            end                        tempVar = zeros(size(activations,1),1);            tempVar(blinkfacs) = 1;            blinkdata = (winvFull * diag(tempVar) * (activations-repmat(median(activations(:,goodPoints)')',1,size(activations,2))));        end                if any(blinksign ==1)            blinkEOG(1,goodPoints) = blinkEOG(1,goodPoints)+mean(blinkdata(VEOG(blinksign ==1),goodPoints),1);        end        if any(blinksign ==-1)            blinkEOG(1,goodPoints) = blinkEOG(1,goodPoints)-mean(blinkdata(VEOG(blinksign ==-1),goodPoints),1);        end        blinkEOG=blinkEOG-median(blinkEOG);                count=0;        blinkWindow=round(blinkwindowMS/(1000/dataChunk.Fs)); %blink peaks within a 100 ms treated as a single blink                dataSize=size(dataChunk.data,2);                boundaryPoints=[];        boundaryPointsGP=[];        for iTrial=1:size(dataChunk.data,3)            if ~isempty(dataChunk.events{iTrial})                boundaryPoints=[boundaryPoints; [dataChunk.events{iTrial}(find(strcmp('boundary',{dataChunk.events{iTrial}.type}))).sample]'+(iTrial-1)*dataSize];            end            if iTrial > 1                boundaryPoints=[boundaryPoints; (iTrial-1)*dataSize+1];            end        end        for iBound=1:length(boundaryPoints)            minPoint=min(find(goodPoints>=boundaryPoints(iBound)));            if ~isempty(minPoint)                boundaryPointsGP(iBound)=minPoint;            end        end                blinkLengthMin=round(blinkLengthMinMS/(1000/dataChunk.Fs));        filterWidth=round(filterWidthMS/(1000/dataChunk.Fs));                numEpochs=numTrials;        if strcmp(dataChunk.dataType,'continuous')            %check to see if procedure made data noisier            for iTrial = 1:numTrials                if iTrial == numTrials                    epochPointsGP=find(goodPoints>((iTrial-1)*trialSize));                else                    epochPointsGP=find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize)));                end                epochPoints=goodPoints(epochPointsGP);                                %                 if sum(var(trialData(chans,epochPoints))) < sum(var(trialData(chans,epochPoints)-blinkdata(chans,epochPointsGP)))                %                     noisier=noisier+1;                %                 end            end                        numEpochs=max(length(boundaryPointsGP),1);        end        %blinkPeaks, blinkStarts, and blinkEnds in goodPoints space, blinkEOG and boundaryPoints are in regular point space        for iEpoch = 1:numEpochs %for continuous data, for each set of points bracketed by boundary events (all the data if no boundary events)            ep_tictoc;if EPtictoc.stop;return;end            if strcmp(dataChunk.dataType,'continuous')                iTrial=1;                if iEpoch==1                    boundStart=1;                else                    boundStart=boundaryPointsGP(iEpoch);                end                if (numEpochs==1) || (iEpoch==length(boundaryPointsGP))                    boundEnd=length(goodPoints);                else                    boundEnd=boundaryPointsGP(iEpoch+1)-1;                end                epochPointsGP=[boundStart:boundEnd];                epochPoints=goodPoints(epochPointsGP);            else                iTrial=iEpoch;                epochPointsGP=find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))); %epoch's points in goodPoints space                epochPoints=goodPoints(epochPointsGP); %epoch's points in full points space with just good points included            end                        %check to see if procedure made data noisier            %                 if sum(var(trialData(chans,epochPoints))) < sum(var(trialData(chans,epochPoints)-blinkdata(chans,epochPoints)))            %                     noisier=noisier+1;            %                 end            if ~isempty(epochPoints)                %blinkPeaks, blinkStarts, and blinkEnds, blinkEOG is in regular point space                trialBlinkEOG=blinkEOG(1,epochPoints);                trialBlinkEOG=detrend(trialBlinkEOG);                trialBlinkEOG=trialBlinkEOG-median(trialBlinkEOG);                blinkPeaks=min(find( trialBlinkEOG >= blinkThreshold)); %find first blink point                if ~isempty(blinkPeaks)                    trialBlinkEOGgrad=gradient(filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(trialBlinkEOG(1),1,filterWidth) trialBlinkEOG repmat(trialBlinkEOG(end),1,filterWidth)]));                    trialBlinkEOGgrad=trialBlinkEOGgrad(filterWidth+1:end-filterWidth); %remove padding that was added to avoid edge artifacts being aggravated by zero-padding during filtering                    blinkStarts=max(find(trialBlinkEOGgrad(1:blinkPeaks-blinkLengthMin)<0));                    %                         blinkStarts=max(find(trialBlinkEOG(1:blinkPeaks(1)) < (blinkEdgeThreshold)));                    if isempty(blinkStarts) || any(ismember(boundaryPoints,[epochPoints(blinkStarts(1))+1:epochPoints(blinkPeaks(1))]))                        blinkStarts=0;                    end                    blinkEnds=min(find(trialBlinkEOGgrad(blinkPeaks+blinkLengthMin:end)>0))+blinkPeaks(1)+blinkLengthMin-1;                    %                         blinkEnds=min(find(trialBlinkEOG(blinkPeaks(1):end) < (blinkEdgeThreshold)))+blinkPeaks(1)-1;                    if isempty(blinkEnds) || any(ismember(boundaryPoints,[epochPoints(blinkPeaks(1))+1:epochPoints(blinkEnds)]))                        blinkEnds=0;                    end                    if blinkPeaks(1) < length(epochPoints)                        for iPoint=blinkPeaks(1)+1:length(epochPoints)                            theAmp=trialBlinkEOG(1,iPoint);                            if theAmp >= blinkThreshold                                if (epochPoints(iPoint)-epochPoints(blinkPeaks(end))) > blinkWindow || any(ismember(boundaryPoints,[epochPoints(blinkPeaks(end))+1:epochPoints(iPoint)]))                                    blinkPeaks=[blinkPeaks;iPoint]; %new blink peak                                    if iPoint < blinkEnds(end)                                        blinkEnds(end)=0;                                    end                                    theStart=max(find(trialBlinkEOGgrad(1:iPoint-1)<0));                                    %                                         theStart=max(find(trialBlinkEOG(1:iPoint) < (blinkEdgeThreshold)));                                    if isempty(theStart)                                        blinkStarts(end+1,1)=0;                                        firstBlinkSamp=1;                                    elseif theStart < max(blinkEnds)                                        blinkStarts(end+1,1)=0;                                        firstBlinkSamp=max(blinkEnds);                                    elseif theStart < max(blinkPeaks(1:end-1))                                        blinkStarts(end+1,1)=0;                                        firstBlinkSamp=max(blinkPeaks(1:end-1))+1;                                    elseif any(ismember(boundaryPoints,[epochPoints(theStart)+1:epochPoints(iPoint)]))                                        blinkStarts(end+1,1)=0;                                        firstBlinkSamp=max(boundaryPoints(ismember(boundaryPoints,[epochPoints(theStart)+1:epochPoints(iPoint)])));                                    else                                        blinkStarts(end+1,1)=theStart;                                        firstBlinkSamp=theStart;                                    end                                    %                                         theEnd=iPoint-1+min(find(trialBlinkEOG(iPoint:end) < (blinkEdgeThreshold)));                                    theEnd=min(find(trialBlinkEOGgrad(iPoint+1:end)>0))+iPoint-1;                                    if isempty(theEnd)                                        blinkEnds(end+1,1)=0;                                        lastBlinkSamp=length(epochPoints);                                    elseif any(ismember(boundaryPoints,[epochPoints(iPoint)+1:epochPoints(theEnd)]))                                        blinkEnds(end+1,1)=0;                                        lastBlinkSamp=max(find(ismember([epochPoints(iPoint)+1:epochPoints(theEnd)],boundaryPoints)));                                    else                                        blinkEnds(end+1,1)=theEnd;                                        lastBlinkSamp=theEnd;                                    end                                    trialData(ETchans,epochPoints(firstBlinkSamp:lastBlinkSamp))=NaN; %NaN out eye-tracker data during blinks                                    if ~isempty(dataChunk.events{theSubject,iTrial})                                        theValues={dataChunk.events{theSubject,iTrial}.value};                                        valList=[];                                        for iValue=1:length(theValues)                                            if any(strcmp(theValues{iValue},{'saccadeET','fixationET'}))                                                valList(end+1)=iValue;                                            end                                        end                                        ETevents=find(ismember([dataChunk.events{theSubject,iTrial}(valList').sample],[firstBlinkSamp:lastBlinkSamp]));                                        if ~isempty(ETevents)                                            dataChunk.events{theSubject,iTrial}(ETevents)=[]; %drop ET                                        end                                    end                                else                                    if theAmp > trialBlinkEOG(1,blinkPeaks(end))                                        blinkPeaks(end)=iPoint; %update current blink peak                                        theEnd=min(find(trialBlinkEOGgrad(blinkPeaks(end)+blinkLengthMin:end)>0))+blinkPeaks(end)+blinkLengthMin-1;                                        %                         blinkEnds=min(find(trialBlinkEOG(blinkPeaks(1):end) < (blinkEdgeThreshold)))+blinkPeaks(1)-1;                                        if isempty(theEnd) || any(ismember(boundaryPoints,[epochPoints(blinkPeaks(end))+1:epochPoints(theEnd)]))                                            theEnd=0;                                        end                                        blinkEnds(end)=theEnd;                                    end                                end                            end                        end                    end                end                for iBlink=1:length(blinkPeaks)                    count=count+1;                                        if blinkStarts(iBlink) > 0                        dataChunk.events{theSubject,iTrial}(end+1).sample=goodPoints(epochPointsGP(blinkStarts(iBlink)))-((iTrial-1)*trialSize);                        dataChunk.events{theSubject,iTrial}(end).type='artifact';                        dataChunk.events{theSubject,iTrial}(end).value='blink_start';                        dataChunk.events{theSubject,iTrial}(end).duration=0;                        dataChunk.events{theSubject,iTrial}(end).keys.code='blnk';                        dataChunk.events{theSubject,iTrial}(end).keys.data=num2str(count);                        dataChunk.events{theSubject,iTrial}(end).keys.datatype='text';                        dataChunk.events{theSubject,iTrial}(end).keys.description='';                    end                                        dataChunk.events{theSubject,iTrial}(end+1).sample=goodPoints(epochPointsGP(blinkPeaks(iBlink)))-((iTrial-1)*trialSize);                    dataChunk.events{theSubject,iTrial}(end).type='artifact';                    dataChunk.events{theSubject,iTrial}(end).value='blink';                    dataChunk.events{theSubject,iTrial}(end).duration=0;                    dataChunk.events{theSubject,iTrial}(end).keys.code='blnk';                    dataChunk.events{theSubject,iTrial}(end).keys.data=num2str(count);                    dataChunk.events{theSubject,iTrial}(end).keys.datatype='text';                    dataChunk.events{theSubject,iTrial}(end).keys.description='';                                        if blinkEnds(iBlink) > 0                        dataChunk.events{theSubject,iTrial}(end+1).sample=goodPoints(epochPointsGP(blinkEnds(iBlink)))-((iTrial-1)*trialSize);                        dataChunk.events{theSubject,iTrial}(end).type='artifact';                        dataChunk.events{theSubject,iTrial}(end).value='blink_end';                        dataChunk.events{theSubject,iTrial}(end).duration=0;                        dataChunk.events{theSubject,iTrial}(end).keys.code='blnk';                        dataChunk.events{theSubject,iTrial}(end).keys.data=num2str(count);                        dataChunk.events{theSubject,iTrial}(end).keys.datatype='text';                        dataChunk.events{theSubject,iTrial}(end).keys.description='';                    end                                        blinkTrialNum{iChunk}(theSubject,iTrial)=1; %mark this epoch as having at least one blink                    startPoint=blinkStarts(iBlink);                    if startPoint==0                        if iBlink==1                            epochStart=epochPoints(1);                        else                            epochStart=epochPoints(blinkPeaks(iBlink-1));                        end                    else                        epochStart=epochPoints(startPoint);                    end                    boundPoints=intersect(boundaryPoints,[epochStart+1:epochPoints(blinkPeaks(iBlink))]);                    if ~isempty(boundPoints)                        epochStart=max(boundPoints);                    end                                        endPoint=blinkEnds(iBlink);                    if endPoint==0                        if iBlink==length(blinkPeaks)                            epochEnd=epochPoints(end);                        else                            epochEnd=epochPoints(blinkPeaks(iBlink+1));                        end                    else                        epochEnd=epochPoints(endPoint);                    end                    boundPoints=intersect(boundaryPoints,[epochPoints(blinkPeaks(iBlink))+1:epochEnd]);                    if ~isempty(boundPoints)                        epochEnd=min(boundPoints);                    end                                        blinkPoints{iChunk-startChunk+1}=[blinkPoints{iChunk-startChunk+1}; [epochStart+1:epochEnd-1]'];                end            end        end        blinkPoints{iChunk-startChunk+1}=unique(blinkPoints{iChunk-startChunk+1});                %even if no discernible blink peaks, there can still be blink-related activity like blink recovery artifact        if strcmp(eogMethod,'EMCP')            trialData(chans,:) = reshape(corRawData,length(chans),[]);        else            dataGP = trialData(chans,goodPoints);            noblinkdataGP= dataGP - blinkdata(chans,goodPoints);            trialData(chans,goodPoints) = noblinkdataGP;            subtractedBlinks=zeros(size(trialData));            subtractedBlinks(chans,goodPoints) = blinkdata(chans,goodPoints);        end                if ~scanFlag            if count == 0                msg=['No blink peaks detected but blink-related activity corrected.'];            elseif count == 1                msg=['One blink corrected.'];            else                msg=[num2str(count) ' blinks corrected.'];            end        else            if count == 0                msg=['No blink periods detected.'];            elseif count == 1                msg=['One blink period detected.'];            else                msg=[num2str(count) ' blink periods detected.'];            end        end        disp(msg);        outputLog{end+1}=msg;                if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})            figure(butterflyFig{iChunk});            theTitle='subtracted blinks';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,subtractedBlinks,chans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        theTitle='with blinks subtracted';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialData,chans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end    else        msg='No components match blink template so no correction performed.';        disp(msg);        outputLog{end+1}=msg;                subtractedBlinks = zeros(size(dataChunk.data(:,:,:,1)));                if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})            figure(butterflyFig{iChunk});            if numSubs > 1                theTitle='subtracted blinks';            else                theTitle='no blinks to subtract that were detected';            end            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,zeros(size(trialData)),chans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title(theTitle,'Interpreter','none');                        if numSubs > 1                theTitle='with blinks subtracted';            else                theTitle='no blinks subtracted';            end            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialData,chans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end    end        if strcmp(eogMethod,'EMCP')        if any(any(any(subtractedSaccades)))            corData=zeros(size(trialData));            corData(chans,:) = reshape(corRawData,numGoodChans,[]); %flatten to two-dimensional array.                        if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})                figure(butterflyFig{iChunk});                theTitle='subtracted saccades';                plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,reshape(subtractedSaccades,numChans,[]),chans,theSubject);                subplot(numGraphs,1,graphCounter-4), plot([1:decimateSamples:totalDisplayPeriod],plotData);                title(theTitle,'Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                                theTitle='with saccades subtracted';                plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,corData,chans,theSubject);                subplot(numGraphs,1,graphCounter-3), plot([1:decimateSamples:totalDisplayPeriod],plotData);                title(theTitle,'Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);            end        else            msg='EMCP did not perform any saccade correction.';            disp(msg);            outputLog{end+1}=msg;                        if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})                figure(butterflyFig{iChunk});                if numSubs > 1                    theTitle='subtracted saccades';                else                    theTitle='no saccades to subtract that were detected';                end                plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,zeros(size(trialData)),chans,theSubject);                subplot(numGraphs,1,graphCounter-4), plot([1:decimateSamples:totalDisplayPeriod],plotData);                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                title(theTitle,'Interpreter','none');                                if numSubs > 1                    theTitle='with saccades subtracted';                else                    theTitle='no saccades subtracted';                end                plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialData,chans,theSubject);                subplot(numGraphs,1,graphCounter-3), plot([1:decimateSamples:totalDisplayPeriod],plotData);                title(theTitle,'Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);            end        end    end    drawnow        if ~isempty(baseline)			%baseline again in case there were blinks in the baseline period.        for iTrial = 1:numTrials            epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            base=(iTrial-1)*trialSize+baseline;            goodBase=goodPoints(find(ismember(base,goodPoints)));            if ~isempty(epoch) && ~isempty(goodBase)                baseMeans = mean(trialData(EEGchans,goodBase),2);                trialData(EEGchans,epoch)=trialData(EEGchans,epoch)-diag(baseMeans)*ones(length(EEGchans),length(epoch));            end        end    end        if length(refChan) == 2        trialData(refChan(2),:)=-trialData(refChan(1),:);     %put second reference channel back in.    end        %rereference the data.    if ~isempty(refChan)        for iTrial = 1:numTrials            epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            if ~isempty(epoch)                referenceData=mean(trialData(refChan,epoch),1);                for iChan=1:length(EEGchans)                    theChan=EEGchans(iChan);                    trialData(theChan,epoch)=trialData(theChan,epoch)-referenceData;                end            end        end    end        dataChunk.data(:,:,:,theSubject)=reshape(trialData,size(dataChunk.data(:,:,:,theSubject)));    dataChunk.analysis.blinkTrial(theSubject,:)=blinkTrialNum{iChunk}(theSubject,:);        subtractedEOG=zeros(1,size(trialData,2));    if any(blinksign ==1)        subtractedEOG(1,goodPoints) = subtractedEOG(1,goodPoints)+mean(subtractedBlinks(VEOG(blinksign ==1),goodPoints),1);    end    if any(blinksign ==-1)        subtractedEOG(1,goodPoints) = subtractedEOG(1,goodPoints)+mean(subtractedBlinks(VEOG(blinksign ==-1),goodPoints),1);    end        blinkChan=find(strcmp('blink',dataChunk.chanNames));    if isempty(blinkChan)        EPadd.chanNames{1}='blink';        EPadd.chanTypes{1}='REG';        EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));        EPadd.data(:,:,:,theSubject)=reshape(subtractedEOG,size(dataChunk.data(1,:,:,1)));        if isfield(dataChunk,'interpChans')            interpChans=dataChunk.interpChans;            dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            dataChunk.interpChans=interpChans;        else            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');        end    else        dataChunk.data(blinkChan,:,:,theSubject)=reshape(subtractedEOG,size(dataChunk.data(1,:,:,1)));    end        if strcmp(eogMethod,'EMCP')        saccChan=find(strcmp('Hsaccade',dataChunk.chanNames));        if isempty(saccChan)            EPadd.chanNames{1}='Hsaccade';            EPadd.chanTypes{1}='REG';            EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));            EPadd.data(:,:,:,theSubject)=reshape(hSaccEEG,1,size(dataChunk.data,2),[]);            if isfield(dataChunk,'interpChans')                interpChans=dataChunk.interpChans;                dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.                [dataChunk]=ep_addData(dataChunk,EPadd,'channels');                dataChunk.interpChans=interpChans;            else                [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            end        else            dataChunk.data(saccChan,:,:,theSubject)=reshape(hSaccEEG,1,size(dataChunk.data,2),[]);        end                saccChan=find(strcmp('Vsaccade',dataChunk.chanNames));        if isempty(saccChan)            EPadd.chanNames{1}='Vsaccade';            EPadd.chanTypes{1}='REG';            EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));            EPadd.data(:,:,:,theSubject)=reshape(vSaccEEG,1,size(dataChunk.data,2),[]);            if isfield(dataChunk,'interpChans')                interpChans=dataChunk.interpChans;                dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.                [dataChunk]=ep_addData(dataChunk,EPadd,'channels');                dataChunk.interpChans=interpChans;            else                [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            end        else            dataChunk.data(saccChan,:,:,theSubject)=reshape(vSaccEEG,1,size(dataChunk.data,2),[]);        end    end        if isempty(dataChunk)        disp('Warning: No file saved due to program error.');    end    if exist('EPchunk','var') && ~isempty(EPchunk)        if exist('EPchunkSP','var') && ~isempty(EPchunkSP)            EPchunkSP{iChunk}=dataChunk;        else            EPchunk{iChunk}=dataChunk;        end    else        ep_tictoc('ioStart');        eval (['save ''' outFile '-' num2str(iChunk) '.mat'' dataChunk']);        ep_tictoc('ioFinish');    end        if standAlone        try            MATLABver=ver('MATLAB');            [a b]=strtok(MATLABver.Version,'.');            b=b(2:end);            if ~isprop(butterflyFig,'Number')                eval (['print -f' num2str(butterflyFig{iChunk}) ' -djpeg ''' inFile '-' num2str(iChunk) 'EOG.jpg''']);            else                eval (['print -f' num2str(butterflyFig{iChunk}.Number) ' -djpeg ''' inFile '-' num2str(iChunk) 'EOG.jpg''']);            end        catch            disp('Couldn''t save a copy of the artifact correction figure.  Perhaps your version of Matlab is not current.');        end    end    priorPoints=priorPoints+size(trialData,2);    subtractedBlinksTopo=subtractedBlinksTopo+mean(subtractedBlinks(EEGchans,:),2,'omitnan');end% if noisier == 1%     msg=['1 ' theSegment ' was noisier after correction.'];% else%     msg=[num2str(noisier) ' ' theSegment 's were noisier after correction.'];% end% disp(msg);% outputLog{end+1}=msg;totblinkTrialNum=[];for iChunk = startChunk:endChunk    totblinkTrialNum=[totblinkTrialNum blinkTrialNum{iChunk}];endtemplates.blinks.auto=zeros(length(EEGchans),1);if any(strcmp(blinkSource,{'autoTemplate','bothTemplate','eyeTracker'}))    totalAutoTemplate=zeros(size(blinkAutoTemplate{1}));    for iChunk = startChunk:endChunk        totalAutoTemplate=totalAutoTemplate+blinkAutoTemplate{iChunk};    end    totalAutoTemplate=totalAutoTemplate/(endChunk-startChunk+1);    templates.blinks.auto(chans,1)=totalAutoTemplate;else    templates.blinks.auto=[];endtemplates.blinks.manual=zeros(length(EEGchans),1);if any(strcmp(blinkSource, {'fileTemplate','bothTemplate'}))    templates.blinks.manual=blinkManualTemplateAC;else    templates.blinks.manual=[];endtemplates.blinks.blinkTopo=subtractedBlinksTopo;if strcmp(eogMethod,'EMCP')    templates.hSaccades.manual=zeros(length(EEGchans),1);    templates.vSaccades.manual=zeros(length(EEGchans),1);    if any(strcmp(sacSource, {'fileTemplate','bothTemplate'}))        if ~isempty(hSaccManualTemplate)            templates.hSaccades.manual(chans,1)=hSaccManualTemplate(chans);        end        if ~isempty(vSaccManualTemplate)            templates.vSaccades.manual(chans,1)=vSaccManualTemplate(chans);        end    end        templates.hSaccades.auto=zeros(length(EEGchans),1);    templates.vSaccades.auto=zeros(length(EEGchans),1);    %     if any(strcmp(sacSource, {'autoTemplate','bothTemplate','eyeTracker'}))    %         if ~isempty(hSaccAutoTemplate)    %             templates.hSaccades.auto(chans,1)=hSaccAutoTemplate(chans);    %         end    %         if ~isempty(vSaccAutoTemplate)    %             templates.vSaccades.auto(chans,1)=vSaccAutoTemplate(chans);    %         end    %     end        templates.hSaccades.hSaccadesTopo(chans,1)=saccHwinv;    templates.vSaccades.vSaccadesTopo(chans,1)=saccVwinv;end