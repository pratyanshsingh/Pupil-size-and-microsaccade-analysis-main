function [totmoveTrialNum , outputLog, graphCounter] = ep_fixMovement(inFile, startChunk, endChunk, badDataCriteria, badChans, refChan, butterflyFig, graphCounter, numGraphs, theSubject, eog)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [totmoveTrialNum , outputLog, graphCounter] = ep_fixMovement(inFile, startChunk, endChunk, badDataCriteria, badChans, refChan, butterflyFig, graphCounter, numGraphs, theSubject, eog)%%	Reads in file chunks generated by chunkInputFile function.  It runs an ICA on each individual trial%   and drops factors corresponding to large noise sources (usually movement artifact).%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.%%Inputs%	inFile:     filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	startChunk: starting chunk (usually 1)%   endChunk:   ending chunk%   badDataCriteria:  Criteria for detecting bad data.%       .window:    moving average window for smoothing%       .minmax:    difference from minimum to maximum for bad channel%       .trialminmax:  difference from minimum to maximum for bad trial%       .badnum:    percent of bad channels exceeded to declare bad trial, rounding down%       .hminmax:   difference from minimum to maximum for bad horizontal EOG%       .neighbors: number of electrodes considered to be neighbors%       .badchan:   maximum microvolt difference allowed from best matching neighbor%       .maxneighbor:   maximum microvolt difference allowed from best matching neighbor%       .blink:     threshold correlation with blink template, 0 to 1%       .detrend:   1 to detrend%       .badtrials: percentage of good trials chan is bad to declare a channel globally bad%       .replace:   1 to interpolate bad channels from neighbors.%       .noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad)%       .movefacs  : number of factors to retain during movement correction.%       .channelMode: 'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing.%       .trialMode: 'fix' to fix bad trial data and 'none' to do nothing.%   badChans:   list of bad channels to exclude from blink detection process.  Will be set to a flat line.%   refChan:    Array of current reference channels.%   butterflyFig:  the handle for the output figure.  Otherwise, will open a new figure.%   graphCounter: the current subplot for the summary figure.%   numGraphs: the total number of subgraphs in the summary figure.%   theSubject: which subject of the file is being processed.%   eog:        EOG channels.%%   The input chunks are EP format data files.%%Outputs%	totmoveTrialNum: Total list of movement trials.%	Saves files with movement artifact removed, replacing the original chunked files.%   outputLog: output messages from noise fixing process%   graphCounter: the current subplot for the summary figure.%% History:%% by Joseph Dien (5/26/09)% jdien07@mac.com%%  modified 10/28/09 JD%  Added option to disable preprocessing figure for low memory situations.%%  modified 2/11/10 JD%  Will now work with subject average files with multiple subjects.%  MoveTrial no longer initialized to zero.%%  modified 10/12/10 JD%  For continuous files, data now divided into one second epochs and can be artifact rejected in an epochwise fashion%  in same fashion as segmented data.%%  modified 10/16/10 JD%  Added support for HEOG saccade correction.%% modified 9/24/13 JD% Restricted blink correction to EEG channels.%% bufix 3/11/14 JD% Handles decimal sampling rates gracefully.%% modified 3/18/14 JD% Changed uses of "temp" as a variable name to "tempVar" due to other Matlab programmers often using it as a function% name, resulting in collisions.%% modified 6/2/14 JD% Rereference an epoch after performing movement correction% Obtains reference channel info from function call rather than file to make consistent with the other artifact% correction subroutines.%% bugfix 8/14/15 JD% Fixed unable to save artifact correction summary figure starting with% Matlab 2014b in stand-alone mode.%% modified 1/24/17 JD% Excluding EOG channels from the movement correction detection.%% bugfix 10/5/17 JD% Fixed crashes due to Matlab changing their graphics objects AGAIN in 2017b.%% bugfix 10/20/17 JD% Eliminated x tick labels to address problem with subplots in summary% artifact figure getting squeezed by formatting problem on PCs.%% modified 2/4/18 JD% Made subplot specification for summary figure output more flexible.%% modified 4/8/18 JD% Consolidated summary figure for average files so no longer one per subject.%% bugfix 8/27/18 JD% Handles case where pinv unable to invert the correlation matrix and% crashes.%% bugfix & modified 6/24/19 JD% Fixed case where channel has sporadic high amplitude bad data, derailing mean correction.% Accelerates artifact correction by adding option to keep chunks in RAM.% Now excludes global bad channels from summary subplot.%% bugfix 9/17/19 JD% Fixed crash when clicking abort button.% % bugfix 11/4/20 JD% Can now handle NaN data values.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2025  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPchunk EPtictocif ~isempty(butterflyFig)    graphCounter=graphCounter+2;endmsg='Fixing movement artifacts.';disp(msg);outputLog{1}=msg;moveTrialNum = [];totmoveTrialNum=[];badChans = badChans(find(badChans));	%drop out bad channels set as being zerooutputLog=[];count=0;theEOG(1) = eog.LUVEOG;theEOG(2) = eog.RUVEOG;theEOG(3) = eog.LLVEOG;theEOG(4) = eog.RLVEOG;warning off GLREN:doubleBufferSlow; %Turn off warning message about doublebuffer not available.if ~exist('butterflyFig','var')    butterflyFig=figure('Name','Movement Artifact Correction','NumberTitle','off');    colormap jet;    standAlone=1;else    standAlone=0;endfor iChunk = startChunk:endChunk    disp([deblank(inFile) '-' num2str(iChunk)]);    if exist('EPchunk','var') && ~isempty(EPchunk)        dataChunk=EPchunk{iChunk};    else        ep_tictoc('ioStart');        eval(['load ''' deblank(inFile) '-' num2str(iChunk) '.mat''']);        ep_tictoc('ioFinish');    end        if length(dataChunk.facNames) > 1        disp('This function is not intended for application to factor data.');        return    end        if strcmp(dataChunk.dataType,'continuous')        theSegment = 'one second epoch';    else        theSegment = 'trial';    end        numChans=length(dataChunk.chanNames);    numSubs=length(dataChunk.subNames);    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    if strcmp(dataChunk.dataType,'continuous')        numTrials=floor(size(dataChunk.data,2)/ceil(dataChunk.Fs)); %excess time points are tacked onto final epoch        trialdata=dataChunk.data(:,:,:,theSubject);        trialSize = min(ceil(dataChunk.Fs),size(dataChunk.data,2)); %one second epochs    else        numTrials = length(dataChunk.cellNames);        trialdata=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);        trialSize = length(dataChunk.timeNames);    end        subtractedNoise = zeros(size(trialdata));    moveTrialNum{iChunk}=dataChunk.analysis.moveTrial;    chans = setdiff(EEGchans,badChans);    if strcmp(dataChunk.dataType,'continuous')        displayPeriod=size(dataChunk.data,2);    %Number of timepoints to graph in display.    else        displayPeriod=size(dataChunk.data,2)*size(dataChunk.data,3);    end    decimateSamples=ceil(max(1,displayPeriod/10000));    totalDisplayPeriod=displayPeriod*size(dataChunk.data,4);    nonEOGchans=find(~ismember(chans,theEOG));    chanMeans=repmat(median(dataChunk.data(chans,:)','omitnan')',1,trialSize);        if standAlone        subplot(3,1,1), plot([1:displayPeriod],trialdata(chans,1:displayPeriod));        axis([1 displayPeriod -200 200])        set(gca,'XTickLabel','','XTick',[]);        title([deblank(inFile) '-' num2str(iChunk)],'Interpreter','none');    end        fprintf('%60s\n',' ' );    for trial =1:numTrials        ep_tictoc;if EPtictoc.stop;return;end        fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Working on ' theSegment '# '], trial, numTrials))        theData=trialdata(chans,(trial-1)*trialSize+1:trial*trialSize)-chanMeans;        if strcmp(dataChunk.dataType,'continuous') && trial == numTrials            theData=trialdata(chans,(trial-1)*trialSize+1:end); %excess time points are tacked onto final epoch        end        if abs(min(min(theData(nonEOGchans,:),[],'omitnan'),[],'omitnan') - max(max(theData(nonEOGchans,:),[],'omitnan'),[],'omitnan')) > badDataCriteria.trialminmax %don't bother with PCA if no large amplitude voltages            S = cov(theData); %covariance matrix            goodPoints=~isnan(diag(S));            if (~any(diag(S)==0)) && (length(find(goodPoints))>=badDataCriteria.movefacs) %if any time points have zero variance, may not be factorable and definitely not fixable                Sd = diag(sqrt(diag(S(goodPoints,goodPoints))));  %diagonal matrix of standard deviations of variables as used to generate relationship matrix                [V,L] = eig(S(goodPoints,goodPoints));                V = fliplr(V);                numFac=badDataCriteria.movefacs;                V = V(:,1:numFac);  %truncated eigenvector matrix                FacScr = (theData(:,goodPoints)) * V;    %factor scores, not mean corrected.                ScrDiag = diag(std(FacScr));                A = inv(Sd) * (V * ScrDiag);  %unrotated factor loading matrix                C = sum((A.^2),2)';                A = (diag(sqrt(C).^-1)) * A;  %factor loadings Kaiser-normalized by communalities                [FacPat]= ep_doVarimax(A);                FacPat = diag(sqrt(C)) * FacPat;  %renormalize factor loadings by original communalities                [FacPat, FacCor] = ep_doPromax(FacPat, 3); %Only apply loading weighting to the Varimax step                %to match SAS output and to avoid rounding errors.                FacStr = FacPat * FacCor;	%factor structure matrix (Harman, eq. 12.19, p. 268)                inversionError=0;                try                    invR=pinv(corrcoef(theData(:,goodPoints)));                catch                    inversionError=1;                end                if ~inversionError                    FacCof=invR*FacStr;                    FacScr=(theData(:,goodPoints))*FacCof;                    FacScr=(FacScr)*inv(diag(std(FacScr)));                                        noiseFacs=find(abs(max(abs(Sd*FacPat)).*(max(FacScr(nonEOGchans,:))-min(FacScr(nonEOGchans,:)))) > badDataCriteria.trialminmax);                                        if ~isempty(noiseFacs) %if there are noise factors, subtract them out                        FacScrFull = zeros(numChans,numFac);                        for i = 1:length(chans)                            FacScrFull(chans(i),:)=FacScr(i,:);                        end                        tempVar = zeros(numFac,1);                        tempVar(noiseFacs) = 1;                        noisedata=zeros(numChans,size(theData,2));                        noisedata(:,goodPoints) = FacScrFull * (Sd*FacPat* diag(tempVar))';                        if strcmp(dataChunk.dataType,'continuous') && trial == numTrials                            nonoisedata= trialdata(:,(trial-1)*trialSize+1:end) - noisedata;                            if ~isempty(refChan)                                nonoisedata=nonoisedata-repmat(mean(nonoisedata(refChan,:),1),numChans,1); %rereference the data.                            end                            trialdata(:,(trial-1)*trialSize+1:end) = nonoisedata;                            subtractedNoise(:,(trial-1)*trialSize+1:end) = noisedata;                        else                            nonoisedata= trialdata(:,(trial-1)*trialSize+1:trial*trialSize) - noisedata;                            if ~isempty(refChan)                                nonoisedata=nonoisedata-repmat(mean(nonoisedata(refChan,:),1),numChans,1); %rereference the data.                            end                            trialdata(:,(trial-1)*trialSize+1:trial*trialSize) = nonoisedata;                            subtractedNoise(:,(trial-1)*trialSize+1:trial*trialSize) = noisedata;                        end                        count=count+1;                        moveTrialNum{iChunk}(trial)=1;                                            end                end            end        end    end    fprintf('%60s\n',' ' );        if count == 1        msg=['1 ' theSegment ' corrected for movement activity.'];    else        msg=[num2str(count) ' ' theSegment 's corrected for movement activity.'];    end    disp(msg);    outputLog{end+1}=msg;        if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})        if standAlone            figure(butterflyFig{iChunk});            subplot(3,1,2), plot([1:totalDisplayPeriod],subtractedNoise(chans,1:totalDisplayPeriod));            title('subtracted movement artifacts','Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        subplot(3,1,3), plot([1:totalDisplayPeriod],trialdata(chans,1:totalDisplayPeriod));            title('with movement artifacts subtracted','Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        else            figure(butterflyFig{iChunk});            theTitle='subtracted movement artifacts';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,subtractedNoise,chans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        theTitle='with movement artifacts subtracted';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialdata,chans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end    end        if count == 0        msg='No components met threshold so no correction performed.';        disp(msg);        outputLog{end+1}=msg;                if ~isempty(butterflyFig) && ishandle(butterflyFig{iChunk})            if standAlone                figure(butterflyFig{iChunk});                subplot(3,1,2), plot([1:totalDisplayPeriod],ones(1,totalDisplayPeriod));                title('no movements to subtract that were detected','Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                                subplot(3,1,3), plot([1:totalDisplayPeriod],trialdata(chans,1:totalDisplayPeriod));                title('no movement artifacts subtracted','Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);            else                figure(butterflyFig{iChunk});                if numSubs > 1                    theTitle='subtracted movement artifacts';                else                    theTitle='no movements to subtract that were detected';                end                plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,zeros(size(trialdata)),chans,theSubject);                subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);                title(theTitle,'Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                                if numSubs > 1                    theTitle='with movement artifacts subtracted';                else                    theTitle='no movement artifacts subtracted';                end                plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialdata,chans,theSubject);                subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);                title(theTitle,'Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);            end        end    end        drawnow        if strcmp(dataChunk.dataType,'continuous')        dataChunk.data(:,:,:,theSubject)=trialdata;    else        dataChunk.data(:,:,:,theSubject)=reshape(trialdata,numChans,trialSize,numTrials);    end    dataChunk.analysis.moveTrial(theSubject,:)=moveTrialNum{iChunk};        if exist('EPchunk','var') && ~isempty(EPchunk)        EPchunk{iChunk}=dataChunk;    else        ep_tictoc('ioStart');        eval (['save ''' inFile '-' num2str(iChunk) '.mat'' dataChunk']);        ep_tictoc('ioFinish');    end    if standAlone        try            MATLABver=ver('MATLAB');            [a b]=strtok(MATLABver.Version,'.');            b=b(2:end);            if ~isprop(butterflyFig,'Number')                eval (['print -f' num2str(butterflyFig{iChunk}) ' -djpeg ''' inFile '''-' num2str(iChunk) 'move.jpg']);            else                eval (['print -f' num2str(butterflyFig{iChunk}.Number) ' -djpeg ''' inFile '''-' num2str(iChunk) 'move.jpg']);            end        catch            disp('Couldn''t save a copy of the movement correction figure.  Perhaps your version of Matlab is not current.');        end    endendif standAlone    close(butterflyFig);endtotmoveTrialNum=[];for iChunk = startChunk:endChunk    totmoveTrialNum=[totmoveTrialNum moveTrialNum{iChunk}];end