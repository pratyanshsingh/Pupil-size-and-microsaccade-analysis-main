function [totblinkTrialNum, blinkPoints, templates, outputLog, graphCounter] = ep_emcp(inFile, outFile, startChunk, endChunk, badDataCriteria, badChans, eog, templateSource, blinkFile, saccadeFile, baseline, refChan, butterflyFig, graphCounter, numGraphs, theSubject)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [totblinkTrialNum, blinkPoints, templates, outputLog, graphCounter] = ep_emcp(inFile, outFile, startChunk, endChunk, badDataCriteria, badChans, eog, templateSource, blinkFile, saccadeFile, baseline, refChan, butterflyFig, graphCounter, numGraphs, theSubject)%%	Reads in file chunks generated by chunkInputFile function (should be set at a size small%	enough to fit in memory.  100,000 samples of 128chan data can be processed with ICA.%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.%%Inputs%	inFile:     filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	outFile:    filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	startChunk: starting chunk (usually 1)%   endChunk:   ending chunk%   badDataCriteria:  Criteria for detecting bad data.%       .window:    moving average window for smoothing%       .minmax:    difference from minimum to maximum for bad channel%       .trialminmax:  difference from minimum to maximum for bad trial%       .badnum:    percent of bad channels exceeded to declare bad trial, rounding down%       .hminmax:   difference from minimum to maximum for bad horizontal EOG%       .neighbors: number of electrodes considered to be neighbors%       .badchan:   maximum microvolt difference allowed from best matching neighbor%       .maxneighbor:   maximum microvolt difference allowed from best matching neighbor%       .blink:     threshold correlation with blink template, 0 to 1%       .saccade:     threshold correlation with saccade template, 0 to 1%       .saccademin:  µv Saccade Fac is the minimum HEOG voltage difference required to constitute a possible saccade.%       .detrend:   1 to detrend%       .badtrials: percentage of good trials chan is bad to declare a channel globally bad%       .replace:   1 to interpolate bad channels from neighbors.%       .noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad)%       .movefacs  : number of factors to retain during movement correction.%       .channelMode: 'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing.%       .trialMode: 'fix' to fix bad trial data and 'none' to do nothing.%       .saturation: followed by range of acceptable data values.  Time points with a channel outside this range will be excluded.%   badChans:   list of bad channels to exclude from blink detection process.%   eog:        EOG channels.%   templateSource:   source of blink template (fileTemplate: load 'blinks' file.  autoTemplate: automatically generate blink template.%                  bothTemplate: use both file and automatic template at the same time).%   blinkFile:  file with blink template.  Assumed to be in the same directory as the data file.%   saccadeFile: file with saccade template.  Assumed to be in the same directory as the data file.%   baseline:   array of sample numbers to permanently baseline correct the trials with.  [] means don't correct.%   refChan:    Array of current reference channels.%   butterflyFig:  the handle for the output figure.  Otherwise, will open a new figure.%   graphCounter: the current subplot for the summary figure.%   numGraphs: the total number of subgraphs in the summary figure.%   theSubject: which subject of the file is being processed.%   blinkRotation: the rotation for the blink correction procedure..%%   The input chunks are EP format data files.%%Outputs%	totblinkTrialNum: Total list of blink trials.%   blinkPoints: Array of points that fall within blink periods, numbering end-to-end for single-trial data. (cell array of number of chunks)%   templates: the templates used for the correction, both file and auto if both used.%       .blinks%           .manual: manual template from file (number of EEG channels,1)%           .auto: auto template (number of EEG channels,1)%   outputLog: output messages from blink fixing process%%	Saves files with blinks removed, replacing the original chunked files.%   If baseline option is used (provides better results, particularly when%   there are large DC swings in the recordings), then the output will be%   baselined.%% History:%% by Joseph Dien (8/14/20)% jdien07@mac.com%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2025  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPchunk EPchunkSP EPtictocif ~isempty(butterflyFig)    graphCounter=graphCounter+4;endmsg='Starting eyeblinks routine.';disp(msg);outputLog{1}=msg;blinkPoints=cell(endChunk-startChunk+1,1);totblinkTrialNum=[];badChans=badChans(:); %make sure it's a column vectortemplates=[];if ~exist('butterflyFig','var')    butterflyFig=figure('Name','Artifact Correction','NumberTitle','off');    colormap jet;    standAlone=1;else    standAlone=0;endtheEOG(1) = eog.LUVEOG;theEOG(2) = eog.RUVEOG;theEOG(3) = eog.LLVEOG;theEOG(4) = eog.RLVEOG;theEOG(5) = eog.LHEOG;theEOG(6) = eog.RHEOG;blinkThreshold=300; %minimum microvolts to count as a blinkblinkwindowMS=100; %minimum separation for blinks in ms.slopeLengthMS=100; %for auto template, number of ms to look for slope on either side of putative blink peak.slopeThresh=2; %criterion for sufficient slope for putative blinkblinkSymm=100; %upper VEOG of blinks need to be within this range of each other to be included in automatic blink templates.blinkLengthMinMS=20; %minimum width of blink event when computing start and end of blink.filterWidthMS=20; %width of the smoothing filter window in MS.blinkEdgeThreshold=blinkThreshold/4;noisier=0;VEOG=[];goodVEOG=[];for iChan=1:4    if isempty(intersect(theEOG(iChan),badChans)) && (theEOG(iChan) ~= -1)        VEOG=[VEOG theEOG(iChan)];        goodVEOG(end+1)=iChan;    endendblinksign = [1 1 -1 -1]';blinksign=blinksign(goodVEOG,1);HEOG=[];for i=5:6    if isempty(intersect(theEOG(i),badChans)) && (theEOG(i) ~= -1)        HEOG=[HEOG theEOG(i)];    endendif length(HEOG) < 2    msg{1}='Need both HEOG channels.';    [msg]=ep_errorMsg(msg);    returnendif ~any(blinksign==1) || ~any(blinksign==-1)    msg{1}='Need both an upper and a lower VEOG channel.';    [msg]=ep_errorMsg(msg);    returnendblinkManualTemplate=[];blinkAutoTemplate=[];hSaccManualTemplate=[];vSaccManualTemplate=[];hSaccAutoTemplate=[];vSaccAutoTemplate=[];saccadeFileCorrect=0;if ~any(strcmp(templateSource, 'none'))        %saccade template    [fileDir, name, ext] = fileparts(inFile);    ep_tictoc('ioStart');    eval(['load ''' saccadeFile '''']);    ep_tictoc('ioFinish');        if ~exist('EPsaccade','var')        msg='Not a saccade template.';        [msg]=ep_errorMsg({msg});        return    end        if ~exist('EPsaccade','var')        msg='No saccade template so not computing correlation with EMCP.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        saccadeFileCorrect=0;    else        saccadeFileCorrect=1;        if (~isfield(EPsaccade,'vSaccade')) || ~any(EPsaccade.vSaccade.template)            msg='No vertical saccade template so not computing correlation with EMCP.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            vertSaccadeFileCorrect=0;        else            vertSaccadeFileCorrect=1;        end    end        if exist('EPchunk','var') && ~isempty(EPchunk)        if exist('EPchunkSP','var') && ~isempty(EPchunkSP) && isstruct(EPchunkSP{1})            dataChunk=EPchunkSP{1};        else            dataChunk=EPchunk{1};        end    else        ep_tictoc('ioStart');        eval(['load ''' deblank(inFile) '-' num2str(1) '.mat''']);        ep_tictoc('ioFinish');    end    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    EEGsaccChans=find(ismember({EPsaccade.eloc.type},{'EEG','REF'}));    nonHEOGbadChans=setdiff(badChans,[eog.LHEOG eog.RHEOG]); %HEOG bad chans will be interpolated    saccChans = setdiff(EEGsaccChans,nonHEOGbadChans);        if saccadeFileCorrect        hSaccManualTemplate=EPsaccade.hSaccade.template(:);        if size(hSaccManualTemplate,2) > 1            msg='Something is wrong with the saccade template.  It has the wrong dimensions.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end                %if the template is different from the dataset, remap the template        if (length(EPsaccade.eloc) ~= length(EEGchans)) || any([EPsaccade.eloc.theta]-[dataChunk.eloc.theta]) || any([EPsaccade.eloc.radius]-[dataChunk.eloc.radius])            newData=ep_interpChans(hSaccManualTemplate(saccChans), EPsaccade.eloc(saccChans), dataChunk.eloc(EEGchans));            ep_tictoc;if EPtictoc.stop;return;end            if isempty(newData)                return            else                hSaccManualTemplate=newData;            end        end        if vertSaccadeFileCorrect            vSaccManualTemplate=EPsaccade.vSaccade.template(:);            %if the template is different from the dataset, remap the template            if (length(EPsaccade.eloc) ~= length(EEGchans)) || any([EPsaccade.eloc.theta]-[dataChunk.eloc.theta]) || any([EPsaccade.eloc.radius]-[dataChunk.eloc.radius])                newData=ep_interpChans(vSaccManualTemplate(saccChans), EPsaccade.eloc(saccChans), dataChunk.eloc(EEGchans));                ep_tictoc;if EPtictoc.stop;return;end                if isempty(newData)                    return                else                    vSaccManualTemplate=newData;                end            end        end    end        %blink template        [fileDir, name, ext] = fileparts(inFile);    ep_tictoc('ioStart');    eval(['load ''' blinkFile '''']);    ep_tictoc('ioFinish');        if ~exist('EPblink','var')        msg{1}='Not a blink template so not computing correlation with EMCP.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        blinkFileCorrect=0;    else        blinkFileCorrect=1;    end        if blinkFileCorrect        blinkManualTemplate=EPblink.template;        if size(blinkManualTemplate,1) > 1            blinkManualTemplate = blinkManualTemplate'; %for some reason I had decided to have the templates be row vectors.        end        if size(blinkManualTemplate,1) > 1            msg='Something is wrong with the blink template.  It has the wrong dimensions.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end        %if the template is different from the dataset, remap the template        if (length(EPblink.eloc) ~= length(EEGchans)) || any([EPblink.eloc.theta]-[dataChunk.eloc.theta]) || any([EPblink.eloc.radius]-[dataChunk.eloc.radius])            newData=ep_interpChans(blinkManualTemplate', EPblink.eloc(EEGblinkChans), dataChunk.eloc(EEGchans));            ep_tictoc;if EPtictoc.stop;return;end            if isempty(newData)                return            else                blinkManualTemplate=newData;            end            blinkManualTemplate=blinkManualTemplate';        end    endendbadChans = badChans(find(badChans));	%drop out bad channels set as being zerooutputLog=cell(0);warning off GLREN:doubleBufferSlow; %Turn off warning message about doublebuffer not available.priorPoints=0;for iChunk = startChunk:endChunk    if endChunk > startChunk        msg=[deblank(inFile) '-' num2str(iChunk)];        disp(msg);        outputLog{end+1}=msg;    end        if exist('EPchunk','var') && ~isempty(EPchunk)        if exist('EPchunkSP','var') && ~isempty(EPchunkSP) && isstruct(EPchunkSP{iChunk})            dataChunk=EPchunkSP{iChunk};        else            dataChunk=EPchunk{iChunk};        end    else        ep_tictoc('ioStart');        eval(['load ''' deblank(inFile) '-' num2str(iChunk) '.mat''']);        ep_tictoc('ioFinish');    end        if strcmp(dataChunk.dataType,'continuous')        theSegment = 'one second epoch';    else        theSegment = 'trial';    end        numChans=length(dataChunk.chanNames);    numPoints=length(dataChunk.timeNames);    numCells=length(dataChunk.cellNames);    numSubs=length(dataChunk.subNames);    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    if length(dataChunk.facNames) > 1        msg='This function is not intended for application to factor data.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end        if iChunk ==startChunk        subtractedBlinksTopo=zeros(length(EEGchans),1);        subtractedHsacTopo=zeros(length(EEGchans),1);    end        ETchans=find(ismember(dataChunk.chanTypes,{'PPL';'XEY';'YEY'}));        trialData=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);    blinkData=squeeze(dataChunk.data(:,:,:,theSubject));        if strcmp(dataChunk.dataType,'continuous')        displayPeriod=size(dataChunk.data,2);    %Number of timepoints to graph in display.    else        displayPeriod=size(dataChunk.data,2)*size(dataChunk.data,3);    end    decimateSamples=ceil(max(1,displayPeriod/10000));    totalDisplayPeriod=displayPeriod*size(dataChunk.data,4);        if displayPeriod == 1        msg='There is only one time point and so the data cannot be blink/saccade corrected.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end        if strcmp(dataChunk.dataType,'continuous')        numTrials=floor(size(trialData,2)/ceil(dataChunk.Fs)); %excess time points are tacked onto final epoch        trialSize = min(ceil(dataChunk.Fs),size(trialData,2)); %one second epochs    else        trialSize = length(dataChunk.timeNames);        numTrials = length(dataChunk.cellNames);    end        chans = setdiff(EEGchans,badChans);    goodPoints = find((max(trialData(chans,:)-repmat(median(trialData(chans,:)')',1,size(trialData(chans,:),2))) < badDataCriteria.saturation(2)) & (min(trialData(chans,:)-repmat(median(trialData(chans,:)')',1,size(trialData(chans,:),2))) > badDataCriteria.saturation(1)));    if length(goodPoints) < size(trialData,2)        msg=[num2str(size(trialData,2)-length(goodPoints)) ' points were dropped as having exceeded the amplifier saturation threshold, which has been set at ' num2str(badDataCriteria.saturation(1)) ' and ' num2str(badDataCriteria.saturation(2)) '.'];        outputLog{end+1}=msg;        disp(msg);    end        if ~isempty(baseline)			%subtract out baselines before performing ICA        if strcmp(dataChunk.dataType,'continuous')            baseMeans = mean(trialData(EEGchans,baseline),2);            trialData(EEGchans,:)=trialData(EEGchans,:)-diag(baseMeans)*ones(length(EEGchans),size(trialData,2));        else            for iTrial = 1:numTrials                epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));                base=(iTrial-1)*trialSize+baseline;                goodBase=goodPoints(find(ismember(base,goodPoints)));                if ~isempty(epoch) && ~isempty(goodBase)                    baseMeans = mean(trialData(EEGchans,goodBase),2);                    trialData(EEGchans,epoch)=trialData(EEGchans,epoch)-diag(baseMeans)*ones(length(EEGchans),length(epoch));                end            end        end    end        if standAlone        if ~isempty(butterflyFig)            figure(butterflyFig(theSubject,iChunk));            [pathstr, fileName, ext]=fileparts(inFile);            subplot(3,1,1), plot([1:decimateSamples:displayPeriod],trialData([badChans; chans],1:decimateSamples:displayPeriod));            axis([1 displayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title([deblank(fileName) '-' num2str(iChunk)],'Interpreter','none');        end                if ~isempty(baseline)			%subtract out baselines before performing ICA            if ~isempty(butterflyFig)                subplot(3,1,2), plot([1:decimateSamples:displayPeriod],trialData([badChans; chans],1:decimateSamples:displayPeriod));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                title('with baselines subtracted','Interpreter','none');            end        else            if ~isempty(butterflyFig)                subplot(3,1,3), plot([1:decimateSamples:displayPeriod],trialData([badChans; chans],1:decimateSamples:displayPeriod));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                title('no baseline subtraction specified','Interpreter','none');            end        end    end        VEOGdata=mean(blinkData(VEOG(blinksign ==1),:,:),1)-mean(blinkData(VEOG(blinksign ==-1),:,:),1); %add VEOG difference wave    HEOGdata=blinkData(eog.LHEOG,:,:)-blinkData(eog.RHEOG,:,:); %add HEOG difference wave    [fzChan, theOrder] = ep_findChan(dataChunk.eloc, dataChunk.implicit, dataChunk.chanNames, dataChunk.ced, badChans, 'Fz', dataChunk.montage);    blinkData=blinkData(chans,:,:);    numGoodChans=length(chans);    blinkData(end+1,:,:)=VEOGdata;    blinkData(end+1,:,:)=HEOGdata;        parameters.verbose=1;                                   %0=no output to screen (for background jobs), 1=print progress to screen    parameters.beckman=0;                                   %0=not from Neuroscan lab, 1=from Neuroscan lab    parameters.digitizingRate=1000/dataChunk.Fs;            %Digitizing period (ms)    parameters.VEOG_CHANNEL=size(blinkData,1)-1;            %position of VEOG in rawData */    parameters.HEOG_CHANNEL=size(blinkData,1);              %position of HEOG in rawData */    parameters.FZ_CHANNEL=fzChan;                           %position of Fz channel in rawData.    parameters.eegChannels=length(chans)+2;                 %Number of EEG channels plus VEOG and HEOG.    parameters.criteria=badDataCriteria.saturation(2);      %Microvolt number that is deemed out-of-range.    cellList=unique(dataChunk.cellNames);    binData=zeros(length(dataChunk.cellNames),1);    for iCell=1:length(dataChunk.cellNames)        binData(iCell)=find(strcmp(dataChunk.cellNames{iCell},cellList));    end        [subBlinksGC, subSaccsGC, ~, ~, corRawData, msg] = EMCP(permute(blinkData,[3,2,1]), binData, parameters, []);    outputLog(end+1:end+length(msg))=msg;        subBlinksGC=permute(subBlinksGC,[3 2 1]);    subBlinksGC=subBlinksGC(1:numGoodChans,:,:);    subtractedBlinks=zeros(numChans,numPoints,numCells);    subtractedBlinks(chans,:,:)=subBlinksGC;        subSaccsGC=permute(subSaccsGC,[3 2 1]);    subSaccsGC=subSaccsGC(1:numGoodChans,:,:);     subtractedSaccades=zeros(numChans,numPoints,numCells);    subtractedSaccades(chans,:,:)=subSaccsGC;        corRawData=permute(corRawData,[3 2 1]);    corRawData=corRawData(1:numGoodChans,:,:);        blinkTrialNum{iChunk}=dataChunk.analysis.blinkTrial;    blinkEOG=mean(subtractedBlinks(VEOG(blinksign ==1),:,:),1)-mean(subtractedBlinks(VEOG(blinksign ==-1),:,:),1);    saccEOG=subtractedSaccades(eog.LHEOG,:,:)-subtractedSaccades(eog.RHEOG,:,:);    blinkEOG=blinkEOG-mean(blinkEOG);    saccEOG=saccEOG-mean(saccEOG);        chanMeans=mean(trialdata','omitnan')';        %generate automatic blink template    if any(strcmp(templateSource,{'autoTemplate','bothTemplate','eyeTracker'}))        blinkTimes = zeros(numTrials,1);        if strcmp(templateSource,'eyeTracker') && ~isempty(dataChunk.events{1})            blinkSamps=round([dataChunk.events{1}(find(strcmp('blinkStartET',{dataChunk.events{1}.value}))).sample]);            blinkSamps=blinkSamps-priorPoints;            blinkSamps=blinkSamps((blinkSamps > 0) & (blinkSamps <= size(trialdata,2))); %only saccadeET events in the current data chunk.        end                for iTrial = 1:numTrials %check each trial for presence of blink            if strcmp(dataChunk.dataType,'continuous') && (iTrial == numTrials)                epoch=goodPoints(find(goodPoints>((iTrial-1)*trialSize))); %excess time points are tacked onto final epoch            else                epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            end            if ~isempty(epoch)                blinkFlag=0;                blinkSignal = sum(diag(blinksign)*(trialdata(VEOG,epoch))-repmat(chanMeans(VEOG),1,length(epoch)))';                [maxamp maxpoint] = max(blinkSignal);                if strcmp(templateSource,'eyeTracker')                    if any(ismember(blinkSamps,epoch))                        blinkFlag=1;                    end                elseif ((epoch(maxpoint)-slopeLength) > 0) && ((epoch(maxpoint)+slopeLength) <= size(trialdata,2))                    badBlink=0;                    if all(ismember([1 2],goodVEOG)) && (abs((trialdata(eog.LUVEOG,epoch(maxpoint))-chanMeans(eog.LUVEOG))-(trialdata(eog.RUVEOG,epoch(maxpoint))-chanMeans(eog.RUVEOG))) > blinkSymm)                        badBlink=1; %upper VEOG not symmetrical enough to be counted for autoblink template                    end                    if all(ismember([1 3],goodVEOG)) && (abs((trialdata(eog.LUVEOG,epoch(maxpoint))-chanMeans(eog.LUVEOG))-(trialdata(eog.LLVEOG,epoch(maxpoint))-chanMeans(eog.LLVEOG))) < blinkThreshold)                        badBlink=1; %difference between upper and lower EOG too small to count as a blink.                    end                    if all(ismember([2 4],goodVEOG)) && (abs((trialdata(eog.RUVEOG,epoch(maxpoint))-chanMeans(eog.RUVEOG))-(trialdata(eog.RLVEOG,epoch(maxpoint))-chanMeans(eog.RLVEOG))) < blinkThreshold)                        badBlink=1; %difference between upper and lower EOG too small to count as a blink.                    end                    if ~badBlink                        blinkSignal = sum(diag(blinksign)*(trialdata(VEOG,epoch(maxpoint)-slopeLength:epoch(maxpoint))-repmat(chanMeans(VEOG),1,slopeLength+1)))';                        b1=[ones(slopeLength+1,1), [1:slopeLength+1]']\blinkSignal;                        blinkSignal = sum(diag(blinksign)*trialdata(VEOG,epoch(maxpoint):epoch(maxpoint)+slopeLength)-repmat(chanMeans(VEOG),1,slopeLength+1))';                        b2=[ones(slopeLength+1,1), [1:slopeLength+1]']\blinkSignal;                        if (b1(2) > slopeThresh) && (b2(2) < -slopeThresh)                            %if this really is a peak point and with reasonable slopes                            blinkFlag=1;                        end                    end                end                if blinkFlag                    if sign(maxamp) ~= 0                        blinkTimes(iTrial)=epoch(maxpoint); %timepoint of blink activity                    end                end            end        end                blinkTimes=blinkTimes(find(blinkTimes)); %compact array to eliminate trials with no blinks        emcpBlinks=mean(subtractedBlinks,2);        if ~isempty(blinkTimes)            if length(blinkTimes) == 1                msg=['1 blink ' theSegment ' used for template generation.'];            else                msg=[num2str(length(blinkTimes)) ' blink ' theSegment 's used for template generation.'];            end            disp(msg);            outputLog{end+1}=msg;            if length(blinkTimes) == 1                autoBlinks=trialdata(chans,blinkTimes)';            else                autoBlinks=mean(trialdata(chans,blinkTimes)');            end            autoBlinks=autoBlinks-chanMeans(chans)';                        corrs = corrcoef([autoBlinks(EEGchansNoHEOG)' emcpBlinks(EEGchansNoHEOG)]); %not including HEOG since too variable            msg=['The correlation between the EMCP blink topography and the automatic blink template (not used for EMCP and provided for comparison''s sake) was: ' num2str(abs(corrs(2,1)))];            disp(msg);            outputLog{end+1}=msg;        else        msg='No blinks auto-detected to form the blink template.';        disp(msg);        outputLog{end+1}=msg;        autoBlinks=zeros(1,length(chans));            blinkfacs=[];            corrs=[];        end        blinkAutoTemplate{iChunk}(:,1)=autoBlinks;    end        if strcmp(templateSource,'fileTemplate')        corrs = corrcoef([blinkManualTemplate(EEGchansNoHEOG)' emcpBlinks(EEGchansNoHEOG)]); %not including HEOG since too variable        msg=['The correlation between the EMCP blink topography and the manual blink template (not used for EMCP and provided for comparison''s sake) was: ' num2str(abs(corrs(2,1)))];        disp(msg);        outputLog{end+1}=msg;        autoBlinks=[];    end        if strcmp(templateSource,'bothTemplate')        corrs = corrcoef([blinkManualTemplate(EEGchansNoHEOG)' emcpBlinks(EEGchansNoHEOG)]); %not including HEOG since too variable        msg=['The correlation between the EMCP blink topography and the manual blink template (not used for EMCP and provided for comparison''s sake) was: ' num2str(abs(corrs(2,1)))];        disp(msg);        outputLog{end+1}=msg;    end            if any(any(any(subtractedBlinks))) %if any blink artifacts were subtracted        count=0;        blinkWindow=blinkwindowMS/round(1000/dataChunk.Fs); %blink peaks within a 100 ms treated as a single blink                dataSize=size(dataChunk.data,2);                boundaryPoints=[];        for iTrial=1:size(dataChunk.data,3)            if ~isempty(dataChunk.events{iTrial})                boundaryPoints=[boundaryPoints; [dataChunk.events{iTrial}(find(strcmp('boundary',{dataChunk.events{iTrial}.type}))).sample]'+(iTrial-1)*dataSize];            end            if iTrial > 1                boundaryPoints=[boundaryPoints; (iTrial-1)*dataSize+1];            end        end                blinkLengthMin=blinkLengthMinMS/round(1000/dataChunk.Fs);        filterWidth=filterWidthMS/round(1000/dataChunk.Fs);                if strcmp(dataChunk.dataType,'continuous')                        %check to see if procedure made data noisier            numTrials=floor(size(dataChunk.data,2)/ceil(dataChunk.Fs)); %excess time points are tacked onto final epoch            trialSize = min(ceil(dataChunk.Fs),size(dataChunk.data,2)); %one second epochs                        for iTrial = 1:numTrials                if iTrial == numTrials                    epochPointsGP=find(goodPoints>((iTrial-1)*trialSize));                else                    epochPointsGP=find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize)));                end                epochPoints=goodPoints(epochPointsGP);                                if sum(var(trialdata(chans,epochPoints))) < sum(var(trialdata(chans,epochPoints)-blinkdata(chans,epochPointsGP)))                    noisier=noisier+1;                end            end                        %blinkPeaks, blinkStarts, and blinkEnds in goodPoints space, blinkEOG and boundaryPoints are in regular point space            blinkPeaks=min(find(blinkEOG(goodPoints) >= blinkThreshold)); %find first blink point            if ~isempty(blinkPeaks)                blinkStarts=max(find(blinkEOG(goodPoints(1:blinkPeaks(1))) < (blinkEdgeThreshold))); %the last officially non-blink point prior to the peak                if isempty(blinkStarts) || any(ismember(boundaryPoints,[goodPoints(blinkStarts(1))+1:goodPoints(blinkPeaks(1))]))                    blinkStarts=0;                end                blinkEnds=min(find(blinkEOG(goodPoints(blinkPeaks(1):end)) < (blinkEdgeThreshold)))+blinkPeaks(1)-1; %the first officialy non-blink point after the peak                if isempty(blinkEnds) || any(ismember(boundaryPoints,[goodPoints(blinkPeaks(1))+1:goodPoints(blinkEnds)]))                    blinkEnds=0;                end                if blinkPeaks(1) < length(goodPoints)                    for iPoint=blinkPeaks(1)+1:length(goodPoints)                        theAmp=blinkEOG(goodPoints(iPoint));                        if theAmp >= blinkThreshold                            if ((goodPoints(iPoint)-goodPoints(blinkPeaks(end))) > blinkWindow) || any(ismember(boundaryPoints,[goodPoints(blinkPeaks(end))+1:goodPoints(iPoint)]))                                blinkPeaks=[blinkPeaks;iPoint]; %new blink peak                                if iPoint < blinkEnds(end)                                    blinkEnds(end)=0;                                end                                theStart=max(find(blinkEOG(goodPoints(1:iPoint)) < (blinkEdgeThreshold))); %good points space                                if isempty(theStart)                                    blinkStarts(end+1,1)=0;                                    firstBlinkSamp=1;                                elseif theStart < max(blinkEnds)                                    blinkStarts(end+1,1)=0;                                    firstBlinkSamp=max(blinkEnds);                                elseif theStart < max(blinkPeaks(1:end-1))                                    blinkStarts(end+1,1)=0;                                    firstBlinkSamp=max(blinkPeaks(1:end-1))+1;                                elseif any(ismember(boundaryPoints,[goodPoints(theStart)+1:goodPoints(iPoint)]))                                    blinkStarts(end+1,1)=0;                                    firstBlinkSamp=find(goodPoints==max(boundaryPoints(ismember(boundaryPoints,[goodPoints(theStart)+1:goodPoints(iPoint)])))); %good points space                                else                                    blinkStarts(end+1,1)=theStart;                                    firstBlinkSamp=theStart;                                end                                theEnd=min(find(blinkEOG(goodPoints(iPoint:end)) < (blinkEdgeThreshold))); %good points space                                if isempty(theEnd)                                    blinkEnds(end+1,1)=0;                                    lastBlinkSamp=length(goodPoints);                                elseif any(ismember(boundaryPoints,[goodPoints(iPoint)+1:goodPoints(theEnd)]))                                    blinkEnds(end+1,1)=0;                                    lastBlinkSamp=find(goodPoints==max(boundaryPoints(ismember(boundaryPoints,[goodPoints(iPoint)+1:goodPoints(theEnd)]))));                                else                                    blinkEnds(end+1,1)=theEnd+iPoint-1;                                    lastBlinkSamp=theEnd;                                end                                trialdata(ETchans,goodPoints(firstBlinkSamp:lastBlinkSamp))=NaN; %NaN out eye-tracker data during blinks                                if ~isempty(dataChunk.events{1})                                    theValues={dataChunk.events{1}.value};                                    valList=[];                                    for iValue=1:length(theValues)                                        if any(strcmp(theValues{iValue},{'saccadeET','fixationET'}))                                            valList(end+1)=iValue;                                        end                                    end                                    ETevents=find(ismember([dataChunk.events{1}(valList').sample],[firstBlinkSamp:lastBlinkSamp]));                                    if ~isempty(ETevents)                                        dataChunk.events{1}(ETevents)=[]; %drop ET                                    end                                end                            else                                if theAmp > blinkEOG(1,goodPoints(blinkPeaks(end)))                                    blinkPeaks(end)=iPoint; %update current blink peak                                end                            end                        end                    end                end                                for iBlink=1:length(blinkPeaks)                    count=count+1;                                        if blinkStarts(iBlink) > 0                        dataChunk.events{theSubject,1}(end+1).sample=goodPoints(blinkStarts(iBlink));                        dataChunk.events{theSubject,1}(end).type='artifact';                        dataChunk.events{theSubject,1}(end).value='blink_start';                        dataChunk.events{theSubject,1}(end).duration=0;                        dataChunk.events{theSubject,1}(end).keys.code='blnk';                        dataChunk.events{theSubject,1}(end).keys.data=num2str(count);                        dataChunk.events{theSubject,1}(end).keys.datatype='text';                        dataChunk.events{theSubject,1}(end).keys.description='';                    end                                        dataChunk.events{theSubject,1}(end+1).sample=goodPoints(blinkPeaks(iBlink));                    dataChunk.events{theSubject,1}(end).type='artifact';                    dataChunk.events{theSubject,1}(end).value='blink_peak';                    dataChunk.events{theSubject,1}(end).duration=0;                    dataChunk.events{theSubject,1}(end).keys.code='blnk';                    dataChunk.events{theSubject,1}(end).keys.data=num2str(count);                    dataChunk.events{theSubject,1}(end).keys.datatype='text';                    dataChunk.events{theSubject,1}(end).keys.description='';                                        if blinkEnds(iBlink) > 0                        dataChunk.events{theSubject,1}(end+1).sample=goodPoints(blinkEnds(iBlink));                        dataChunk.events{theSubject,1}(end).type='artifact';                        dataChunk.events{theSubject,1}(end).value='blink_end';                        dataChunk.events{theSubject,1}(end).duration=0;                        dataChunk.events{theSubject,1}(end).keys.code='blnk';                        dataChunk.events{theSubject,1}(end).keys.data=num2str(count);                        dataChunk.events{theSubject,1}(end).keys.datatype='text';                        dataChunk.events{theSubject,1}(end).keys.description='';                    end                                        theTrial=min(ceil(goodPoints(blinkPeaks(iBlink))/trialSize),size(blinkTrialNum,2));                    blinkTrialNum{iChunk}(theSubject,theTrial)=1; %mark this epoch as having at least one blink                                        startPoint=blinkStarts(iBlink);                    if startPoint==0                        if iBlink==1                            epochStart=goodPoints(1);                        else                            epochStart=goodPoints(blinkPeaks(iBlink-1));                        end                    else                        epochStart=goodPoints(startPoint);                    end                    boundPoints=intersect(boundaryPoints,[epochStart+1:goodPoints(blinkPeaks(iBlink))]);                    if ~isempty(boundPoints)                        epochStart=max(boundPoints);                    end                                        endPoint=blinkEnds(iBlink);                    if endPoint==0                        if iBlink==length(blinkPeaks)                            epochEnd=goodPoints(end);                        else                            epochEnd=goodPoints(blinkPeaks(iBlink+1));                        end                    else                        epochEnd=goodPoints(endPoint);                    end                    boundPoints=intersect(boundaryPoints,[goodPoints(blinkPeaks(iBlink))+1:epochEnd]);                    if ~isempty(boundPoints)                        epochEnd=min(boundPoints);                    end                                        blinkPoints{iChunk-startChunk+1}=[blinkPoints{iChunk-startChunk+1}; [epochStart+1:epochEnd-1]'];                end                blinkPoints{iChunk-startChunk+1}=unique(blinkPoints{iChunk-startChunk+1});            end        else            %not continuous data            for iTrial = 1:numTrials                ep_tictoc;if EPtictoc.stop;return;end                epochPointsGP=find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))); %epoch's points in goodPoints space                epochPoints=goodPoints(epochPointsGP); %epoch's points in full points space                                %check to see if procedure made data noisier                if sum(var(trialdata(chans,epochPoints))) < sum(var(trialdata(chans,epochPoints)-blinkdata(chans,epochPoints)))                    noisier=noisier+1;                end                if ~isempty(epochPoints)                    %blinkPeaks, blinkStarts, and blinkEnds, blinkEOG is in regular point space                    trialBlinkEOG=blinkEOG(1,epochPoints);                    trialBlinkEOG=detrend(trialBlinkEOG);                    trialBlinkEOG=trialBlinkEOG-median(trialBlinkEOG);                    blinkPeaks=min(find( trialBlinkEOG >= blinkThreshold)); %find first blink point                    if ~isempty(blinkPeaks)                        trialBlinkEOGgrad=gradient(filter((1/filterWidth)*ones(1,filterWidth),1,[repmat(trialBlinkEOG(1),1,filterWidth) trialBlinkEOG repmat(trialBlinkEOG(end),1,filterWidth)]));                        trialBlinkEOGgrad=trialBlinkEOGgrad(filterWidth+1:end-filterWidth); %remove padding that was added to avoid edge artifacts being aggravated by zero-padding during filtering                        blinkStarts=max(find(trialBlinkEOGgrad(1:blinkPeaks-blinkLengthMin)<0));%                         blinkStarts=max(find(trialBlinkEOG(1:blinkPeaks(1)) < (blinkEdgeThreshold)));                        if isempty(blinkStarts) || any(ismember(boundaryPoints,[epochPoints(blinkStarts(1))+1:epochPoints(blinkPeaks(1))]))                            blinkStarts=0;                        end                        blinkEnds=min(find(trialBlinkEOGgrad(blinkPeaks+blinkLengthMin:end)>0))+blinkPeaks(1)+blinkLengthMin-1;%                         blinkEnds=min(find(trialBlinkEOG(blinkPeaks(1):end) < (blinkEdgeThreshold)))+blinkPeaks(1)-1;                        if isempty(blinkEnds) || any(ismember(boundaryPoints,[epochPoints(blinkPeaks(1))+1:epochPoints(blinkEnds)]))                            blinkEnds=0;                        end                        if blinkPeaks(1) < length(epochPoints)                            for iPoint=blinkPeaks(1)+1:length(epochPoints)                                theAmp=trialBlinkEOG(1,iPoint);                                if theAmp >= blinkThreshold                                    if (epochPoints(iPoint)-epochPoints(blinkPeaks(end))) > blinkWindow || any(ismember(boundaryPoints,[epochPoints(blinkPeaks(end))+1:epochPoints(iPoint)]))                                        blinkPeaks=[blinkPeaks;iPoint]; %new blink peak                                        if iPoint < blinkEnds(end)                                            blinkEnds(end)=0;                                        end                                        theStart=max(find(trialBlinkEOGgrad(1:iPoint-1)<0));%                                         theStart=max(find(trialBlinkEOG(1:iPoint) < (blinkEdgeThreshold)));                                        if isempty(theStart)                                            blinkStarts(end+1,1)=0;                                            firstBlinkSamp=1;                                        elseif theStart < max(blinkEnds)                                            blinkStarts(end+1,1)=0;                                            firstBlinkSamp=max(blinkEnds);                                        elseif theStart < max(blinkPeaks(1:end-1))                                            blinkStarts(end+1,1)=0;                                            firstBlinkSamp=max(blinkPeaks(1:end-1))+1;                                        elseif any(ismember(boundaryPoints,[epochPoints(theStart)+1:epochPoints(iPoint)]))                                            blinkStarts(end+1,1)=0;                                            firstBlinkSamp=max(boundaryPoints(ismember(boundaryPoints,[epochPoints(theStart)+1:epochPoints(iPoint)])));                                        else                                            blinkStarts(end+1,1)=theStart;                                            firstBlinkSamp=theStart;                                        end%                                         theEnd=iPoint-1+min(find(trialBlinkEOG(iPoint:end) < (blinkEdgeThreshold)));                                        theEnd=min(find(trialBlinkEOGgrad(iPoint+1:end)>0))+iPoint-1;                                        if isempty(theEnd)                                            blinkEnds(end+1,1)=0;                                            lastBlinkSamp=length(epochPoints);                                        elseif any(ismember(boundaryPoints,[epochPoints(iPoint)+1:epochPoints(theEnd)]))                                            blinkEnds(end+1,1)=0;                                            lastBlinkSamp=max(find(ismember([epochPoints(iPoint)+1:epochPoints(theEnd)],boundaryPoints)));                                        else                                            blinkEnds(end+1,1)=theEnd;                                            lastBlinkSamp=theEnd;                                        end                                        trialdata(ETchans,epochPoints(firstBlinkSamp:lastBlinkSamp))=NaN; %NaN out eye-tracker data during blinks                                        if ~isempty(dataChunk.events{theSubject,iTrial})                                            theValues={dataChunk.events{theSubject,iTrial}.value};                                            valList=[];                                            for iValue=1:length(theValues)                                                if any(strcmp(theValues{iValue},{'saccadeET','fixationET'}))                                                    valList(end+1)=iValue;                                                end                                            end                                            ETevents=find(ismember([dataChunk.events{theSubject,iTrial}(valList').sample],[firstBlinkSamp:lastBlinkSamp]));                                            if ~isempty(ETevents)                                                dataChunk.events{theSubject,iTrial}(ETevents)=[]; %drop ET                                            end                                        end                                    else                                        if theAmp > trialBlinkEOG(1,blinkPeaks(end))                                            blinkPeaks(end)=iPoint; %update current blink peak                                            theEnd=min(find(trialBlinkEOGgrad(blinkPeaks(end)+blinkLengthMin:end)>0))+blinkPeaks(end)+blinkLengthMin-1;                                            %                         blinkEnds=min(find(trialBlinkEOG(blinkPeaks(1):end) < (blinkEdgeThreshold)))+blinkPeaks(1)-1;                                            if isempty(theEnd) || any(ismember(boundaryPoints,[epochPoints(blinkPeaks(end))+1:epochPoints(theEnd)]))                                                theEnd=0;                                            end                                            blinkEnds(end)=theEnd;                                        end                                    end                                end                            end                        end                    end                    for iBlink=1:length(blinkPeaks)                        count=count+1;                                                if blinkStarts(iBlink) > 0                            dataChunk.events{theSubject,iTrial}(end+1).sample=goodPoints(epochPointsGP(blinkStarts(iBlink)))-((iTrial-1)*trialSize);                            dataChunk.events{theSubject,iTrial}(end).type='artifact';                            dataChunk.events{theSubject,iTrial}(end).value='blink_start';                            dataChunk.events{theSubject,iTrial}(end).duration=0;                            dataChunk.events{theSubject,iTrial}(end).keys.code='blnk';                            dataChunk.events{theSubject,iTrial}(end).keys.data=num2str(count);                            dataChunk.events{theSubject,iTrial}(end).keys.datatype='text';                            dataChunk.events{theSubject,iTrial}(end).keys.description='';                        end                                                dataChunk.events{theSubject,iTrial}(end+1).sample=goodPoints(epochPointsGP(blinkPeaks(iBlink)))-((iTrial-1)*trialSize);                        dataChunk.events{theSubject,iTrial}(end).type='artifact';                        dataChunk.events{theSubject,iTrial}(end).value='blink';                        dataChunk.events{theSubject,iTrial}(end).duration=0;                        dataChunk.events{theSubject,iTrial}(end).keys.code='blnk';                        dataChunk.events{theSubject,iTrial}(end).keys.data=num2str(count);                        dataChunk.events{theSubject,iTrial}(end).keys.datatype='text';                        dataChunk.events{theSubject,iTrial}(end).keys.description='';                                                if blinkEnds(iBlink) > 0                            dataChunk.events{theSubject,iTrial}(end+1).sample=goodPoints(epochPointsGP(blinkEnds(iBlink)))-((iTrial-1)*trialSize);                            dataChunk.events{theSubject,iTrial}(end).type='artifact';                            dataChunk.events{theSubject,iTrial}(end).value='blink_end';                            dataChunk.events{theSubject,iTrial}(end).duration=0;                            dataChunk.events{theSubject,iTrial}(end).keys.code='blnk';                            dataChunk.events{theSubject,iTrial}(end).keys.data=num2str(count);                            dataChunk.events{theSubject,iTrial}(end).keys.datatype='text';                            dataChunk.events{theSubject,iTrial}(end).keys.description='';                        end                                                blinkTrialNum{iChunk}(theSubject,iTrial)=1; %mark this epoch as having at least one blink                        startPoint=blinkStarts(iBlink);                        if startPoint==0                            if iBlink==1                                epochStart=epochPoints(1);                            else                                epochStart=epochPoints(blinkPeaks(iBlink-1));                            end                        else                            epochStart=epochPoints(startPoint);                        end                        boundPoints=intersect(boundaryPoints,[epochStart+1:epochPoints(blinkPeaks(iBlink))]);                        if ~isempty(boundPoints)                            epochStart=max(boundPoints);                        end                                                endPoint=blinkEnds(iBlink);                        if endPoint==0                            if iBlink==length(blinkPeaks)                                epochEnd=epochPoints(end);                            else                                epochEnd=epochPoints(blinkPeaks(iBlink+1));                            end                        else                            epochEnd=epochPoints(endPoint);                        end                        boundPoints=intersect(boundaryPoints,[epochPoints(blinkPeaks(iBlink))+1:epochEnd]);                        if ~isempty(boundPoints)                            epochEnd=min(boundPoints);                        end                                                blinkPoints{iChunk-startChunk+1}=[blinkPoints{iChunk-startChunk+1}; [epochStart+1:epochEnd-1]'];                    end                end            end            blinkPoints{iChunk-startChunk+1}=unique(blinkPoints{iChunk-startChunk+1});        end                %even if no discernible blink peaks, there can still be blink-related activity like blink recovery artifact        corData=zeros(size(trialData));        corData(chans,:) = reshape(corRawData,numGoodChans,[]); %flatten to two-dimensional array.                if count == 0            msg=['No blink peaks detected but blink-related activity corrected.'];        elseif count == 1            msg=['One blink corrected.'];        else            msg=[num2str(count) ' blinks corrected.'];        end        disp(msg);        outputLog{end+1}=msg;                if ~isempty(butterflyFig)            figure(butterflyFig{iChunk});            theTitle='subtracted blinks';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,reshape(subtractedBlinks,numChans,[]),chans,theSubject);            subplot(numGraphs,1,graphCounter-4), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        theTitle='with blinks subtracted';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,corData+reshape(subtractedSaccades,numChans,[]),chans,theSubject);            subplot(numGraphs,1,graphCounter-3), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end    else        msg='EMCP did not perform any blink correction.';        disp(msg);        outputLog{end+1}=msg;                if ~isempty(butterflyFig)            figure(butterflyFig{iChunk});            if numSubs > 1                theTitle='subtracted blinks';            else                theTitle='no blinks to subtract that were detected';            end            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,zeros(size(trialData)),chans,theSubject);            subplot(numGraphs,1,graphCounter-4), plot([1:decimateSamples:totalDisplayPeriod],plotData);            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title(theTitle,'Interpreter','none');                        if numSubs > 1                theTitle='with blinks subtracted';            else                theTitle='no blinks subtracted';            end            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialData,chans,theSubject);            subplot(numGraphs,1,graphCounter-3), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end    end        if any(any(any(subtractedSaccades)))        corData=zeros(size(trialData));        corData(chans,:) = reshape(corRawData,numGoodChans,[]); %flatten to two-dimensional array.                if ~isempty(butterflyFig)            figure(butterflyFig{iChunk});            theTitle='subtracted saccades';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,reshape(subtractedSaccades,numChans,[]),chans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        theTitle='with saccades subtracted';            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,corData,chans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end    else        msg='EMCP did not perform any saccade correction.';        disp(msg);        outputLog{end+1}=msg;                if ~isempty(butterflyFig)            figure(butterflyFig{iChunk});            if numSubs > 1                theTitle='subtracted saccades';            else                theTitle='no saccades to subtract that were detected';            end            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,zeros(size(trialData)),chans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title(theTitle,'Interpreter','none');                        if numSubs > 1                theTitle='with saccades subtracted';            else                theTitle='no saccades subtracted';            end            plotData=ep_makePlotData(butterflyFig{iChunk},displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialData,chans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end    end        drawnow        trialData(chans,:)=reshape(corRawData,numGoodChans,[]);        if ~isempty(baseline)			%baseline again in case there were blinks in the baseline period.        for iTrial = 1:numTrials            epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            base=(iTrial-1)*trialSize+baseline;            goodBase=goodPoints(find(ismember(base,goodPoints)));            if ~isempty(epoch) && ~isempty(goodBase)                baseMeans = mean(trialData(EEGchans,goodBase),2);                trialData(EEGchans,epoch)=trialData(EEGchans,epoch)-diag(baseMeans)*ones(length(EEGchans),length(epoch));            end        end    end        if length(refChan) == 2        trialData(refChan(2),:)=-trialData(refChan(1),:);     %put second reference channel back in.    end        %rereference the data.    if ~isempty(refChan)        for iTrial = 1:numTrials            epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            if ~isempty(epoch)                referenceData=mean(trialData(refChan,epoch),1);                for iChan=1:length(EEGchans)                    theChan=EEGchans(iChan);                    trialData(theChan,epoch)=trialData(theChan,epoch)-referenceData;                end            end        end    end        dataChunk.data(:,:,:,theSubject)=reshape(trialData,size(dataChunk.data(:,:,:,theSubject)));    dataChunk.analysis.blinkTrial(theSubject,:)=blinkTrialNum{iChunk}(theSubject,:);        blinkChan=find(strcmp('blink',dataChunk.chanNames));    if isempty(blinkChan)        EPadd.chanNames{1}='blink';        EPadd.chanTypes{1}='REG';        EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));        EPadd.data(:,:,:,theSubject)=reshape(blinkEOG,size(dataChunk.data(1,:,:,1)));        if isfield(dataChunk,'interpChans')            interpChans=dataChunk.interpChans;            dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            dataChunk.interpChans=interpChans;        else            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');        end    else        dataChunk.data(blinkChan,:,:,theSubject)=reshape(blinkEOG,size(dataChunk.data(1,:,:,1)));    end        saccChan=find(strcmp('saccade',dataChunk.chanNames));    if isempty(saccChan)        EPadd.chanNames{1}='saccade';        EPadd.chanTypes{1}='REG';        EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));        EPadd.data(:,:,:,theSubject)=reshape(saccEOG,size(dataChunk.data(1,:,:,1)));        if isfield(dataChunk,'interpChans')            interpChans=dataChunk.interpChans;            dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            dataChunk.interpChans=interpChans;        else            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');        end    else        dataChunk.data(saccChan,:,:,theSubject)=reshape(saccEOG,size(dataChunk.data(1,:,:,1)));    end        if isempty(dataChunk)        disp('Warning: No file saved due to program error.');    end    if exist('EPchunk','var') && ~isempty(EPchunk)        if exist('EPchunkSP','var') && ~isempty(EPchunkSP)            EPchunkSP{iChunk}=dataChunk;        else            EPchunk{iChunk}=dataChunk;        end    else        ep_tictoc('ioStart');        eval (['save ''' outFile '-' num2str(iChunk) '.mat'' dataChunk']);        ep_tictoc('ioFinish');    end        if standAlone        try            MATLABver=ver('MATLAB');            [a b]=strtok(MATLABver.Version,'.');            b=b(2:end);            if ~isprop(butterflyFig,'Number')                eval (['print -f' num2str(butterflyFig{iChunk}) ' -djpeg ''' inFile '-' num2str(iChunk) 'EOG.jpg''']);            else                eval (['print -f' num2str(butterflyFig{iChunk}.Number) ' -djpeg ''' inFile '-' num2str(iChunk) 'EOG.jpg''']);            end        catch            disp('Couldn''t save a copy of the artifact correction figure.  Perhaps your version of Matlab is not current.');        end    end    priorPoints=priorPoints+size(trialData,2);    blinkTopo=mean(subtractedBlinks(EEGchans,:),2);    subtractedBlinksTopo=subtractedBlinksTopo+blinkTopo;    if saccadeFileCorrect        corrs = corrcoef([hSaccManualTemplate(chans) blinkTopo]);        msg=['The horizontal saccade regression correlation was: ' num2str(max(abs(corrs(2:end,1))))];        disp(msg);        outputLog{end+1}=msg;    end    sacTopo=mean(subtractedSaccades(EEGchans,:),2);    subtractedHsacTopo=subtractedHsacTopo+sacTopo;    if saccadeFileCorrect        corrs = corrcoef([hSaccManualTemplate(chans) sacTopo]);        msg=['The blink regression correlation was: ' num2str(max(abs(corrs(2:end,1))))];        disp(msg);        outputLog{end+1}=msg;    endend% if noisier == 1%     msg=['1 ' theSegment ' was noisier after correction.'];% else%     msg=[num2str(noisier) ' ' theSegment 's were noisier after correction.'];% end% disp(msg);% outputLog{end+1}=msg;totblinkTrialNum=[];for iChunk = startChunk:endChunk    totblinkTrialNum=[totblinkTrialNum blinkTrialNum{iChunk}];endtemplates.blinks.auto=zeros(length(EEGchans),1);if any(strcmp(templateSource,{'autoTemplate','bothTemplate','eyeTracker'}))    totalAutoTemplate=zeros(size(blinkAutoTemplate{1}));    for iChunk = startChunk:endChunk        totalAutoTemplate=totalAutoTemplate+blinkAutoTemplate{iChunk};    end    totalAutoTemplate=totalAutoTemplate/(endChunk-startChunk+1);    templates.blinks.auto(chans,1)=totalAutoTemplate;else    templates.blinks.auto=[];endtemplates.blinks.manual=zeros(length(EEGchans),1);if any(strcmp(templateSource, {'fileTemplate','bothTemplate'}))    templates.blinks.manual=blinkManualTemplate;else    templates.blinks.manual=[];endtemplates.blinks.blinkTopo=subtractedBlinksTopo;templates.blinks.auto=[];templates.blinks.manual=[];templates.hSaccades.hSaccadesTopo=subtractedHsacTopo(EEGchans,:);templates.hSaccades.auto=[];templates.hSaccades.manual=[];