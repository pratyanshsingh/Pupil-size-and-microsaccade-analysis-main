function ep_artifactCorrection(varargin)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ep_artifactCorrection(varargin);% Handles the process of splitting up parts of the files, doing the correction, and then rejoining them.%%	Reads in file chunks generated by readEGISses function (should be set at a size small%	enough to fit in memory.  100,000 samples of 128chan data can be processed with ICA in a 1GB.%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.  It will need a channel%	coordinates file in the EEGlab .ced format.  It will assume that the%	first three entries are fiducials and drop them.  It will assume that%	the next set of entries are the electrodes and will ignore any extras%	at the end.  It will also assume that all the files in a given batch have the same electrode montage.%%Keywords - all optional (defaults in parentheses)%   files: followed by cell array of file names to correct.  Assumes active directory if path not specified.  (default: will ask for files)%   inputFormat: followed by input file format.%   outputFormat: followed by output file format.%   baseline: followed by array of sample numbers to permanently baseline correct the trials with.  [] means don't correct. (default: [])%   timePoints:     followed by array of sample numbers to retain.  [] means don't drop any timepoints. (default: [])%   template: followed by source of blink template (fileTemplate: load blink format file.  autoTemplate: automatically generate blink template.%               bothTemplate: use both file and automatic template at the same time) (default: autotemplate)%   saccTemplate: followed by source of saccade template (fileTemplate: load saccade format file.(default: fileTemplate)%   blinkFile: path and name of the blink file if using the FileTemplate or bothTemplate options.%   saccadeFile: path and name of the saccade file if using the FileTemplate option.%   SPfile: path and name of the SP file if using the FileTemplate option.%   blinkMethod: Method used for blink correction.  The names of the ICA rotations.%   saccMethod: Method used for saccadic CRD correction.  The names of the ICA rotations or 'regression'.%   SPmethod: Method used for spike potential correction.  The names of the ICA rotations or 'vector'.%   eogMethod: Overall method for eye artifact correction ('ICA', 'MAAC', 'EMCP').%   badChans: followed by cell array of bad channels to exclude from blink detection process (default: [])%   saturation: followed by range of acceptable data values (default: -1000 to +1000)%   eog: followed by structured array with EOG channels (LUVEOG, RUVEOG, LLVEOG, RLVEOG, LHEOG, RHEOG)%               (must be provided by either eog keyword or by auto-detection of montage from original file.)%   window:    moving average window for smoothing during bad channel detection only (default: 80 ms)%   minmax:    difference from minimum to maximum for bad channel (default: 100 µv)%   badnum:    percent of bad channels exceeded to declare bad trial, rounding down (default: 10)%   neighbors: number of electrodes considered to be neighbors (default: 6)%   maxneighbor:   maximum microvolt difference allowed from best matching neighbor (default: 30 µv)%   badchan:   minimum predictability from neighbors to not be considered globally bad (default: .4)%   blink:     threshold correlation with blink template, 0 to 1 (default: .9)%   saccade:     threshold correlation with saccade template, 0 to 1 (default: .8)%   saccademin:  µv Saccade Fac is the minimum HEOG voltage difference required to constitute a possible saccade. (default: 20)%   sacpot:  µv saccade potential amplitude to trigger detection. (default: 100)%   trialminmax:  difference from minimum to maximum for bad trial (default: 100 µv)%   detrend:   1 to detrend (0).  Not recommended for ERP data as can attenuate ERP components.  Can be useful for continuous data or spectral data in general.%              Credit to Hyunseok Kook.%   fMRI:   1 to perform gradient and ballistocardiogram artifact corrections (0).%   badtrials: percentage of good trials chan is bad to declare a channel globally bad (default: 20)%   channelMode:   'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing. (default: replace)%   trialMode:   'fix' to fix bad trial data and 'none' to do nothing. (default: fix)%   noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad) (default: 1)%   chunkSize: Number of timepoints to read in.  Roughly 100000 per GB of memory available. (default: 100,000)%   minTrialsPerCell: Minimum number of good trials per cell to avoid warning message. (default: 15)%   movefacs  : number of factors to retain during movement correction.%   noFigure  : 1 to disable summary figures of artifact detection (to help cope with low memory situations).%   editMode  : How to identify artifacts (automatic: use automatic criteria and enter marks into file; manual: use%               existing marks in file; both: use existing marks in file and add additional ones based on automatic criteria)%               (default: both)%%Outputs%	Saves files with blinks removed.  Uses original name with "_e" appended to the stem.%   If baseline option is used (provides better results, particularly when%   there are large DC swings in the recordings), then the output will be%   baselined.%   finalLog: output messages from blink process%% History:%% by Joseph Dien (2/17/08)% jdien07@mac.com%%% modified 11/20/08 JD% Changed to keyword approach.  Made baseline specification more flexible.% Changed to use FieldTrip I/O in order to be able to read more formats.%% modified and bugfix 2/11/09 JD% Changed to allow selection of multiple files from selector.  Problematic% files do not stop entire batch.  More information added to log file.  Bad% channel and trial detection implemented.  Blinkfile template option crash fixed.% Fixed crash when selecting a single file with the file requestor.%% modified 3/25/09 JD% Changed to use readData and writeData functions to provide more flexibility with I/O functions.% Now relies on readData to obtain the .ced file name.%% modified 4/17/09 JD% eloc and ced now handled by readData.%% modified 7/14/09 JD% Added none option to blink template.  Changed 'replace' keyword to 'channelMode'.  Added 'trialMode'.% Single summary figure for full artifact correction procedure.  Changing name of function to% artifactCorrection from blinkCorrecction.  Doesn't require two vertical EOG channels% if using file template.  Uses updated blink template format.%% bugfix 8/27/09 JD% Location of windows appearing partly off screen on some systems.  Fixed.%% bugfix & modified 8/30/09 JD% Was setting all data formats to EGIS.  Added support for continuous data.%% bugfix & modified 9/16/09 JD% Added refChan input to deal with mean mastoid data where the presence of the two reference channels (correlated -1)% was causing ICA problems.% Slashes in log file being interpreted as control characters.% Trialwise bad channel detection deactivated for continuous data.%% bugfix 9/23/09 JD% When input files were split into multiple chunks, only the final one's progress window was being closed.% In batch runs the windows would accumulate and eventually result in a memory error.%% bugfix 10/17/09 JD% Continuous data crashed artifact correction.%% modified 10/28/09 JD% Added option to disable preprocessing figure for low memory situations.%% bugfix 10/31/09 JD% When there are multiple chunks, only saving the figure for the final one.%% bugfix 12/5/09 JD% Avoid performing trialwise bad channel detection entirely unless both minmax and maxneighbor parameters are inactive.% Fixed crash when more than one bad channel.% Now assumes montages are all the same, not just the channel coordinates.%% modified & bugfix 2/24/10 JD% No longer treating shorted channels as being bad channels as this was proving too conservative a criterion.  Instead% it now just provides a warning message.% Will now work with subject average files with multiple subjects.% Turning off bad channel preferences affects only the relevant bad channel criteria rather than turning off all bad% channel detection.% Now uses file's reference settings if not specified in the Preprocess pane.% Added log to bad channel detection function output.%% modified 6/15/10 JD% Added name of first session file to the name of the log file if just one or the number of files if more.%% modified 8/31/10 JD% Added message about time taken for artifact run.%%  modified 10/28/10 JD%  Added support for HEOG saccade correction.%%  modified 1/18/11 JD%  Added support for selecting timepoints.%%  modified 1/20/11 JD%  Added support for manually specifying EOG channels in the preferences.%%  modified 2/10/11 JD%  Finished taking out hmin saccade code.%% modified 1/27/12 JD% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.%% modified 1/28/13 JD% Added options for using manual edit marks instead of or in addition to automatic marking for bad channel and trials.% If baseline correction chosen, will occur even if blink correction not performed and it will be applied prior to bad% channel and trial detection.  Detrending now performed prior to bad channel and trial correction but before baseline% correction.%% bugfix 5/9/13 JD% Fixed crash when using Points option with continuous data.%% bugfix 5/13/13 JD% Fixed automatic global bad channel detection being performed even when editMode set to Manual.%% modified 9/24/13 JD% Restricted blink correction to EEG channels.%% bugfix 9/26/13 JD% Fixed not finding files past the first when batched and they are not in the active directory.%%  modified 11/15/13 JD%  Added fMRI artifact correction option to Preprocess data function using fMRIb EEGlab plugin.%%  modified 11/23/13 JD%  Does not write over existing files.%% bugfix 11/25/13 JD% Fixed crashes when there are multiple bad channels.%%  modified 11/27/13 JD%  Added fMRI artifact correction option to Preprocess data function using AMRI EEG fMRI Toolbox.%%  bugfix 1/12/14 JD%  Workaround for Matlab bug periodically causing screen size to register as having zero size.%% modified 3/18/14 JD% Changed uses of "temp" as a variable name to "tempVar" due to other Matlab programmers often using it as a function% name, resulting in collisions.%% modified 6/2/14 JD% Movement correction function call now includes current reference channel info.%% modified 6/3/14 JD% Added support for SMI eye tracking files.% If current reference not specified, default to original reference.%% bugfix 6/12/14 JD% Fixed blank keys field of events being produced without .key (e.g., .keys.keyCod instead of .keys.key.keyCode)%% modified 7/16/14 JD% Simplified keys code field structure.%% bugfix 8/27/14 JD% Fixed crash for files where event values are all numbers rather than% strings.%% modified 8/29/14 JD% Moved SMI file support to the readData function.%% modified 8/31/14 JD% Added support for adding additional keys information to events in continuous data and trial specs in single-trial% data.%%  modified 5/25/14 JD%  Set colormap to jet even for Matlab 2014b onwards.%% bugfix 8/14/15 JD% Fixed unable to save artifact correction summary figure starting with% Matlab 2014b.%% modified 12/18/15 JD% Preprocessing function allows EEG files with different numbers of non-EEG channels to be batched together.%% modified 2/16/16 JD% Artifact figure files no longer overwrite prior such files with same name.%% modified 9/16/16 JD% Added automatic detection and correction of saccade potentials.% Added template summary figure to saved files.% Implemented improved saccade correction routines, dropping blink points from saccade potential and saccade corrections.%% modified 11/5/16 JD% Added support for writing out subject spec text files.%% modified 1/3/17 JD% Added eyeTracker option to blink and saccade correction routines.%% modified 2/5/17 JD% Added Subtracted topography to template jpeg output.%% modified 4/18/17 JD% Excludes time points beyond a certain range from global bad channel detection, blink, and saccade routines.%% modified 10/3/17 JD% Interpolates bad EOG channels instead of aborting artifact correction when too many are bad.%% bugfix 10/11/17 JD% Fixed crashes due to Matlab changing their graphics objects AGAIN in 2017b.%% bugfix 10/20/17 JD% Eliminated x tick labels to address problem with subplots in summary% artifact figure getting squeezed by formatting problem on PCs.%% modified 2/4/18 JD% Made subplot specification for summary figure output more flexible.%% bugfix 2/12/18 JD% Fixed crash when detrend option used.%% modified 4/2/18 JD% Only interpolate EOG channels if blink or saccade correcting.% Consolidated summary figure for average files so no longer one per subject.%% bugfix 11/29/18 JD% Fixed crash when replacing bad channels and Edit Mode is set to Manual.% Fixed not preserving Average Reference notation and therefore rereferencing the data to the original reference site.%% bugfix 3/9/19 JD% Fixed crash when using noFigure option for preprocessing.%% modified 6/24/19 JD% Accelerates artifact correction by adding option to keep chunks in RAM.%% bugfix 1/10/20 JD% Fixed crash with fMRIb fMRI correction option and there are TR markers with decimal sample numbers.%% modified 3/18/20 JD% Added fiducials structure to find channels function call.%% modified 5/5/20 JD% Added mains noise correction.%% modified 5/16/20 JD% Added EMCP option.% Added separate checkbox control for SP correction.%% modified 5/27/20 JD% Added ICA options for CRD saccade artifact correction.%% bugfix & modified 6/11/20 JD% Fixed crash when processing a file with no trial specs, as from an .erp file.% Added ICA options for CRD saccade and spike potential artifact corrections.% Added eye artifact control to specify EMCP, MAAC, or single-step ICA options.%% modified 8/27/20 JD% Changed automatic default HEOG channels to closest to F9 and F10.%% modified 11/4/20 JD% Changed automatic default upper VEOG channels to closer to eyes.% Moved spike potential file template to separate file.%% modified 2/13/21 JD% Removed option to fix mains noise.%% bugfix 11/12/21 JD% Fixed crash when a topo in the templates figure was blank, as when no data were corrected.%% modified 7/24/22 JD% Added support for reading Matlab .mat files.%% bugfix 11/17/23 JD% Fixed Single File Mode aborting with a "file not found" error.%% modified 11/14/24 JD% If summary figure close button is clicked midway through run, will ask for confirmation that run is to be aborted.%% bugfix 4/18/25 JD% No longer presenting abort dialog for each figure during preprocessing runs.% Fixed not actually temporarily correcting bad EOG channels at start of artfact correction routine.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2025  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPmain EPchunk EPchunkSP EPtictocep_tictoc('begin');baseline=[];timePoints=[];sessionFiles=[];outputFormat='egi_egis';inputFormat='egi_egis';blinkTemplate='autoTemplate';saccTemplate='fileTemplate';SPtemplate='fileTemplate';blinkFile=[];saccadeFile=[];SPfile=[];badChans=[];chunkSize=100000;eog=[];origRefChan=[];currRefChan=[];noFigure=0;ced = 'none';editMode='both';badDataCriteria.window=80;badDataCriteria.minmax=100;badDataCriteria.trialminmax=200;badDataCriteria.badnum=10;badDataCriteria.neighbors=6;badDataCriteria.badchan=.4;badDataCriteria.maxneighbor=30;badDataCriteria.blink=.9;badDataCriteria.detrend=0;badDataCriteria.badtrials=20;badDataCriteria.channelMode='replace';badDataCriteria.trialMode='fix';badDataCriteria.noadjacent=1;badDataCriteria.movefacs=20;badDataCriteria.sacpot=100;badDataCriteria.saturation=[-1000 1000];minTrialsPerCell=15;scrsz = EPmain.scrsz;if ~isempty(varargin)    if isa(varargin{1},'cell') && nargin==1 %if keywords were input as a single cell string        inputSet=varargin{1};    else        inputSet=varargin;    endelse    inputSet=[];endargNum=length(inputSet);if mod(argNum,2) ~= 0    msg{1}='The keywords need to all be in pairs, with a keyword followed by the keyword information.';    [msg]=ep_errorMsg(msg);    returnendreadArg=[];argCount=1;while argCount <= argNum    if isempty(inputSet{argCount})        argCount=argCount+1;    else        switch inputSet{argCount}            case 'files'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''files'' keyword must be followed by a set of file names.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~iscell(inputSet{argCount})                    msg{1}='The ''files'' keyword must be followed by a set of file names.';                    [msg]=ep_errorMsg(msg);                    return                end                sessionFiles=inputSet{argCount};                argCount=argCount+1;            case 'inputFormat'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''inputFormat'' keyword must be followed by a format name.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~ischar(inputSet{argCount})                    msg{1}='The ''inputFormat'' keyword must be followed by a format name.';                    [msg]=ep_errorMsg(msg);                    return                end                inputFormat=inputSet{argCount};                readArg{end+1}='format';                readArg{end+1}=inputSet{argCount};                argCount=argCount+1;            case 'outputFormat'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''outputFormat'' keyword must be followed by a format name.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~ischar(inputSet{argCount})                    msg{1}='The ''outputFormat'' keyword must be followed by a format name.';                    [msg]=ep_errorMsg(msg);                    return                end                outputFormat=inputSet{argCount};                argCount=argCount+1;            case 'baseline'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''baseline'' keyword must be followed by a list of samples.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''baseline'' keyword must be followed by a set of numbers (e.g., [1:50]).';                    [msg]=ep_errorMsg(msg);                    return                end                baseline=inputSet{argCount};                argCount=argCount+1;            case 'timePoints'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''timePoints'' keyword must be followed by a list of samples.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''timePoints'' keyword must be followed by a set of numbers (e.g., [1:50]).';                    [msg]=ep_errorMsg(msg);                    return                end                timePoints=inputSet{argCount};                argCount=argCount+1;%             case 'mains'%                 argCount=argCount+1;%                 if argCount > argNum%                     msg{1}='The ''mains'' keyword must be followed by none, 50, or 60.';%                     [msg]=ep_errorMsg(msg);%                     return%                 end%                 if ~any(strcmp(inputSet{argCount},{'none','50','60'}))%                     msg{1}='The ''mains'' keyword must be followed by none, 50, or 60.';%                     [msg]=ep_errorMsg(msg);%                     return%                 end%                 mainsFix=inputSet{argCount};%                 argCount=argCount+1;            case 'template'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''template'' keyword must be followed by the template option.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~any(strcmp(inputSet{argCount},{'autoTemplate','fileTemplate','bothTemplate','eyeTracker','none'}))                    msg{1}='The ''template'' keyword must be followed by ''autoTemplate'', ''fileTemplate'', ''bothTemplate'',''eyeTracker'', ''none''.';                    [msg]=ep_errorMsg(msg);                    return                end                blinkTemplate=inputSet{argCount};                argCount=argCount+1;            case 'saccTemplate'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''saccTemplate'' keyword must be followed by the saccade template option.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~any(strcmp(inputSet{argCount},{'autoTemplate','fileTemplate','bothTemplate','eyeTracker','none'}))                    msg{1}='The ''saccTemplate'' keyword must be followed by ''autoTemplate'', ''fileTemplate'', ''bothTemplate'',''eyeTracker'', ''none''.';                    [msg]=ep_errorMsg(msg);                    return                end                saccTemplate=inputSet{argCount};                argCount=argCount+1;            case 'SPtemplate'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''SPtemplate'' keyword must be followed by the spike potential template option.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~any(strcmp(inputSet{argCount},{'autoTemplate','fileTemplate','bothTemplate','none'}))                    msg{1}='The ''SPtemplate'' keyword must be followed by ''autoTemplate'', ''fileTemplate'', ''bothTemplate'', ''none''.';                    [msg]=ep_errorMsg(msg);                    return                end                SPtemplate=inputSet{argCount};                argCount=argCount+1;            case 'blinkFile'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''blinkFile'' keyword must be followed by the blink file name.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~ischar(inputSet{argCount})                    msg{1}='The ''blinkFile'' keyword must be followed by the blink file name.';                    [msg]=ep_errorMsg(msg);                    return                end                blinkFile=inputSet{argCount};                argCount=argCount+1;            case 'saccadeFile'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''saccadeFile'' keyword must be followed by the saccade file name.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~ischar(inputSet{argCount})                    msg{1}='The ''saccadeFile'' keyword must be followed by the saccade file name.';                    [msg]=ep_errorMsg(msg);                    return                end                saccadeFile=inputSet{argCount};                argCount=argCount+1;            case 'SPfile'                argCount=argCount+1;                if (argCount > argNum) || ~ischar(inputSet{argCount})                    msg{1}='The ''SPfile'' keyword must be followed by the SP file name.';                    [msg]=ep_errorMsg(msg);                    return                end                SPfile=inputSet{argCount};                argCount=argCount+1;            case 'blinkMethod'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''blinkMethod'' keyword must be followed by the blink method.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~ischar(inputSet{argCount})                    msg{1}='The ''blinkMethod'' keyword must be followed by the blink method.';                    [msg]=ep_errorMsg(msg);                    return                end                blinkMethod=inputSet{argCount};                argCount=argCount+1;            case 'saccMethod'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''saccMethod'' keyword must be followed by the saccade method.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~ischar(inputSet{argCount})                    msg{1}='The ''saccMethod'' keyword must be followed by the saccade method.';                    [msg]=ep_errorMsg(msg);                    return                end                saccMethod=inputSet{argCount};                argCount=argCount+1;            case 'SPmethod'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''SPmethod'' keyword must be followed by the SP method.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~ischar(inputSet{argCount})                    msg{1}='The ''SPmethod'' keyword must be followed by the SP method.';                    [msg]=ep_errorMsg(msg);                    return                end                SPmethod=inputSet{argCount};                argCount=argCount+1;            case 'eogMethod'                argCount=argCount+1;                if (argCount > argNum) || ~ischar(inputSet{argCount})                    msg{1}='The ''eogMethod'' keyword must be followed by the eye movement correction method.';                    [msg]=ep_errorMsg(msg);                    return                end                eogMethod=inputSet{argCount};                argCount=argCount+1;            case 'badChans'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''badChans'' keyword must be followed by a set of numbers (e.g., [1 3]).';                    [msg]=ep_errorMsg(msg);                    return                end                if ~iscell(inputSet{argCount})                    msg{1}='The ''badChans'' keyword must be followed by a set of numbers (e.g., [1 3]).';                    [msg]=ep_errorMsg(msg);                    return                end                badChans=inputSet{argCount};                argCount=argCount+1;            case 'saturation'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''saturation'' keyword must be followed by a range of permissible values (e.g., [-32768 32767]).';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount}) || length(inputSet{argCount}) ~= 2                    msg{1}='The ''saturation'' keyword must be followed by a range of permissible values (e.g., [-32768 32767]).';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.saturation=inputSet{argCount};                argCount=argCount+1;            case 'eog'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''eog'' keyword must be followed by an array with the six EOG channels.';                    [msg]=ep_errorMsg(msg);                    return                end                eog2=inputSet{argCount};                if ~isempty(eog2)                    if ~isnumeric(eog2) || length(eog2) ~= 6                        msg{1}='The ''eog'' keyword must be followed by an array with the six EOG channels.';                        [msg]=ep_errorMsg(msg);                        return                    end                end                eog.LUVEOG = eog2(1);                eog.RUVEOG = eog2(2);                eog.LLVEOG = eog2(3);                eog.RLVEOG = eog2(4);                eog.LHEOG = eog2(5);                eog.RHEOG = eog2(6);                argCount=argCount+1;            case 'window'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''window'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''window'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.window=inputSet{argCount};                argCount=argCount+1;            case 'minmax'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''minmax'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''minmax'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.minmax=inputSet{argCount};                argCount=argCount+1;            case 'trialminmax'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''trialminmax'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''trialminmax'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.trialminmax=inputSet{argCount};                argCount=argCount+1;            case 'badnum'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''badnum'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''badnum'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if badDataCriteria.badnum < 0 || badDataCriteria.badnum > 100                    msg{1}='The ''badnum'' number must be between 0 and 100.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.badnum=inputSet{argCount};                argCount=argCount+1;            case 'neighbors'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''neighbors'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''neighbors'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.neighbors=inputSet{argCount};                argCount=argCount+1;            case 'maxneighbor'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''maxneighbor'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''maxneighbor'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.maxneighbor=inputSet{argCount};                argCount=argCount+1;            case 'badchan'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''badchan'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''badchan'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if badDataCriteria.badchan < 0 || badDataCriteria.badchan > 1                    msg{1}='The ''badchan'' number must be between 0 and 1.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.badchan=inputSet{argCount};                argCount=argCount+1;            case {'blink', 'blinks'}                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''blink'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''blink'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.blink=inputSet{argCount};                if badDataCriteria.blink < 0 || badDataCriteria.blink > 1                    msg{1}='The ''blink'' number must be between 0 and 1.';                    [msg]=ep_errorMsg(msg);                    return                end                argCount=argCount+1;            case {'saccade', 'saccades'}                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''saccade'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''saccade'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.saccade=inputSet{argCount};                if badDataCriteria.saccade < 0 || badDataCriteria.blink > 1                    msg{1}='The ''saccade'' number must be between 0 and 1.';                    [msg]=ep_errorMsg(msg);                    return                end                argCount=argCount+1;            case 'saccademin'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''saccademin'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''saccademin'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.saccademin=inputSet{argCount};                argCount=argCount+1;            case 'sacpot'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''sacpot'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''sacpot'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.sacpot=inputSet{argCount};                argCount=argCount+1;            case 'detrend'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''detrend'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''detrend'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.detrend=inputSet{argCount};                if badDataCriteria.detrend ~= 0 && badDataCriteria.detrend ~= 1                    msg{1}='The ''detrend'' number must be either 0 or 1.';                    [msg]=ep_errorMsg(msg);                    return                end                if badDataCriteria.detrend ==1                    disp('Warning: detrending can distribute an effect across the entire epoch.  Use with care.');                end                argCount=argCount+1;            case 'fMRI'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''fMRI'' keyword must be followed by the algorithm number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''fMRI'' keyword must be followed by the algorithm number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.fMRI=inputSet{argCount};                if badDataCriteria.fMRI < 0 || badDataCriteria.fMRI > 2                    msg{1}='The ''fMRI'' number must be 0-2.';                    [msg]=ep_errorMsg(msg);                    return                end                argCount=argCount+1;            case 'EMG'                argCount=argCount+1;                if argCount+2 > argNum                    msg{1}='The ''EMG'' keyword must be followed by three parameters.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''EMG'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.EMG=inputSet{argCount};                if badDataCriteria.EMG ~= 0 && badDataCriteria.EMG ~= 1                    msg{1}='The ''EMG'' number must be either 0 or 1.';                    [msg]=ep_errorMsg(msg);                    return                end                argCount=argCount+1;                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''EMG'' criterion number must be followed by an EMG ratio parameter.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.EMGratio=inputSet{argCount};                if badDataCriteria.EMGratio < 0                    msg{1}='The ''EMGratio'' number must be positive.';                    [msg]=ep_errorMsg(msg);                    return                end                argCount=argCount+1;                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''EMG'' ratio number must be followed by an EMG threshold parameter.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.EMGthresh=inputSet{argCount};                if badDataCriteria.EMGthresh < 0                    msg{1}='The ''EMG'' threshold number must be positive.';                    [msg]=ep_errorMsg(msg);                    return                end                argCount=argCount+1;            case 'alpha'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''alpha'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''alpha'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.alpha=inputSet{argCount};                if badDataCriteria.alpha ~= 0 && badDataCriteria.alpha ~= 1                    msg{1}='The ''alpha'' number must be either 0 or 1.';                    [msg]=ep_errorMsg(msg);                    return                end                if badDataCriteria.alpha ==1                    disp('Warning: alpha correction is experimental.  Should not be used with frequency-domain analysis.  Use with care.');                    disp('**It can require a great deal of RAM to function and can crash the computer if there is not enough.**');                end                argCount=argCount+1;            case 'badtrials'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''badtrials'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''badtrials'' keyword must be followed by the criterion number.';                    [msg]=ep_errorMsg(msg);                    return                end                if badDataCriteria.badtrials < 0 || badDataCriteria.badtrials > 100                    msg{1}='The ''badtrials'' number must be between 0 and 100.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.badtrials=inputSet{argCount};                argCount=argCount+1;            case 'channelMode'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''channelMode'' keyword must be followed by ''replace'' or ''mark'' or ''none''.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~ischar(inputSet{argCount})                    msg{1}='The ''channelMode'' keyword must be followed by ''replace'' or ''mark'' or ''none''.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~any(strcmp(inputSet{argCount},{'replace','mark','none'}))                    msg{1}='The ''channelMode'' keyword must be followed by ''replace'' or ''mark'' or ''none''.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.channelMode=inputSet{argCount};                argCount=argCount+1;            case 'trialMode'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''trialMode'' keyword must be followed by ''fix'' or ''none''.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~ischar(inputSet{argCount})                    msg{1}='The ''trialMode'' keyword must be followed by ''fix'' or ''none''.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~any(strcmp(inputSet{argCount},{'fix','none'}))                    msg{1}='The ''trialMode'' keyword must be followed by ''fix'' or ''none''.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.trialMode=inputSet{argCount};                argCount=argCount+1;            case 'noadjacent'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''noadjacent'' keyword must be followed by 0 or 1.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''noadjacent'' keyword must be followed by 0 or 1.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.noadjacent=inputSet{argCount};                if badDataCriteria.noadjacent ~= 0 && badDataCriteria.noadjacent ~= 1                    msg{1}='The ''noadjacent'' keyword must be followed by 0 or 1.';                    [msg]=ep_errorMsg(msg);                    return                end                argCount=argCount+1;            case 'chunkSize'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''chunkSize'' keyword must be followed by the chunk size number.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''chunkSize'' keyword must be followed by the chunk size number.';                    [msg]=ep_errorMsg(msg);                    return                end                chunkSize=inputSet{argCount};                argCount=argCount+1;            case 'minTrialsPerCell'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''minTrialsPerCell'' keyword must be followed by a number of trials.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''minTrialsPerCell'' keyword must be followed by a number of trials.';                    [msg]=ep_errorMsg(msg);                    return                end                minTrialsPerCell=inputSet{argCount};                argCount=argCount+1;            case 'movefacs'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''movefacs'' keyword must be followed by a number of factors.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''movefacs'' keyword must be followed by a number of factors.';                    [msg]=ep_errorMsg(msg);                    return                end                badDataCriteria.movefacs=inputSet{argCount};                argCount=argCount+1;            case 'origReference'                readArg{end+1}=inputSet{argCount};                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''origReference'' keyword must be followed by the reference channel(s).';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount}) && ~any(ismember(inputSet{argCount},{'AVG','CSD'}))                    msg{1}='The ''origReference'' keyword must be followed by the reference channel(s).';                    [msg]=ep_errorMsg(msg);                    return                end                origRefChan=inputSet{argCount};                readArg{end+1}=inputSet{argCount};                argCount=argCount+1;            case 'currReference'                readArg{end+1}=inputSet{argCount};                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''currReference'' keyword must be followed by the reference channel(s).';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount}) && ~any(ismember(inputSet{argCount},{'AVG','CSD'}))                    msg{1}='The ''currReference'' keyword must be followed by the reference channel(s).';                    [msg]=ep_errorMsg(msg);                    return                end                currRefChan=inputSet{argCount};                readArg{end+1}=inputSet{argCount};                argCount=argCount+1;            case 'noFigure'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''noFigure'' keyword must be followed by 0 or 1.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~isnumeric(inputSet{argCount})                    msg{1}='The ''noFigure'' keyword must be followed by 0 or 1.';                    [msg]=ep_errorMsg(msg);                    return                end                noFigure=inputSet{argCount};                if noFigure ~= 0 && noFigure ~= 1                    msg{1}='The ''noFigure'' keyword must be followed by 0 or 1.';                    [msg]=ep_errorMsg(msg);                    return                end                argCount=argCount+1;            case 'editMode'                argCount=argCount+1;                if argCount > argNum                    msg{1}='The ''editMode'' keyword must be followed by the edit mode option.';                    [msg]=ep_errorMsg(msg);                    return                end                if ~any(strcmp(inputSet{argCount},{'automatic','manual','both'}))                    msg{1}='The ''editMode'' keyword must be followed by ''automatic'' or ''manual'' or ''both''.';                    [msg]=ep_errorMsg(msg);                    return                end                editMode=inputSet{argCount};                argCount=argCount+1;            otherwise                readArg{end+1}=inputSet{argCount};                argCount=argCount+1;                readArg{end+1}=inputSet{argCount};                argCount=argCount+1;        end    endendif any(strcmp(blinkTemplate, {'fileTemplate','bothTemplate'})) && isempty(blinkFile)    blinkFile = 'blinks';endif ~strcmp('format',readArg)    readArg{end+1}='format';    readArg{end+1}='egi_egis';endif isempty(sessionFiles)    [sessionFiles, pathname]=ep_getFilesUI(inputFormat);    if isempty(sessionFiles)        return    end    if sessionFiles{1}==0        msg{1}='No filenames selected. You have to click on a name';        [msg]=ep_errorMsg(msg);        return    end    for theFile=1:size(sessionFiles,2)        sessionFiles{theFile}=[activeDirectory sessionFiles{theFile}];    endelse    for theFile=1:size(sessionFiles,2)        [activeDirectory, name, ext] = fileparts(sessionFiles{theFile});        if isempty(activeDirectory)            activeDirectory=pwd;            sessionFiles{theFile}=[activeDirectory filesep sessionFiles{theFile}];        end        if ~exist(sessionFiles{theFile},'file')            msg{1}=['Error: The file ' sessionFiles{theFile} ' is not in the directory.'];            [msg]=ep_errorMsg(msg);            return        end    endendsessionFiles=sessionFiles';numSessions = size(sessionFiles,1);EPmain.preprocess.midFigure=0;EPmain.preprocess.autoClose=0;finalLog{1,1}='ARTIFACT CORRECTION SUMMARY';if isempty(badChans) || (isscalar(badChans)) && (isempty(badChans{1}))    badChans=cell(numSessions,1);endif (size(sessionFiles,1) ~= size(badChans,1))    msg{1}='Must specify a set of bad channels for each subject.';    [msg]=ep_errorMsg(msg);    returnendif exist('icadefs','file') ~= 2    msg{1}='Error: ICA not available.  You need to download EEGlab and then add it to Matlab''s path list.';    msg{2}='See tutorial file for details.';    [msg]=ep_errorMsg(msg);    returnendevalc('ep_icadefsWrapper;');if any(isspace(pwd)) && exist(ICABINARY,'file') == 2    disp(['Binary ICA does not work if any part of the pathname (' pwd ') has a space in it.']);    disp('Will use regular ICA instead.');end%assume the first session file is representative of the rest.ep_tictoc;if EPtictoc.stop;return;endName=deblank(sessionFiles{1});thisReadArg=readArg;thisReadArg{end+1}='file';[pathstr, fileName, ext]=fileparts(Name);thisReadArg{end+1}=Name;[EPdata, origEloc, outInfo]=ep_readData(thisReadArg);ep_tictoc;if EPtictoc.stop;return;endif isempty(EPdata) || isempty(EPdata.data)    msg{1}=['Error: The file ' sessionFiles{1} ' was not read successfully.'];    [msg]=ep_errorMsg(msg);    returnend[EPdata]=ep_stripAdds(EPdata);if isempty(EPdata.eloc)    msg{1}=['Error: The file ' sessionFiles{1} ' has no information on channel locations.  .ced file needed.'];    [msg]=ep_errorMsg(msg);    returnendEEGchans=find(strcmp('EEG',EPdata.chanTypes));if (length([EPdata.eloc(EEGchans).theta]) < length(EPdata.eloc(EEGchans))) || (length([EPdata.eloc(EEGchans).radius]) < length(EPdata.eloc(EEGchans)))    msg{1}=['Error: Aborting preprocessing run.  The file ' sessionFiles{1} ' is missing coordinates for channels:'];    msg{2}=[];    for i=1:length(EPdata.eloc)        if isempty(EPdata.eloc(i).theta) || isempty(EPdata.eloc(i).radius)            msg{2}=[msg{2} EPdata.eloc(i).labels ';'];        end    end    [msg]=ep_errorMsg(msg);    returnendif isempty(EPdata.data)    msg{1}=['Error: The file ' sessionFiles{1} ' had no data left to correct after additions were removed.'];    [msg]=ep_errorMsg(msg);    returnendnChans=length(EPdata.chanNames);if badDataCriteria.fMRI    ep_tictoc;if EPtictoc.stop;return;end    if ~strcmp(EPdata.dataType,'continuous')        msg{1}=['Error: Files must be continuous data type to correct for fMRI artifacts.'];        [msg]=ep_errorMsg(msg);        return    end    switch badDataCriteria.fMRI        case 1            disp('Using fMRIb EEGlab plugin to perform fMRI artifact correction.');            disp('R.K. Niazy, C.F. Beckmann, G.D. Iannetti, J.M. Brady, and S.M. Smith (2005) Removal of FMRI environment artifacts from EEG data using optimal basis sets. NeuroImage 28 (3), pages 720-737.');            if ~exist('firls')                msg{1}=['Error: Must have Signal Processing Toolbox installed to perform fMRI artifact correction.'];                msg{2}=['Consider switching to AMRI option using Preprocessing Preferences setting.'];                [msg]=ep_errorMsg(msg);                return            end            if ~exist('fmrib_pas','file')                msg{1}=['Error: Must have fMRIb EEGlab plugin installed to perform fMRI artifact correction.'];                [msg]=ep_errorMsg(msg);                return            end        case 2            disp('Using AMRI EEG fMRI Toolbox to perform fMRI artifact correction.');            disp('Liu Z, de Zwart JA, van Gelderen P, Kuo L-W, Duyn JH, Statistical feature extraction for artifact removal from concurrent fMRI-EEG recordings, NeuroImage (2011), doi:10.1016/j.neuroimage.2011.10.042.');            if ~exist('amri_eeg_rpeak','file')                msg{1}=['Error: Must have AMRI EEG fMRI Toolbox installed to perform fMRI artifact correction.'];                [msg]=ep_errorMsg(msg);                return            end        otherwise            msg{1}=['Error: fMRI option now recognized.'];            [msg]=ep_errorMsg(msg);            return    end    eventValues={EPdata.events{1}.value}';    eventValues=unique(cellfun(@num2str,eventValues(find(~cellfun(@isempty,eventValues))),'UniformOutput',false'));    eventValues=sort(eventValues);    [selected,ok] = listdlg('PromptString',['Choose TR event marker.'],'ListString',eventValues,'SelectionMode','single');    if ~ok        disp('Cancelling preprocessing run.');        return    end    TRmarker=eventValues{selected};endif ~strcmp(blinkTemplate,'none') && ~strcmp(EPdata.dataType,'single_trial')    msg='Warning: blink correction works best with single trial data.';    disp(msg);    logMsg=msg;    finalLog{end+1,1}=logMsg;endif ~strcmp(blinkTemplate,'none') && strcmp(EPdata.dataType,'single_trial') && isempty(baseline)    msg='Warning: blink correction works best with baseline corrected single trial data.';    disp(msg);    logMsg=msg;    finalLog{end+1,1}=logMsg;endif strcmp(badDataCriteria.trialMode,'fix') && ~strcmp(EPdata.dataType,'single_trial')    disp('Warning: movement correction works best with single trial data.');    disp('Otherwise the epochs used for movement correction may not correspond to the segments, if the intention is to segment the data, resulting in discontinuities.');    disp('Likewise, such discontinuities could affect spectral measures if the epochs do not correspond with the spectral windows.');end%Check to make sure the files all have the same number of channels.badList=[];for theFile=2:length(sessionFiles)    ep_tictoc;if EPtictoc.stop;return;end    Name2=deblank(sessionFiles{theFile});    thisReadArg2=readArg;    thisReadArg2{end+1}='file';    thisReadArg2{end+1}=Name2;    thisReadArg2{end+1}='silent';    thisReadArg2{end+1}='on';    thisReadArg2{end+1}='ced';    thisReadArg2{end+1}=EPdata.ced; %assume they all have the same channel coordinates    thisReadArg2{end+1}='montage';    thisReadArg2{end+1}=EPdata.montage; %assume they all have the same montage    if strcmp(inputFormat,'matlab_mat')        thisReadArg2{end+1}='matlabDims';        thisReadArg2{end+1}=outInfo.matlabDims;    end    [data2, origEloc, outInfo]=ep_readData(thisReadArg2);    ep_tictoc;if EPtictoc.stop;return;end    if isempty(data2) || isempty(data2.data)        logMsg=['Warning: The file ' sessionFiles{theFile} ' was not successfully read.  Dropping from batch run.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        badList(end+1)=theFile;    else        [data2]=ep_stripAdds(data2);        if isempty(data2) || isempty(data2.data)            return        end        if (nChans ~= length(data2.chanNames))            logMsg=['Warning: The file ' sessionFiles{theFile} ' has a different set of electrodes from ' sessionFiles{1} '.'];            finalLog{end+1,1}=logMsg;        end    endendsessionFiles(badList)=[];if ~isempty(eog)    logMsg=['Using manually specified EOG channels.'];    disp(logMsg);    finalLog{end+1,1}=logMsg;    if max(eog2) > length(EPdata.chanNames)        msg{1}='EOG channel numbers larger than number of channels in the data.';        [msg]=ep_errorMsg(msg);        return    endelse    %assume they all have the same channel coordinates    [eog.LUVEOG, ~] = ep_findChan(EPdata.eloc, EPdata.implicit, EPdata.chanNames, EPdata.ced, badChans{1}, 'LUVEOG', EPdata.montage);    if isempty(eog.LUVEOG)        msg{1}='Cannot perform preprocessing without EOG channel information.';        [msg]=ep_errorMsg(msg);        return    end    [eog.RUVEOG, ~] = ep_findChan(EPdata.eloc, EPdata.implicit, EPdata.chanNames, EPdata.ced, badChans{1}, 'RUVEOG', EPdata.montage);    [eog.LLVEOG, ~] = ep_findChan(EPdata.eloc, EPdata.implicit, EPdata.chanNames, EPdata.ced, badChans{1}, 'LLVEOG', EPdata.montage);    [eog.RLVEOG, ~] = ep_findChan(EPdata.eloc, EPdata.implicit, EPdata.chanNames, EPdata.ced, badChans{1}, 'RLVEOG', EPdata.montage);    [eog.LHEOG, ~] = ep_findChan(EPdata.eloc, EPdata.implicit, EPdata.chanNames, EPdata.ced, badChans{1}, 'F9', EPdata.montage);    [eog.RHEOG, ~] = ep_findChan(EPdata.eloc, EPdata.implicit, EPdata.chanNames, EPdata.ced, badChans{1}, 'F10', EPdata.montage);endif any(isempty([eog.LUVEOG eog.RUVEOG eog.LLVEOG eog.RLVEOG eog.LHEOG eog.RHEOG]))    msg{1}='Cannot perform preprocessing without EOG channel information.';    [msg]=ep_errorMsg(msg);    returnendelecDistances=ep_closestChans(EPdata.eloc);if isempty(eog)    msg{1}='No EOG channels specified.';    [msg]=ep_errorMsg(msg);    returnendlogMsg=['The blink channels are: LUVEOG(' num2str(eog.LUVEOG) ') RUVEOG(' num2str(eog.RUVEOG) ') LLVEOG(' num2str(eog.LLVEOG) ') RLVEOG(' num2str(eog.RLVEOG) ').'];disp(logMsg);finalLog{end+1,1}=logMsg;logMsg=['The saccade channels are: LHEOG(' num2str(eog.LHEOG) ') RHEOG(' num2str(eog.RHEOG) ').'];disp(logMsg);finalLog{end+1,1}=logMsg;logMsg=['Minimum number of good trials per cell to avoid warning message is: ' num2str(minTrialsPerCell) '.'];disp(logMsg);finalLog{end+1,1}=logMsg;if badDataCriteria.window    logMsg=['Moving average window for smoothing during bad channel detection: ' num2str(badDataCriteria.window) ' ms.'];else    logMsg='Moving average window for smoothing during bad channel detection: OFF.';enddisp(logMsg);finalLog{end+1,1}=logMsg;if badDataCriteria.window    logMsg=['Difference from minimum to maximum for bad channel: ' num2str(badDataCriteria.minmax) ' µv.'];else    logMsg='Difference from minimum to maximum for bad channel: OFF.';enddisp(logMsg);finalLog{end+1,1}=logMsg;if badDataCriteria.window    logMsg=['Percent of bad channels exceeded to declare bad trial, rounding down: ' num2str(badDataCriteria.badnum) '%.'];else    logMsg='Percent of bad channels exceeded to declare bad trial, rounding down: OFF.';enddisp(logMsg);finalLog{end+1,1}=logMsg;if badDataCriteria.neighbors    logMsg=['Number of electrodes considered to be neighbors: ' num2str(badDataCriteria.neighbors) '.'];else    logMsg='Number of electrodes considered to be neighbors: NONE.';enddisp(logMsg);finalLog{end+1,1}=logMsg;if badDataCriteria.badchan    logMsg=['Minimum predictability from neighbors to not be considered globally bad: ' num2str(badDataCriteria.badchan) '.'];else    logMsg='Minimum predictability from neighbors to not be considered globally bad: OFF.';enddisp(logMsg);finalLog{end+1,1}=logMsg;if badDataCriteria.maxneighbor    logMsg=['Maximum difference from most similar neighboring electrode to be considered bad: ' num2str(badDataCriteria.maxneighbor) ' µv.'];else    logMsg='Maximum difference from most similar neighboring electrode to be considered bad: OFF.';enddisp(logMsg);finalLog{end+1,1}=logMsg;logMsg=['Blink template option is: ' blinkTemplate '.'];disp(logMsg);finalLog{end+1,1}=logMsg;logMsg=['CRD saccade template option is: ' saccTemplate '.'];disp(logMsg);finalLog{end+1,1}=logMsg;logMsg=['spike potential template option is: ' SPtemplate '.'];disp(logMsg);finalLog{end+1,1}=logMsg;if strcmp(eogMethod,'EMCP')    logMsg='Using EMCP to perform eye movement correction.';    disp(logMsg);    finalLog{end+1,1}=logMsg;    logMsg='Gratton, G., Coles, M. G. H., & Donchin, E. (1983). A new method for off-line removal of ocular artifact. Electroencephalography and Clinical Neurophysiology, 55, 468–484.';    disp(logMsg);    finalLog{end+1,1}=logMsg;    if ~isequal(badDataCriteria.saturation,[-Inf Inf])        logMsg='EMCP has its own method of dealing with out-of-range time points so will not set them to NaN.';        disp(logMsg);        finalLog{end+1,1}=logMsg;    endelse    if strcmp(eogMethod,'MAAC')        logMsg=['Using MAAC stepwise procedure.'];    else        logMsg=['Using ICA single-step procedure.'];    end    disp(logMsg);    finalLog{end+1,1}=logMsg;    if badDataCriteria.blink && ~strcmp(blinkTemplate,'none')        logMsg=['Threshold correlation with blink template: ' num2str(badDataCriteria.blink) '.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        switch blinkMethod            case 'Infomax'                logMsg='For blinks, using EEGlab function runica to perform Infomax rotation.';            case 'Extended-Infomax'                logMsg='For blinks, using EEGlab function runica to perform Extended-Infomax rotation.';            case 'SOBI'                logMsg='For blinks, using EEGlab function sobi to perform SOBI rotation.';            case 'JADE'                logMsg='For blinks, using EEGlab function jader to perform JADE rotation.';            case 'fastICA'                logMsg='For blinks, using FastICA function fastica to perform fastICA rotation.';            case 'AMICA'                logMsg='For blinks, using EEGlab extension function runamica15 to perform AMICA rotation.';        end        disp(logMsg);        finalLog{end+1,1}=logMsg;    else        logMsg='Blink correction: OFF.';        disp(logMsg);        finalLog{end+1,1}=logMsg;    end    if badDataCriteria.blink && ~strcmp(saccTemplate,'none')        logMsg=['Threshold correlation with saccade template: ' num2str(badDataCriteria.blink) '.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        switch saccMethod            case 'regression'                logMsg='For saccades, using regression method.';            case 'Infomax'                logMsg='For saccades, using EEGlab function runica to perform Infomax rotation.';            case 'Extended-Infomax'                logMsg='For saccades, using EEGlab function runica to perform Extended-Infomax rotation.';            case 'SOBI'                logMsg='For saccades, using EEGlab function sobi to perform SOBI rotation.';            case 'JADE'                logMsg='For saccades, using EEGlab function jader to perform JADE rotation.';            case 'fastICA'                logMsg='For saccades, using FastICA function fastica to perform fastICA rotation.';            case 'AMICA'                logMsg='For saccades, using EEGlab extension function runamica15 to perform AMICA rotation.';        end        disp(logMsg);        finalLog{end+1,1}=logMsg;    else        logMsg='CRD saccade correction: OFF.';        disp(logMsg);        finalLog{end+1,1}=logMsg;    endendif badDataCriteria.sacpot && ~strcmp(SPtemplate,'none')    logMsg=['Saccade Potential Threshold: ' num2str(badDataCriteria.sacpot) '.'];    disp(logMsg);    finalLog{end+1,1}=logMsg;    switch SPmethod        case 'vector'            logMsg='For spike potentials, using vector method.';        case 'Infomax'            logMsg='For spike potentials, using EEGlab function runica to perform Infomax rotation.';        case 'Extended-Infomax'            logMsg='For spike potentials, using EEGlab function runica to perform Extended-Infomax rotation.';        case 'SOBI'            logMsg='For spike potentials, using EEGlab function sobi to perform SOBI rotation.';        case 'JADE'            logMsg='For spike potentials, using EEGlab function jader to perform JADE rotation.';        case 'fastICA'            logMsg='For spike potentials, using FastICA function fastica to perform fastICA rotation.';        case 'AMICA'            logMsg='For spike potentials, using EEGlab extension function runamica15 to perform AMICA rotation.';    endelse    logMsg='Saccade Potential correction: OFF.';enddisp(logMsg);finalLog{end+1,1}=logMsg;if badDataCriteria.detrend    logMsg=['Detrend data: ON.'];else    logMsg='Detrend data: OFF.';enddisp(logMsg);finalLog{end+1,1}=logMsg;if badDataCriteria.badtrials    logMsg=['Percentage of good trials chan is bad to declare a channel globally bad: ' num2str(badDataCriteria.badtrials) '%.'];else    logMsg='Percentage of good trials chan is bad to declare a channel globally bad: NONE.';enddisp(logMsg);finalLog{end+1,1}=logMsg;if badDataCriteria.movefacs && strcmp(badDataCriteria.trialMode,'fix')    logMsg=['Number of factors to retain when correcting movement artifacts: ' num2str(badDataCriteria.movefacs) '.'];else    logMsg='Movement artifact correction: NONE.';enddisp(logMsg);finalLog{end+1,1}=logMsg;if strcmp(badDataCriteria.trialMode,'fix')    logMsg=['Maximum voltage difference allowed when correcting movement artifacts: ' num2str(badDataCriteria.trialminmax) '.'];    disp(logMsg);    finalLog{end+1,1}=logMsg;endif badDataCriteria.EMG    logMsg=['Minimum ratio of signal power to EMG noise to retain during EMG correction: ' num2str(badDataCriteria.EMGratio) '.'];    disp(logMsg);    finalLog{end+1,1}=logMsg;    logMsg=['Hz threshold considered to be the lower bound of possible EMG frquencies during EMG correction: ' num2str(badDataCriteria.EMGthresh) '.'];    disp(logMsg);    finalLog{end+1,1}=logMsg;endlogMsg=['Bad channels and trials: ' badDataCriteria.channelMode '.'];disp(logMsg);finalLog{end+1,1}=logMsg;if ~isempty(baseline)    if ~any(diff(baseline)>1)        logMsg=['Samples used to baseline epochs: ' num2str(baseline(1)) ':' num2str(baseline(end)) '.'];    else        logMsg=['Samples used to baseline epochs: ' num2str(baseline) '.'];    end    disp(logMsg);    finalLog{end+1,1}=logMsg;endif ~isempty(timePoints)    if ~any(diff(baseline)>1)        logMsg=['Samples used to baseline epochs: ' num2str(timePoints(1)) ':' num2str(timePoints(end)) '.'];    else        logMsg=['Samples used to baseline epochs: ' num2str(timePoints) '.'];    end    disp(logMsg);    finalLog{end+1,1}=logMsg;endlogMsg=['Editing mode option is: ' editMode '.'];disp(logMsg);finalLog{end+1,1}=logMsg;% % if any(strcmp(mainsFix,{'50','60'}))%     logMsg='Using PREP pipeline cleanLineNoise function to perform mains noise correction.';%     disp(logMsg);%     finalLog{end+1,1}=logMsg;%     logMsg='Bigdely-Shamlo, N., Mullen, T., Kothe, C., Su, K.-M., & Robbins, K. A. (2015). The PREP pipeline: Standardized preprocessing for large-scale EEG analysis. Frontiers in Neuroinformatics, 9. https://doi.org/10.3389/fninf.2015.00016';%     disp(logMsg);%     finalLog{end+1,1}=logMsg;% endtempVar=fix(clock);if length(sessionFiles) > 1    fid=fopen([activeDirectory filesep 'Artifact_Correction_Log ' num2str(length(sessionFiles)) '-files ' date sprintf('-%d-%d-%d',tempVar(4:6)) '.txt'],'w');else    [pathstr, fileName, ext]=fileparts(sessionFiles{1});    fid=fopen([activeDirectory filesep 'Artifact_Correction_Log ' deblank(fileName) ' ' date sprintf('-%d-%d-%d',tempVar(4:6)) '.txt'],'w');endif (fid == -1)    disp('Error: Unable to start log file.');    returnend% baselineChanged=0;% pointsChanged=0;for iSession = 1:numSessions    tic    ep_tictoc;if EPtictoc.stop;return;end    Name=deblank(sessionFiles{iSession});    [pathstr, fileName, ext]=fileparts(Name);        logMsg='**************************************************************';    disp(logMsg);    finalLog{end+1,1}=logMsg;    logMsg=['Working on: ' Name '.'];    disp(logMsg);    finalLog{end+1,1}=logMsg;        if iSession > 1        thisReadArg=readArg;        thisReadArg{end+1}='file';        thisReadArg{end+1}=Name;        thisReadArg{end+1}='ced';        thisReadArg{end+1}=EPdata.ced; %assume they all have the same channel coordinates        thisReadArg{end+1}='montage';        thisReadArg{end+1}=EPdata.montage; %assume they all have the same montage        SMIsuffix=EPmain.preferences.general.SMIsuffix;        if ~isempty(SMIsuffix)            thisReadArg{end+1}='SMIsuffix';            thisReadArg{end+1}=SMIsuffix;        end        specSuffix=EPmain.preferences.general.specSuffix;        if ~isempty(specSuffix)            thisReadArg{end+1}='specSuffix';            thisReadArg{end+1}=specSuffix;        end        subjectSpecSuffix=EPmain.preferences.general.subjectSpecSuffix;        if ~isempty(subjectSpecSuffix)            thisReadArg{end+1}='subjectSpecSuffix';            thisReadArg{end+1}=subjectSpecSuffix;        end        if strcmp(inputFormat,'matlab_mat')            thisReadArg{end+1}='matlabDims';            thisReadArg{end+1}=outInfo.matlabDims;        end        [EPdata, origEloc, outInfo]=ep_readData(thisReadArg);        ep_tictoc;if EPtictoc.stop;return;end        if isempty(EPdata) || isempty(EPdata.data)            logMsg=['Error: The file was not succcessfully read.'];            disp(logMsg);            finalLog{end+1,1}=logMsg;            continue        end        [EPdata]=ep_stripAdds(EPdata);        if isempty(EPdata) || isempty(EPdata.data)            logMsg=['Error: The file was not succcessfully read.'];            disp(logMsg);            finalLog{end+1,1}=logMsg;            continue        end    end    if ~any(strcmp(EPdata.dataType,{'single_trial','continuous','average'}))        logMsg=['Error: The file type ' EPdata.dataType ' is not currently supported by this function.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        continue    end        if length(EPdata.facNames) > 1        logMsg=['Error: This function is not intended for application to factor data.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        continue    end        if badDataCriteria.fMRI        if ~strcmp(EPdata.dataType,'continuous')            logMsg=['Error: Files must be continuous data type to correct for fMRI artifacts.'];            disp(logMsg);            finalLog{end+1,1}=logMsg;            continue        end    end        if ~isempty(EPdata.freqNames)        logMsg=['Error: This function is not intended for application to FFT data.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        continue    end        if strcmp(EPdata.reference.type,'CSD')        logMsg=['Error: This function is not intended for application to CSD data.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        continue    end        if isempty(EPdata.data)        logMsg=['Error: The file had no data left to correct after additions were removed.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        continue    end        %     if baselineChanged    %         baselineChanged=0;    %         baseline=baselineTemp;    %     end    if strcmp(EPdata.dataType,'continuous') && ~isempty(baseline)        %         baselineTemp=baseline;        baseline=[];        %         baselineChanged=1;        logMsg=['This is continuous data so baseline correction is being deactivated.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;    end        %     if pointsChanged    %         pointsChanged=0;    %         timePoints=timePointsTemp;    %     end    if strcmp(EPdata.dataType,'continuous') && ~isempty(timePoints)        %         timePointsTemp=timePoints;        timePoints=[];        %         pointsChanged=1;        logMsg=['This is continuous data so Points is being deactivated.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;    end        if isempty(strcmp(EPdata.trialSpecNames,'edit'))        EPdata.trialSpecNames{end+1}='edit';        EPdata.trialSpecs(:,end+1)=num2cell(ones(length(EPdata.cellNames),1)*(-1));    end        numSamples=length(EPdata.timeNames);    numChans=length(EPdata.chanNames);    numSubs=length(EPdata.subNames);        if (max(timePoints) > numSamples)        logMsg=['Timepoints samples larger than epoch size itself for ' Name '.\n  Setting equal to the epoch size.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        timePoints=timePoints(find(timePoints<=numSamples));    end        if (max(timePoints) < 1)        logMsg=['Timepoints samples less than one for ' Name '.\n  Ignoring numbers less than one.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        timePoints=timePoints(find(timePoints>=1));    end        %trim data to selected time points    if ~isempty(timePoints)        [EPdata]=ep_selectData(EPdata,{[],[timePoints],[],[],[],[]});        numSamples=length(EPdata.timeNames);    end        if (min(baseline) < 1)        logMsg=['Baseline samples less than one for ' Name '.\n  Ignoring numbers less than one.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        baseline=baseline(find(baseline>=1));    end        if (max(baseline) > numSamples)        logMsg=['Baseline samples larger than epoch size itself for ' Name '.\n  Setting equal to the epoch size.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        baseline=baseline(find(baseline<=numSamples));    end        if strcmp(EPdata.reference.type,'AVG')        logMsg=['The current reference is the average reference.'];    else                if ~any(strcmp('origReference',inputSet)) %if reference not specified, default to data file's settings.            origRefChan= EPdata.reference.original;        end                if ~any(strcmp('currReference',inputSet)) %if reference not specified, default to data file's settings.            currRefChan= EPdata.reference.current;            if isempty(currRefChan)                currRefChan=origRefChan;            end        end                if ~isempty(origRefChan)            if length(origRefChan) > 1                logMsg=['The channels ' num2str(origRefChan(:)') ' are marked as being the original references.'];            elseif length(origRefChan) ==1                logMsg=['The channel ' num2str(origRefChan) ' is marked as being the original reference.'];            end            EPdata.reference.type='REG';            EPdata.reference.original=origRefChan;            disp(logMsg);            finalLog{end+1,1}=logMsg;        else            logMsg=['No channels marked as being the original reference channel.'];            disp(logMsg);            finalLog{end+1,1}=logMsg;        end                if ~isempty(currRefChan)            if length(currRefChan) > 1                logMsg=['The channels ' num2str(currRefChan(:)') ' are marked as being the current references.'];                EPdata.reference.current=currRefChan;                EPdata.reference.type='REG';                if max(currRefChan) > length(EPdata.chanTypes)                    disp(['Error: One or more of the reference channels do not exist.  Skipping file: ' Name]);                    continue                end                if any(~strcmp('EEG',EPdata.chanTypes(currRefChan)))                    disp(['Error: One or more of the reference channels are labeled as not being EEG channels.  Skipping file: ' Name]);                    continue                end            elseif isscalar(currRefChan)                logMsg=['The channel ' num2str(currRefChan) ' is marked as being the current reference.'];                EPdata.reference.current=currRefChan;                EPdata.reference.type='REG';                if currRefChan > length(EPdata.chanTypes)                    disp(['Error: The indicated reference channel does not exist.  Skipping file: ' Name]);                    continue                end                if ~strcmp('EEG',EPdata.chanTypes(currRefChan))                    disp(['Error: The reference channel is labeled as not being an EEG channel.  Skipping file: ' Name]);                    continue                end            end            disp(logMsg);            finalLog{end+1,1}=logMsg;        else            logMsg=['No channels marked as being the current reference channel.'];            disp(logMsg);            finalLog{end+1,1}=logMsg;        end    end        if ~noFigure        %determine number of subplots needed for summary figure        numGraphs=1; %start        if badDataCriteria.detrend || ~isempty(baseline)            numGraphs=numGraphs+1; %baseline correction graph        end        if badDataCriteria.fMRI            numGraphs=numGraphs+1; %fMRI correction graph        end        if any(strcmp(editMode,{'automatic','both'}))            numGraphs=numGraphs+2; %global bad data graph        end        if strcmp(eogMethod,'EMCP')            numGraphs=numGraphs+4;        else            if ~strcmp(saccTemplate,'none')                numGraphs=numGraphs+2; %saccade correction graph            end            if badDataCriteria.blink && ~strcmp(blinkTemplate,'none')                numGraphs=numGraphs+2; %blink correction graph            end        end        if ~strcmp(SPtemplate,'none')            numGraphs=numGraphs+2; %SP correction graph        end        if badDataCriteria.trialminmax && strcmp(badDataCriteria.trialMode,'fix')            numGraphs=numGraphs+2; %movement correction graph        end        if badDataCriteria.EMG            numGraphs=numGraphs+2; %EMG correction graph        end        if badDataCriteria.alpha            numGraphs=numGraphs+2; %alpha correction graph        end        if any(strcmp(editMode,{'automatic','both'})) || (strcmp(editMode,'manual') && strcmp(badDataCriteria.channelMode,'replace'))            numGraphs=numGraphs+2; %bad data correction graph        end%         if any(strcmp(mainsFix,{'50','60'}))%             numGraphs=numGraphs+2; %mains correction graph%         end        origData=EPdata;    end        %correct FMRI artifacts    if badDataCriteria.fMRI        ep_tictoc;if EPtictoc.stop;return;end        if ~strcmp(EPdata.dataType,'continuous')            disp(['Error: Files must be continuous data type to correct for fMRI artifacts.  Skipping file: ' Name]);            continue        end                %correct gradient artifact        correctChans=setdiff(find(ismember(EPdata.chanTypes,{'EEG','ECG'})),EPdata.reference.current);        if isempty(correctChans)            disp(['Error: No non-reference EEG channels for correcting fMRI artifacts.  Skipping file: ' Name]);            continue        end                disp('Correcting gradient artifact');        try            switch badDataCriteria.fMRI                case 1                    lpf=0;                    L=10;                    window=30;                    Trigs=round([EPdata.events{1}(find(strcmp(TRmarker,{EPdata.events{1}.value}))).sample]);                    strig=1;                    anc_chk=1;                    tc_chk=0;                    Volumes=0;                    Slices=0;                    pre_frac=0.0300;                    exc=[];                    npc='auto';                    fmriEEG=fmrib_fastr(ep_ep2alleeg(ep_selectData(EPdata,{correctChans,[],[],[],[],[]})),lpf,L,window,Trigs,strig,anc_chk,tc_chk,Volumes,Slices,pre_frac,exc,npc);                case 2                    fmriEEG = amri_eeg_gac(ep_ep2alleeg(ep_selectData(EPdata,{correctChans,[],[],[],[],[]})),'trigger.name',TRmarker);                otherwise                    msg{1}=['Error: fMRI option not recognized.'];                    [msg]=ep_errorMsg(msg);                    return            end        catch            disp(['Error: Unable to complete removing gradient artifacts.  Skipping file: ' Name]);            continue        end                EPdata.data(correctChans,:,1,1,1,1)=fmriEEG.data;                %find qrs peaks in ECG        ECGchan=find(strcmp('ECG',EPdata.chanTypes));        EEGchan=find(strcmp('EEG',EPdata.chanTypes));        if isempty(ECGchan)            disp(['Error: No ECG channel for correcting fMRI artifacts.  Skipping file: ' Name]);            continue        end        if length(ECGchan) >1            disp(['Warning: Multiple ECG channels in file ' Name '.  Using only first ECG channel.']);            ECGchan=ECGchan(1);        end                disp('Finding pulse beats');        try            switch badDataCriteria.fMRI                case 1                    ECGchan=find(strcmp('ECG',EPdata.chanTypes(correctChans)));                    Peaks=fmrib_qrsdetect(ep_ep2alleeg(ep_selectData(EPdata,{correctChans,[],[],[],[],[]})),ECGchan);                    for iPeak=1:length(Peaks)                        EPdata.events{1}(end+1).value='qrs';                        EPdata.events{1}(end).type='trigger';                        EPdata.events{1}(end).duration=0;                        EPdata.events{1}(end).sample=Peaks(iPeak);                        EPdata.events{1}(end).keys=struct('code','','data','','datatype','','description','');                    end                case 2                    addedField=0;                    if ~isfield(EPdata.events{1},'urevent')                        EPdata.events{1}(1).urevent=[];                        addedField=1;                    end                    fmriEEG = amri_eeg_rpeak(ep_ep2alleeg(ep_selectData(EPdata,{EEGchan,[],[],[],[],[]})),ep_ep2alleeg(ep_selectData(EPdata,{ECGchan,[],[],[],[],[]})));                    if addedField                        EPdata.events{1}=rmfield(EPdata.events{1},'urevent');                    end                    eventIndex=find(strcmp('R',{fmriEEG.event.type}));                    for iEvent=1:length(eventIndex)                        EPdata.events{1}(end+1).value='R';                        EPdata.events{1}(end).type='artifact';                        EPdata.events{1}(end).duration=fmriEEG.event(eventIndex(iEvent)).duration;                        EPdata.events{1}(end).sample=fmriEEG.event(eventIndex(iEvent)).latency;                        EPdata.events{1}(end).keys=struct('code','','data','','datatype','','description','');                    end                otherwise                    msg{1}=['Error: fMRI option not recognized.'];                    [msg]=ep_errorMsg(msg);                    return            end        catch ME            rethrow(ME)            disp(['Error: Unable to complete detecting pulse beats.  Skipping file: ' Name]);            continue        end                %correct BCG artifact        disp('Correcting ballistocardiogram artifact');        correctChans=setdiff(find(strcmp('EEG',EPdata.chanTypes)),EPdata.reference.current);        try            switch badDataCriteria.fMRI                case 1                    fmriEEG = fmrib_pas(ep_ep2alleeg(ep_selectData(EPdata,{correctChans,[],[],[],[],[]})),Peaks,'obs',4);                case 2                    fmriEEG = amri_eeg_cbc(ep_ep2alleeg(ep_selectData(EPdata,{correctChans,[],[],[],[],[]})),ep_ep2alleeg(ep_selectData(EPdata,{ECGchan,[],[],[],[],[]})));                    eventIndex=find(strcmp('R',{EPdata.events{1}.value}));                    for iEvent=1:length(eventIndex)                        EPdata.events{1}(eventIndex(iEvent)).value='qrs';                    end                otherwise                    msg{1}=['Error: fMRI option not recognized.'];                    [msg]=ep_errorMsg(msg);                    return            end        catch            disp(['Error: Unable to complete removing BCG artifacts.  Skipping file: ' Name]);            continue        end        EPdata.data(correctChans,:,1,1,1,1)=fmriEEG.data;                subjectTime = floor(toc/60);        logMsg=['The file took ' num2str(subjectTime) ' minutes to process for fMRI artifacts.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;    end        ep_tictoc;if EPtictoc.stop;return;end    [chunkSizes] = ep_chunkInputFile(EPdata, Name, chunkSize);    numChunks=length(chunkSizes);    if numChunks > 1        logMsg=['The file is being split into ' num2str(numChunks) ' files due to its size.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;        logMsg=['If you think your computer has enough RAM to process the file without splitting it, change the Size of Chunks preference setting.'];        disp(logMsg);        finalLog{end+1,1}=logMsg;    end        graphCounter=1;    if ~noFigure        trialData=reshape(origData.data,numChans,[]);        if badDataCriteria.fMRI            fmriEEGtrialData=reshape(fmriEEG.data,length(correctChans),[]);        end        EPmain.preprocess.handles.butterflyFig=cell(numChunks,1);        EPmain.preprocess.midFigure=1;        for iChunk=1:numChunks            if numChunks==1                figName=deblank(fileName);            else                figName=[deblank(fileName) '-' num2str(iChunk)];            end            EPmain.preprocess.handles.butterflyFig{iChunk}=figure('Name',figName,'NumberTitle','off','Position',[scrsz(1)+EPmain.panesize(1) 1 400 scrsz(4)], 'MenuBar', 'none', 'Visible','Off','CloseRequestFcn',@closeSummary);            colormap jet;                        displayPeriod=chunkSizes(iChunk);    %Number of timepoints to graph in display.            decimateSamples=ceil(max(1,displayPeriod/10000));                        for iGraph=1:numGraphs                %                 subplot(numGraphs,1,iGraph), plot([1:decimateSamples:displayPeriod],zeros(1,length([1:decimateSamples:displayPeriod])));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);            end                        subplot(numGraphs,1,graphCounter), plot([1:decimateSamples:displayPeriod],trialData(EEGchans,sum(chunkSizes(1:iChunk-1))+1:decimateSamples:sum(chunkSizes(1:iChunk-1))+displayPeriod));            axis([1 displayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title('raw data','Interpreter','none');            if badDataCriteria.fMRI                subplot(numGraphs,1,graphCounter+1), plot([1:decimateSamples:displayPeriod],fmriEEGtrialData(correctChans,sum(chunkSizes(1:iChunk-1))+1:decimateSamples:sum(chunkSizes(1:iChunk-1))+displayPeriod));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                title('fMRI arifact corrected','Interpreter','none');            end            drawnow        end        graphCounter=graphCounter+1;        if badDataCriteria.fMRI            graphCounter=graphCounter+1;            clear fmriEEGtrialData fmriEEG;        end        clear trialData origData;    end        icaFlag='none';    startCounter=graphCounter;    for iSub=1:numSubs        graphCounter=startCounter;        badSubject=0;        if numSubs > 1            logMsg=['   Subject: ' EPdata.subNames{iSub}];            disp(logMsg);            finalLog{end+1,1}=logMsg;        end                %detrend and baseline correct data        if badDataCriteria.detrend || ~isempty(baseline)            ep_tictoc;if EPtictoc.stop;return;end            [outputLog, graphCounter] = ep_detrendChunk(Name, 1, numChunks, iSub, badDataCriteria.detrend, baseline, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs);            finalLog(end+1:end+length(outputLog),1)=outputLog;        end        %         %fix mains noise%         if any(strcmp(mainsFix,{'50','60'}))%             [outputLog, graphCounter] = ep_fixMains(Name, 1, numChunks, iSub, str2double(mainsFix), EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs);%         end                %detect global bad and shorted channels        if any(strcmp(editMode,{'automatic','both'}))            ep_tictoc;if EPtictoc.stop;return;end            if strcmp(eogMethod,'EMCP')                tempSat=badDataCriteria.saturation;                badDataCriteria.saturation=[-Inf Inf]; %temporarily disable out-of-range NaN replacement as EMCP has its own method of dealing with them.            end            [badChansDetected shortChansDetected, outputLog, graphCounter]=ep_detectBadChans(Name, 1, numChunks, badDataCriteria, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs, iSub, chunkSizes);            if strcmp(eogMethod,'EMCP')                badDataCriteria.saturation=tempSat;            end            finalLog(end+1:end+length(outputLog),1)=outputLog;        else            shortChansDetected=[];            badChansDetected=[];        end        if badChansDetected == -1            logMsg=['This file encountered an error while trying to detect bad channels and so will not be artifact corrected.'];            disp(logMsg);            finalLog{end+1,1}=logMsg;            badSubject=1;        end                theBadChans=unique([badChansDetected; badChans{theFile}]);        if ~isempty(theBadChans)            logMsg=['Global bad channels: ' num2str(theBadChans')];        else            logMsg='Global bad channels: None';        end        disp(logMsg);        finalLog{end+1,1}=logMsg;        if ~any(strcmp(editMode,{'automatic','both'}))            logMsg='(automatic bad channel detection was deactivated)';            finalLog{end+1,1}=logMsg;        end                if badDataCriteria.badnum            if length(theBadChans) > floor(numChans*(badDataCriteria.badnum/100))                if length(EPdata.subNames) > 1                    logMsg=['For subject ' EPdata.subNames{iSub} ' there were too many bad channels.'];                else                    logMsg=['This file has too many bad channels.'];                end                disp(logMsg);                finalLog{end+1,1}=logMsg;                badSubject=1;            end        end                if badDataCriteria.neighbors && badDataCriteria.noadjacent && ~isempty(theBadChans) %neighboring bad channels?            warn=0;            for iChan=1:length(theBadChans)                chan=theBadChans(iChan);                [B IX]=sort(elecDistances(chan,:));                neighbors=IX(2:badDataCriteria.neighbors+1);                if ~isempty(intersect(theBadChans,neighbors))                    warn=1;                    break                end            end            if warn                if length(EPdata.subNames) > 1                    logMsg=['Warning: Subject ' EPdata.subNames{iSub} ' has neighboring globally bad channels.'];                else                    logMsg=['Warning: Subject has neighboring globally bad channels.'];                end                disp(logMsg);                finalLog{end+1,1}=logMsg;            end        end                if ~badSubject                        %interp bad EOG channels if either saccade or blink correcting.            interpChans=[];            if ~strcmp(saccTemplate,'none') || (badDataCriteria.blink && ~strcmp(blinkTemplate,'none'))                ep_tictoc;if EPtictoc.stop;return;end                if any(ismember(eog.LHEOG,theBadChans))                    logMsg='Temporarily interpolating left HEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.LHEOG);                    interpChans(end+1,1)=eog.LHEOG;                end                if any(ismember(eog.RHEOG,theBadChans))                    logMsg='Temporarily interpolating right HEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.RHEOG);                    interpChans(end+1,1)=eog.RHEOG;                end                if any(ismember(eog.LUVEOG,theBadChans))                    logMsg='Temporarily interpolating left upper VEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.LUVEOG);                    interpChans(end+1,1)=eog.LUVEOG;                end                if any(ismember(eog.RUVEOG,theBadChans))                    logMsg='Temporarily interpolating right upper VEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.RUVEOG);                    interpChans(end+1,1)=eog.RUVEOG;                end                if any(ismember(eog.LLVEOG,theBadChans))                    logMsg='Temporarily interpolating left lower VEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.LLVEOG);                    interpChans(end+1,1)=eog.LLVEOG;                end                if any(ismember(eog.RLVEOG,theBadChans))                    logMsg='Temporarily interpolating right lower VEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.RLVEOG);                    interpChans(end+1,1)=eog.RLVEOG;                end                if ~isempty(interpChans)                    logMsg='Warning: interpolating may not work sufficiently well.  It may be necessary to redo this session using manual templates.';                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                end                                for iChunk=1:numChunks                    if exist('EPchunk','var') && ~isempty(EPchunk)                        dataChunk=EPchunk{iChunk};                    else                        ep_tictoc('ioStart');                        eval(['load ''' deblank(inFile) '-' num2str(iChunk) '.mat''']);                        ep_tictoc('ioFinish');                    end                    trialData=reshape(dataChunk.data(:,:,:,iSub),length(dataChunk.chanNames),[]);                    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));                    chans = setdiff(EEGchans,theBadChans);                                        if ~isempty(interpChans)                        disp(['Interpolating ' num2str(size(trialData,2)) ' time points.']);                        dataChunk.interpChans.data=trialData(interpChans,:);                        dataChunk.interpChans.chans=interpChans;                        goodChans=setdiff(chans,interpChans);                        newData=ep_interpChans(trialData(goodChans,:), dataChunk.eloc(goodChans), dataChunk.eloc(interpChans));                        ep_tictoc;if EPtictoc.stop;return;end                        if isempty(newData)                            return                        else                            trialData(interpChans,:)=newData;                        end                    end                                        dataChunk.data(:,:,:,iSub)=reshape(trialData,size(dataChunk.data(:,:,:,iSub)));                    if exist('EPchunk','var') && ~isempty(EPchunk)                        EPchunk{iChunk}=dataChunk;                    else                        ep_tictoc('ioStart');                        eval (['save ''' inFile '-' num2str(iChunk) '.mat'' dataChunk']);                        ep_tictoc('ioFinish');                    end                end            end                        templates.sacPot=[];            templates.hSaccades=[];            templates.vSaccades=[];            templates.blinks=[];            excludePoints=cell(numChunks,1);            blinkDetect=0;                        if strcmp(eogMethod,'ICA')                icaFlag='needToSave';            else                icaFlag='none';            end                        if strcmp(eogMethod,'MAAC')                if ~strcmp(SPtemplate,'none') || ~strcmp(saccTemplate,'none')                    scanFlag=1;                    ep_tictoc;if EPtictoc.stop;return;end                    %identify blink time points to exclude them from the spike potential and saccade correction procedures                    if badDataCriteria.blink && ~strcmp(blinkTemplate,'none')                        EPchunkSP=cell(numChunks,1);                        for iChunk = 1:numChunks                            EPchunkSP{iChunk}=1; %flag that no modified data are available for this chunk during this preliminary step.                        end                                                if ~strcmp(SPtemplate,'none')                            logMsg=['Starting preliminary spike potential scan to exclude them from the preliminary blink detection routine.'];                            disp(logMsg);                            finalLog{end+1,1}=logMsg;                            [totsaccadeTrialNum, temp, outputLog, graphCounter, icaFlag] = ep_fixSaccadePotential(Name, [Name 'SP'], 1, numChunks, badDataCriteria, theBadChans, eog, SPtemplate, SPfile, currRefChan, excludePoints, [], graphCounter, numGraphs, iSub, SPmethod, icaFlag, scanFlag);                            finalLog(end+1:end+length(outputLog),1)=outputLog;                            ep_tictoc;if EPtictoc.stop;return;end                            inFileName=[Name 'SP'];                            if isempty(temp)                                logMsg=['Preliminary spike potential run of file ' Name ' did not find spike potentials.  Skipping the operation.'];                                disp(logMsg);                                finalLog{end+1,1}=logMsg;                                inFileName=Name;                            end                        else                            inFileName=Name;                        end                                                logMsg=['Starting preliminary blink scan to identify which time points to exclude from the saccade and the spike potential corrections.'];                        disp(logMsg);                        finalLog{end+1,1}=logMsg;                                                [blinkTrialNum, excludePoints, temp, outputLog, graphCounter, icaFlag] = ep_fixBlink(inFileName, [Name 'SP'], 1, numChunks, badDataCriteria, theBadChans, eog, blinkTemplate, saccTemplate, blinkFile, saccadeFile, baseline, currRefChan, [], graphCounter, numGraphs, iSub, blinkMethod, icaFlag, scanFlag, eogMethod);                        blinkDetect=1;                        finalLog(end+1:end+length(outputLog),1)=outputLog;                        ep_tictoc;if EPtictoc.stop;return;end                        if isempty(temp)                            logMsg=['Something went wrong with the preliminary blink detection run of file ' Name '.  Skipping the operation.'];                            disp(logMsg);                            finalLog{end+1,1}=logMsg;                        end                    end                                        if exist('EPchunkSP','var')                        EPchunkSP=[];                    else                        for iChunk = 1:numChunks                            delete([Name 'SP-' num2str(iChunk) '.mat']); %clean up temporary work files                        end                    end                end            end                        scanFlag=0;                        %fix saccadic spike potentials            if EPmain.preprocess.SP                if blinkDetect                    logMsg=['Starting final spike potential correction, excluding blink time points.'];                else                    logMsg=['Starting final spike potential correction.'];                end                disp(logMsg);                finalLog{end+1,1}=logMsg;                [totsaccadeTrialNum, outTemplate, outputLog, graphCounter, icaFlag] = ep_fixSaccadePotential(Name, Name, 1, numChunks, badDataCriteria, theBadChans, eog, SPtemplate, SPfile, currRefChan, excludePoints, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs, iSub, SPmethod, icaFlag, scanFlag);                finalLog(end+1:end+length(outputLog),1)=outputLog;                ep_tictoc;if EPtictoc.stop;return;end                if isempty(outTemplate)                    logMsg=['Something went wrong with the spike potential correction run of file ' Name '.  Skipping the operation.'];                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    outTemplate.sacPot=[];                end                templates.sacPot=outTemplate.sacPot;            end                                    %             eval(['load(''' Name '-blink'',''-mat'');']);            %             logMsg=['Using prior computed blink run for initial blink exclusion.'];            %             disp(logMsg);            %             finalLog{end+1,1}=logMsg;                        if strcmp(eogMethod,'EMCP')                ep_tictoc;if EPtictoc.stop;return;end                logMsg=['Starting EMCP correction.'];                disp(logMsg);                finalLog{end+1,1}=logMsg;                [blinkTrialNum, blinkPoints, outTemplate, outputLog, graphCounter, icaFlag] = ep_fixBlink(Name, Name, 1, numChunks, badDataCriteria, theBadChans, eog, blinkTemplate, saccTemplate, blinkFile, saccadeFile, baseline, currRefChan, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs, iSub, blinkMethod, icaFlag, scanFlag, eogMethod);                finalLog(end+1:end+length(outputLog),1)=outputLog;                if isempty(outTemplate)                    logMsg=['Something went wrong with the EMCP run of file ' Name '.  Skipping the operation.'];                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    outTemplate.blinks=[];                end                templates.blinks=outTemplate.blinks;                templates.hSaccades=outTemplate.hSaccades;                templates.vSaccades=outTemplate.vSaccades;            else                                %fix saccade artifacts                if ~strcmp(saccTemplate,'none')                    if blinkDetect                        logMsg=['Starting saccade correction, interpolating blink time points.'];                    else                        logMsg=['Starting saccade correction.'];                    end                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    [outTemplate, outputLog, graphCounter, icaFlag] = ep_fixSaccade(Name, 1, numChunks, theBadChans, eog, saccTemplate, saccadeFile, badDataCriteria, currRefChan, excludePoints, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs, iSub, saccMethod, icaFlag);                    finalLog(end+1:end+length(outputLog),1)=outputLog;                    if isempty(outTemplate)                        logMsg=['Something went wrong with the saccade correction run of file ' Name '.  Skipping the operation.'];                        disp(logMsg);                        finalLog{end+1,1}=logMsg;                        outTemplate.hSaccades=[];                        outTemplate.vSaccades=[];                    end                    templates.hSaccades=outTemplate.hSaccades;                    templates.vSaccades=outTemplate.vSaccades;                end                                %fix blink artifacts                if badDataCriteria.blink && ~strcmp(blinkTemplate,'none')                    ep_tictoc;if EPtictoc.stop;return;end                    if blinkDetect                        logMsg=['Starting final blink correction.'];                    else                        logMsg=['Starting blink correction.'];                    end                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    scanFlag=0;                    [blinkTrialNum, blinkPoints, outTemplate, outputLog, graphCounter, icaFlag] = ep_fixBlink(Name, Name, 1, numChunks, badDataCriteria, theBadChans, eog, blinkTemplate, saccTemplate, blinkFile, saccadeFile, baseline, currRefChan, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs, iSub, blinkMethod, icaFlag, scanFlag, eogMethod);                    finalLog(end+1:end+length(outputLog),1)=outputLog;                    if isempty(outTemplate)                        logMsg=['Something went wrong with the blink correction run of file ' Name '.  Skipping the operation.'];                        disp(logMsg);                        finalLog{end+1,1}=logMsg;                        outTemplate.blinks=[];                    end                    templates.blinks=outTemplate.blinks;                end            end                        %             eval(['save ' Name '-blinkSaccSP EPchunk excludePoints theBadChans;']);                        %fix movement artifacts            if badDataCriteria.trialminmax && strcmp(badDataCriteria.trialMode,'fix')                ep_tictoc;if EPtictoc.stop;return;end                [moveTrialNum outputLog, graphCounter] = ep_fixMovement(Name, 1, numChunks, badDataCriteria, theBadChans, currRefChan, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs, iSub, eog);                finalLog(end+1:end+length(outputLog),1)=outputLog;            else                moveTrialNum=[];            end                        %fix EMG artifacts            if badDataCriteria.EMG                ep_tictoc;if EPtictoc.stop;return;end                logMsg=['Starting EMG correction.'];                disp(logMsg);                finalLog{end+1,1}=logMsg;                if isempty(ver('signal'))                    logMsg=['EMG correction requires Signal Processing Toolbox'];                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                else                    [outputLog, graphCounter] = ep_fixEMG(Name, 1, numChunks, badDataCriteria, theBadChans, currRefChan, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs, iSub);                end            end                        %fix alpha artifacts            if badDataCriteria.alpha                ep_tictoc;if EPtictoc.stop;return;end                logMsg=['Starting alpha correction.'];                disp(logMsg);                finalLog{end+1,1}=logMsg;                [outputLog, graphCounter] = ep_fixAlpha(Name, 1, numChunks, badDataCriteria, theBadChans, currRefChan, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs, iSub);            end                        %detect bad channels and trials            if any(strcmp(editMode,{'automatic','both'}))                ep_tictoc;if EPtictoc.stop;return;end                [outputLog, theBadChans, badChanNum, badTrialNum] = ep_detectBadDataChunk(Name, 1, numChunks, badDataCriteria, theBadChans, editMode, iSub);                finalLog(end+1:end+length(outputLog),1)=outputLog;            else                badTrialNum=[];                badChanNum=[];            end                        if badDataCriteria.badnum                if length(theBadChans) > floor(numChans*(badDataCriteria.badnum/100))                    logMsg=['This subject has too many bad channels.'];                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                    badSubject=1;                end            end                        if badDataCriteria.neighbors && badDataCriteria.noadjacent %neighboring bad channels?                warn=0;                for iChan=1:length(theBadChans)                    chan=theBadChans(iChan);                    [B IX]=sort(elecDistances(chan,:));                    neighbors=IX(2:badDataCriteria.neighbors+1);                    if ~isempty(intersect(theBadChans,neighbors))                        warn=1;                        break                    end                end                if warn                    logMsg='Warning: Subject has neighboring globally bad channels.';                    disp(logMsg);                    finalLog{end+1,1}=logMsg;                end            end                        if strcmp(EPdata.dataType,'single_trial')                [uniqueCellNames, m, CellNameIndex] = unique(EPdata.cellNames);                cellGoodTrialCount=hist(CellNameIndex,length(unique(EPdata.cellNames)));                for theTrial=1:length(badTrialNum)                    if badTrialNum(theTrial)                        cellGoodTrialCount(CellNameIndex(theTrial))=cellGoodTrialCount(CellNameIndex(theTrial))-1;                    end                end                                for theCell=1:length(cellGoodTrialCount)                    if cellGoodTrialCount(theCell) < minTrialsPerCell                        if cellGoodTrialCount(theCell) == 0                            logMsg=['Warning: Cell ' uniqueCellNames{theCell} ' has no good trials.'];                        elseif cellGoodTrialCount(theCell) == 1                            logMsg=['Warning: Cell ' uniqueCellNames{theCell} ' has only 1 good trial.'];                        else                            logMsg=['Warning: Cell ' uniqueCellNames{theCell} ' has only ' num2str(cellGoodTrialCount(theCell)) ' good trials.'];                        end                        disp(logMsg);                        finalLog{end+1,1}=logMsg;                    end                end            end                        if ~badSubject                theDots=findstr(Name,'.');                outName=Name;                if ~isempty(theDots)                    outName=Name(1:theDots(end)-1); %drop the suffix                end                                %replace or mark bad channels                if ~isempty(interpChans)                    ep_tictoc;if EPtictoc.stop;return;end                    theBadChans=unique([interpChans; theBadChans]);                    for iChunk=1:numChunks                        if exist('EPchunk','var') && ~isempty(EPchunk)                            dataChunk=EPchunk{iChunk};                        else                            ep_tictoc('ioStart');                            eval(['load ''' deblank(inFile) '-' num2str(iChunk) '.mat''']);                            ep_tictoc('ioFinish');                        end                        trialData=reshape(dataChunk.data(:,:,:,iSub),length(dataChunk.chanNames),[]);                        trialData(interpChans,:)=dataChunk.interpChans.data;                        dataChunk=rmfield(dataChunk,'interpChans');                        dataChunk.data(:,:,:,iSub)=reshape(trialData,size(dataChunk.data(:,:,:,iSub)));                        if exist('EPchunk','var') && ~isempty(EPchunk)                            EPchunk{iChunk}=dataChunk;                        else                            ep_tictoc('ioStart');                            eval (['save ''' inFile '-' num2str(iChunk) '.mat'' dataChunk']);                            ep_tictoc('ioFinish');                        end                    end                end                                if strcmp(badDataCriteria.channelMode,'replace')                    [outputLog, graphCounter] = ep_replaceBadDataChunks(Name, 1, numChunks, theBadChans, EPmain.preprocess.handles.butterflyFig, graphCounter, numGraphs, iSub);                    finalLog(end+1:end+length(outputLog),1)=outputLog;                elseif strcmp(badDataCriteria.channelMode,'mark')                    [outputLog] = ep_markBadDataChunks(Name, 1, numChunks, theBadChans, iSub);                    finalLog(end+1:end+length(outputLog),1)=outputLog;                end            end                        if ~noFigure                if ~strcmp(saccTemplate,'none') || ~strcmp(blinkTemplate,'none')                    templateFig=figure('Name','Templates','NumberTitle','off','Position',[201 1 900 600], 'MenuBar', 'none','Visible','Off','CloseRequestFcn',@closeSummary);                    colormap jet;                    uicontrol('Style','text','String','Auto','FontSize',EPmain.fontsize,'Position',[100 500 50 20]);                    uicontrol('Style','text','String','File','FontSize',EPmain.fontsize,'Position',[300 500 50 20]);                    uicontrol('Style','text','String','Subtracted','FontSize',EPmain.fontsize,'Position',[500 500 100 20]);                    if ~isempty(templates.sacPot)                        uicontrol('Style','text','String','L Sac Pot','FontSize',EPmain.fontsize,'Position',[10 450 80 20]);                        uicontrol('Style','text','String','R Sac Pot','FontSize',EPmain.fontsize,'Position',[10 350 80 20]);                        if ~isempty(templates.sacPot.autoL)                            if any(templates.sacPot.autoL)                                theMax=abs(max(templates.sacPot.autoL));                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[100 400 100 100]);                            el_topoplot(templates.sacPot.autoL, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                        if ~isempty(templates.sacPot.autoR)                            if any(templates.sacPot.autoR)                                theMax=max(abs(templates.sacPot.autoR),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[100 300 100 100]);                            el_topoplot(templates.sacPot.autoR, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                        if ~isempty(templates.sacPot.manual)                            if any(templates.sacPot.manual)                                theMax=max(abs(templates.sacPot.manual),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[300 400 100 100]);                            el_topoplot(templates.sacPot.manual, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                        if ~isempty(templates.sacPot.sacPotTopo)                            if any(templates.sacPot.sacPotTopo)                                theMax=max(abs(templates.sacPot.sacPotTopo),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[500 400 100 100]);                            el_topoplot(templates.sacPot.sacPotTopo, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                    end                    if ~isempty(templates.hSaccades)                        uicontrol('Style','text','String','H Sacc','FontSize',EPmain.fontsize,'Position',[10 250 80 20]);                        if ~isempty(templates.hSaccades.auto)                            if any(templates.hSaccades.auto)                                theMax=max(abs(templates.hSaccades.auto),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[100 200 100 100]);                            el_topoplot(templates.hSaccades.auto, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                        if ~isempty(templates.hSaccades.manual)                            if any(templates.hSaccades.manual)                                theMax=max(abs(templates.hSaccades.manual),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[300 200 100 100]);                            el_topoplot(templates.hSaccades.manual, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                        if ~isempty(templates.hSaccades.hSaccadesTopo)                            if any(templates.hSaccades.hSaccadesTopo)                                theMax=max(abs(templates.hSaccades.hSaccadesTopo),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[500 200 100 100]);                            el_topoplot(templates.hSaccades.hSaccadesTopo, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                    end                    if ~isempty(templates.vSaccades)                        uicontrol('Style','text','String','V Sacc','FontSize',EPmain.fontsize,'Position',[10 150 80 20]);                        if ~isempty(templates.vSaccades.auto)                            if any(templates.vSaccades.auto)                                theMax=max(abs(templates.vSaccades.auto),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[100 100 100 100]);                            el_topoplot(templates.vSaccades.auto, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                        if ~isempty(templates.vSaccades.manual)                            if any(templates.vSaccades.manual)                                theMax=max(abs(templates.vSaccades.manual),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[300 100 100 100]);                            el_topoplot(templates.vSaccades.manual, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                        if ~isempty(templates.vSaccades.vSaccadesTopo)                            if any(templates.vSaccades.vSaccadesTopo)                                theMax=max(abs(templates.vSaccades.vSaccadesTopo),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[500 100 100 100]);                            el_topoplot(templates.vSaccades.vSaccadesTopo, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                    end                    if ~isempty(templates.blinks)                        uicontrol('Style','text','String','Blink','FontSize',EPmain.fontsize,'Position',[10 50 80 20]);                        if ~isempty(templates.blinks.auto)                            if any(templates.blinks.auto)                                theMax=max(abs(templates.blinks.auto),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[100 1 100 100]);                            el_topoplot(templates.blinks.auto, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                        if ~isempty(templates.blinks.manual)                            if any(templates.blinks.manual)                                theMax=max(abs(templates.blinks.manual),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[300 1 100 100]);                            el_topoplot(templates.blinks.manual, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                        if ~isempty(templates.blinks.blinkTopo)                            if any(templates.blinks.blinkTopo)                                theMax=max(abs(templates.blinks.blinkTopo),[],'omitnan');                                theMin=-theMax;                            else                                theMin=-1;                                theMax=1;                            end                            axes('Units','pixel','position',[500 1 100 100]);                            el_topoplot(templates.blinks.blinkTopo, EPdata.eloc(EEGchans),'maplimits',[theMin, theMax]);                        end                    end                    if numSubs > 1                        stemName = [fileName '(' EPdata.subNames{iSub} ')'];                    else                        stemName = fileName;                    end                                        sameName=1;                    theNumber=0;                    fileName=stemName;                    while sameName                        sameName=0;                        if exist([pathstr filesep fileName '_templates.jpg'],'file')                            sameName=1;                        end                        if sameName                            theNumber=theNumber+1;                            fileName=[stemName '-' num2str(theNumber)];                        end                    end                                        try                        if isnumeric(templateFig)                            if ~isprop(templateFig,'Number')                                eval (['print -f' num2str(templateFig) ' -djpeg ''' pathstr filesep fileName '_templates.jpg''']);                            else                                eval (['print -f' num2str(templateFig.Number) ' -djpeg ''' pathstr filesep fileName '_templates.jpg''']);                            end                        else                            print(templateFig,'-djpeg',[pathstr filesep fileName '_templates.jpg'])                        end                    catch                        disp('Couldn''t save a copy of the template figure.  Perhaps your version of Matlab is not current.');                    end                    EPmain.preprocess.autoClose=1;                    close(templateFig);                end            end        end %~bad subject    end %subject        if ~noFigure        [pathstr, theName, ext]=fileparts(Name);        for iChunk=1:numChunks            stemName = theName;            if numChunks > 1                stemName=[stemName '-chunk' num2str(iChunk)];            end            sameName=1;            theNumber=0;            fileName=stemName;            while sameName                sameName=0;                if exist([pathstr filesep fileName '.jpg'],'file')                    sameName=1;                end                if sameName                    theNumber=theNumber+1;                    fileName=[stemName '-' num2str(theNumber)];                end            end                        if ishandle(EPmain.preprocess.handles.butterflyFig{iChunk})                set(EPmain.preprocess.handles.butterflyFig{iChunk},'PaperPositionMode','auto');                MATLABver=ver('MATLAB');                [a b]=strtok(MATLABver.Version,'.');                b=b(2:end);                                try                    if ~isprop(EPmain.preprocess.handles.butterflyFig{iChunk},'Number')                        eval (['print -f' num2str(EPmain.preprocess.handles.butterflyFig{iChunk}) ' -djpeg ''' pathstr filesep fileName  '.jpg''']);                    else                        eval (['print -f' num2str(EPmain.preprocess.handles.butterflyFig{iChunk}.Number) ' -djpeg ''' pathstr filesep fileName  '.jpg''']);                    end                catch                    disp('Couldn''t save a copy of the artifact correction figure.  Perhaps your version of Matlab is not current.');                end                EPmain.preprocess.midFigure=0;                close(EPmain.preprocess.handles.butterflyFig{iChunk});            else                disp('Couldn''t save a copy of the artifact correction figure.  It seems to be gone.  Did you close it up with your mouse?');            end        end    end        if badDataCriteria.fMRI        suffix='_bcg';    else        suffix='_e';    end        [pathstr, name, ext] = fileparts(Name);    [fileSuffix,formatName]=ep_fileExtensions(outputFormat);        sameName=1;    theNumber=0;    fileNameSuffix=[pathstr filesep name suffix fileSuffix{1}];    while sameName        sameName=0;        if exist(fileNameSuffix,'file')            sameName=1;        end        if sameName            theNumber=theNumber+1;            fileNameSuffix=[pathstr filesep name suffix '-' num2str(theNumber) fileSuffix{1}];        end    end        ep_tictoc;if EPtictoc.stop;return;end    ep_rejoinChunks(Name, fileNameSuffix, outputFormat, numChunks, EPmain.preferences.general.specSuffix,EPmain.preferences.general.subjectSpecSuffix, varargin);        if exist('EPchunk','var') && ~isempty(EPchunk)        EPchunk=cell(0);    else        ep_tictoc('ioStart');        for iChunk = 1:numChunks            delete([Name '-' num2str(iChunk) '.mat']); %clean up temporary work files        end        ep_tictoc('ioFinish');    end        fileTime = floor(toc/60);    logMsg=['The file took ' num2str(fileTime) ' minutes to process.'];    disp(logMsg);    finalLog{end+1,1}=logMsg;    if (fileTime > (8 * 60)) && ismac        logMsg='The file took over eight hours to run.  Did you remember to turn off sleep mode?  It will turn off the Mac in the middle of a Matlab session.';        disp(logMsg);        finalLog{end+1,1}=logMsg;    end    if (fileTime > (4 * 60)) && (numChunks > 1)        logMsg='The file took over four hours to run.  Have you tried increasing the chunk size?  See the tutorial.';        disp(logMsg);        finalLog{end+1,1}=logMsg;    end    for line=1:length(finalLog)        finalLog{line}=strrep(finalLog{line},'\','\\'); %slashes are mistaken as control characters.        finalLog{line}=strrep(finalLog{line},'%','%%'); %percentages are mistaken as control characters.        fprintf(fid,[finalLog{line} '\n']);    end    finalLog=[];        if strcmp(icaFlag,'saved')        delete([pathstr filesep 'ICAresults.mat']); %clean up    end    end %sessiontheDuration=ep_tictoc('end');logMsg=['The files took an average of ' num2str((theDuration/numSessions)/60) ' minutes to process.'];disp(logMsg);fprintf(fid,[logMsg '\n']);logMsg='Done.';disp(logMsg);fprintf(fid,[logMsg '\n']);fclose(fid);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Confirms closing of the Summary pane.function closeSummary(src,event)global EPtictoc EPmainif EPmain.preprocess.autoClose    EPmain.preprocess.autoClose=0; %being closed by the artifact correction run.else    if EPmain.preprocess.midFigure        selection = questdlg('Abort the Preprocessing Run?', ...            'Confirm Closure', ...            'Yes','No','Yes');        switch selection            case 'Yes'                delete(gcf)                EPmain.preprocess.midFigure=0;                EPtictoc.stop=1;                return            case 'No'                return        end    else        delete(gcf)    endend