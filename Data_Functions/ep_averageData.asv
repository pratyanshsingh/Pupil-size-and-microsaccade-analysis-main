function EPdataOut=ep_averageData(inputFiles,inputFormat,fileType,averagingMethod,trimLevel,methodName,smoothing,multiSessionNumber,multiSubjectNumber,multiCellNumber,cfg,preferences,averageType,itemSpec,dropSD,dropNoise)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% EPdataOut=ep_averageData(inputFiles,inputFormat,fileType,averagingMethod,trimLevel,methodName,smoothing,multiSessionNumber,multiSubjectNumber,multiCellNumber,cfg,preferences,averageType,itemSpec,dropSD,dropNoise)
% Averages single trial data into subject averages or subjects averages into grand averages.
% Will refuse to operate on a factor file as it would be meaningless.  The PCA procedure already generates
% a grand average and it can also be generated via the Edit Data function.
% Can also generate spectral coherence and phase-locked output in the process of forming averages.
% Item averages will combine across subjects and also repetitions of the stimulus, but will keep separate instances from different cells or different sessions.
%
%	Reads in specified data files, averages them together using the specified method, dropping bad marked bad trials.
%   Returns an EPdata format structured variable.
%
%Inputs
%   inputFiles: cell array of file names to average.  Assumes active directory if path not specified.  (default: will ask for files)
%   inputFormat: input file format.
%   fileType: input file type.
%   averagingMethod: Type of averaging method   ('Average','Latency-Lock','Jitter-Correct','Frequency-Coherence','Frequency-Phase Lock','RIDE','ReSynch')
%   trimLevel: proportion to drop from each tail of the distribution if using trimmed means averaging.
%   methodName: Method used to carry out transformation (for averaging, 'Mean', 'Median', 'Trimmed_Mean', 'meanSME', 'meanERA').
%   smoothing: Frequency smoothing for frequency domain analysis.
%   multiSessionNumber: For when a session is spread across multiple files and its ID is encoded in the file name, example 7:9 for 7th-9th characters of 'sub001pre.ept'.
%               Needs to be an array of numbers.
%   multiSubjectNumber: For when a subject is spread across multiple files and its ID is encoded in the file name, example 4:6 for 4th-6th characters of 'sub001.ept'.
%               Needs to be an array of numbers.
%   multiCellNumber: For when each cell is in a separate file and its ID is encoded in the file name, example 8:10 for 8th-10th characters of 'sub001TAR.ept'.
%               Needs to be an array of numbers.
%   cfg: configuration structure for method-specific parameters.
%       .latencyName: For latency locking, name of trial spec with ms timing information.
%       .latencyMin: For jitter correction and latency locking, minimum allowed latency value to be included in the average in ms.
%       .latencyMax: For jitter correction and latency locking, maximum allowed latency value to be included in the average in ms.
%               Latency range specified as left to right-sided (e.g., 1 second of 250 samples could be -200 to 800ms).
%               In order for the full range to be used, there has to be sufficient space before and after the range to
%               accommodate latencies that fall at the extremes of the range.  If not, then the range will be narrowed
%               accordingly and a note will be displayed.  Simplest if even number of samples.
%       .jitterChan: For jitter, name of the channel with which to adjust for jitter.
%       .jitterPolar: For jitter, whether to check for maximum (1) or minimum (2).
%       .comp.name: For RIDE.  See RIDE documentation.
%       .comp.twd:  For RIDE.  See RIDE documentation.
%       .comp.latency:  For RIDE.  See RIDE documentation.
%       .dur:  For RIDE.  See RIDE documentation.
%       .rsChannel: For ReSynch.  Channel for component measurement or 'global' to indicate all of them.  Cell array corresponding to five windows.
%       .rsMin: For ReSynch.  Start of correction window in ms.  Cell array corresponding to five windows.
%       .rsMax: For ReSynch.  End of correction window in ms.  Cell array corresponding to five windows.
%       .behav.ACC: the trialSpecName for accuracy.
%       .behav.RT: the trialSpecName for RT.
%       .behav.dropBad: drop if bad trial.
%       .behav.dropError: drop if error trial.
%       .behav.dropTimeout: drop if timeout trial.
%       .behav.minRT: minimum RT to be a good trial.
%       .behav.maxRT: maximum SD RT to be a good trial.
%       .behav.RTmethod: method by which to calculate the averaged RT. 'Median','Mean','Trimmed Mean'
%       .behav.codeCorrect: code value for correct trials.
%       .behav.codeError: code value for error trials.
%       .behav.codeTimeout: code value for timeout trials.
%   preferences: preferences structure
%   averageType: 'subject'=subject average, 'item'=item average.
%   itemSpec: for item averages, the name of the trial spec containing the item names.
%   dropSD:     Flag to drop Trialwise SD information to save time and diskspace.  1=SD only.  2=full covariances.  3=none.
%   dropNoise:     Flag to drop noise information to save time and diskspace.
%
%Outputs
%	Returns EPdata format structured variable.
%   EPdataOut      : Structured array with the data and accompanying information.  See readData.
%                    For the meanSME and meanERA methodName options, the output is a cell array, where each cell is the path
%                    to one of the temporary files created to contain a subject's single-trial data, containing only
%                    the retained good trials, as suitable for the SME and ERA functions.
%

%  Leonowicz, Z., Karvanen, J., & Shishkin, S. L. (2005). Trimmed estimators for robust averaging of event-related
%    potentials. J Neurosci Methods, 142(1), 17-26.
%
%  Ouyang, G., Herzmann, G., Zhou, C., & Sommer, W. (2011). Residue iteration decomposition (RIDE):
%    A new method to separate ERP components on the basis of latency variability in single trials. Psychophysiology, 48(12), 1631-1647.
%
%  Ouyang, G., Sommer, W., & Zhou, C. (2015). Updating and validating a new framework for restoring and analyzing latency-variable ERP components
%    from single trials with residue iteration decomposition (RIDE). Psychophysiology, 52(6), 839-856.
%
%  Green, D. M., & Swets, J. A. (1966). Signal detection theory and psychophysics. New York: Wiley.
%
%  Stanislaw, H., & Todorov, N. (1999). Calculation of signal detection theory measures. Behav Res Methods Instrum Comput, 31(1), 137-149.
%
% History:
%
% by Joseph Dien (7/20/09)
% jdien07@mac.com
%
% bugfix 9/10/09 JD
% Crash when generating grand average from file with analysis fields.
%
% modified & bugfix 2/14/10 JD
% Changed bad channel field to negative numbers for still bad channels.  Modified averaging to deal with the possibility of
% these uncorrected bad channels.  Counts of total blink trials and movement trials for averaged waveforms include only
% good trials.  Averaging function handles possibility of no good trials for an average.
% Moved check for flat epochs to the readData function.  AvgNum and SubNum fields now calculated for grand averages.
% analysis fields no longer optional.
% Make the assumption that all the files averaged together will use the same ced file.
%
% bugfix 5/3/10 JD
% Fixed crash when generating grand average from files with more than one cell by using either mean or median methods.
%
% bugfix 5/25/10 JD
% Fixed cell names being associated with wrong waveforms when averaging data.
%
% bugfix 6/12/10 JD
% Fixed average files not being generated with .dataName field.
%
% modified 10/4/10 JD
% Now assumes that all the session files going into an average is using the same montage so doesn't keep asking for it.
%
%  modified 10/17/10 JD
%  Added support for saccadeTrials and saccadeOnset fields.
%
% modified 1/24/12 JD
% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.
%
% modified 4/13/12 JD
% Added support for averaging FFT data.
%
% bugfix 5/17/12 JD
% Completed support for bad channels by setting bad channel field to NaN in average files and handling average files
% with bad channels when computing grand averages.
%
% modified 7/15/12 JD
% Added ability to merge together session files that have different sets of cells.
%
% bugfix 8/4/12 JD
% Allow continuous files that have been frequency transformed to be averaged.
%
% bugfix 9/8/12 JD
% Fixed crash when combining multiple session files into one average file.
%
% bugfix 9/15/12 JD
% Fixed crash when combining multiple session files into one average file and there are corrected saccades in files after the first.
%
% bugfix 1/14/13 JD
% Fixed subNames and subTypes field not being a column vector when averaging multiple files, resulting in no average
% file being saved.
%
% modified 10/9/13 JD
% Added recTime field.
%
% modified 11/9/13 JD
% Default changed to mean.
%
% modified 11/19/13 JD
% Keeps all the events from the averaged data.
%
% modified 3/6/14 JD
% Fields output in standard order and with .pca, .facVar, and facVarQ.
%
% modified 3/24/14 JD
% Added .cov field.
%
% modified 4/14/14 JD
% Added .covNum field.
%
% modified 4/18/14 JD
% Allows choosing either Hanning or multi-taper methods for spectral measures.
% Eliminated upper bound to smoothing as no longer seems to apply.
%
% modified 4/24/14 JD
% Added coherence and phase-locking options and allows choosing either hanning or multi-taper methods for spectral measures.
%
% modified 6/27/14 JD
% Added latency-locked and jitter-correction averaging options.
%
% bugfix 8/4/14 JD
% Fixed crash when median averaging frequency-domain data.
%
% modified 8/31/14 JD
% Added support for adding additional keys information to events in continuous data and trial specs in single-trial
% data.
%
% bugfix 9/29/14 JD
% Fixed crash when bad channels resulted in not being able to compute
% covariance matrix.
%
% modified 10/16/14 JD
% Passes screen size to ep_readData call.
%
% bugfix 8/30/15 JD
% Changed the frequency bins so that the first one starts at the frequency
% resolution (e.g., 2hz if the bins are 2Hz wide) rather than always at 1.
%
% modified 9/4/15 JD
% Added trial specs for average files and averages their contents.
%
% bugfix 10/12/15 JD
% Fixed aborting averaging when generating a combined subject average file
% wherein one of the files after the first has more trial specs than the
% first average file.
%
% modified 3/8/16 JD
% Eliminated support for .power field.
%
% bugfix 3/15/16 JD
% Fixed crash when using jitter-correct option in Average and there are bad channels in the jitter-correct channel.
% Fixed replaced bad channels still being treated as bad by jitter-correct option in Average.
%
% bugfix 3/21/16 JD
% Fixed crash when generating a grand average with the Average function.
%
% bugfix 8/23/16 JD
% Fixed error when averaging and a cell has no good trials.
%
% modified 8/23/16 JD
% Reworked the latency-lock and the jitter-correct algorithm to operate in a more straightforward manner.
%
% bugfix 9/6/16 JD
% Fixed error when generating a grand average and there are trial specs.
%
% modified 10/16/16 JD
% Added .stims field.
%
% modified 11/7/16 JD
% Added support for reading and writing subject spec text files.
% No longer assumes subject specs are the same for all averaged files.
%
% modified 11/14/16 JD
% Added .calibration field.
%
% bugfix 3/2/17 JD
% Fixed error when generating a grand average.
% Fixed error when generating a grand average where there were no good subjects.
%
% modified 6/18/17 JD
% Added support for multi-file subjects.
% Added .timeUnits field.
% Switch to amplitude scaling when adding freq data together.
% Fixed crashes when using median or trimmed means options.
%
% bugfix 10/15/17 JD
% Fixed crash when averaging files that have different trial specs.
%
% modified 11/22/17 JD
% Added support for impedances field.
%
% bugfix 12/18/17 JD
% Fixed odd behavior due to Matlab bug in which str2num executes word strings which are function names.
% Fixed crash when generating grand average from average file without .cov
% information.
%
% modified 2/12/18 JD
% Added support for stdCM field.
%
% modified 3/28/18 JD
% Added calculation of RT and accuracy summary scores.
%
% bugfix 6/1/18 JD
% Fixed not handling case where some files to be averaged have impedance information and some do not, resulting in later crashes.
%
% bugfix 6/22/18 JD
% Fixed bug in calculation of .covNum field for FIFF files.
%
% modified 8/27/18 JD
% Added RIDE option.
%
% modified 10/18/18 JD
% Added item-averaging option.
% Fixed crash when there are multiple subject specs with the same name.
% Fixed crash when using Subject Type in Average function.
%
% bugfix 11/21/18 JD
% Fixed crash when generating a grand average from multiple combined-subject average files.
%
% modified & bugfix 4/16/19 JD
% Added support for task level performance measures.
% Fixed crash when a file has fewer trial specs than the other files in a batch averaging run.
% When timout dropping is turned off, no longer drops zero RT trials for being less than minimum RT criterion.
%
% bugfix 7/19/19 JD
% Fixed crash when either min RT or max RT fields are empty.
%
% modified 11/5/19 JD
% Added sessNums sessNames fields.
%
% modified 12/23/19 JD
% Upgraded support of std information by adding .covAVE and .GAVsubs fields and eliminating .std and .stdCM fields.
% Noise values no longer trimmed for trimmed means option.
% Changed grand average noise to be subject-wise mean of noise estimates from the first level of averaging.
% May now drop SD and/or noise information to reduce memory and time requirements.
%
% bugfix 1/21/20 JD
% Fixed crash when choosing "SD and covariances" option and there are  non-EEG channels with NaN values.
%
% bugfix 3/9/20 JD
% NaN values no longer included in means and medians.
% Fixed averaging not working when there are multiple sessions per subject.
%
% bugfix 4/12/20 JD
% Fixed crash when Drop Events option not selected.
% Fixed only grand averaging trial specs of last cell.
%
% bugfix 12/22/20 JD
% Fixed erroneous error message about multiple task codes when there were task fields left empty.
%
% bugfix & modified 12/25/20 JD
% Added cell to the single-file options in the Average function.
% Fixed crash when averaging file with no trial specs.
%
% bugfix 1/24/21 JD
% Fixed trials not being dropped correctly based on RT and ACC settings.
%
% bugfix 2/18/21 JD
% Fixed covAVE trial-level standard deviation information not handling NaN values.
%
% modified 3/9/21 JD
% Timeshifts the data via interpolation if the time points of the data going into an average file are not the same.
%
% bugfix 6/16/21 JD
% Fixed misaveraging trial specs or simply crashing when computing a grand average for a set of average files where the set of cells is variable.
%
% bugfix & modified 8/5/21 JD
% Average function now allows specs for RT and ACC to be directly specified.
% ACC codes can now be set in the Average preferences.
% Crash when using item option in Average function fixed.
% Fixed crash when using item average option in Average function and the stim trial specs are numeric.
% Fixed not computing mean or median average properly when there is only one trial.
% Fixed crash when using Average function to form grand average and the files do not contain noise data.
% Average function now retains original order of cells rather than reordering alphabetically.
%
% modified & bugfix 12/24/21 JD
% Added support for meanERA methodName.
% Fixed crash when averaging an .ept file with just one subject spec.
%
% modified & bugfix 2/21/22 JD
% Changed default data numbers to NaN and fixed crash when the resulting average has no data.
%
% modified 7/24/22 JD
% Added support for reading Matlab .mat files.
%
% modified 2/22/25 JD
% Added preliminary support for coordinate-corrected averaging.
% Added support for virtual grand averages.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Copyright (C) 1999-2025  Joseph Dien
%
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

global EPmain EPtictoc

EPdataOut=[];
ep_tictoc('begin');

if nargin < 1
    [inputFiles, activeDirectory]=ep_getFilesUI(inputFormat);
    if isempty(inputFiles)
        return
    end
    if inputFiles{1}==0
        msg{1}='No filenames selected. You have to click on a name';
        [msg]=ep_errorMsg(msg);
        return
    end
    for theFile=1:size(inputFiles,2)
        inputFiles{theFile}=[activeDirectory inputFiles{theFile}];
    end
else
    for theFile=1:size(inputFiles,2)
        [activeDirectory, name, ext] = fileparts(inputFiles{theFile});
        if isempty(activeDirectory)
            activeDirectory=pwd;
            inputFiles{theFile}=[activeDirectory filesep inputFiles{theFile}];
        end
        if ~exist(inputFiles{theFile},'file')
            msg{1}=['Error: The file ' inputFiles{theFile} ' is not in the directory.'];
            [msg]=ep_errorMsg(msg);
            return
        end
    end
end

if ~exist('averageType','var')
    averageType='subject';
end

if ~exist('itemSpec','var')
    itemSpec=[];
end

if ~isfield(cfg.behav,'RT')
    cfg.behav.RT='no RT';
end
if ~isfield(cfg.behav,'ACC')
    cfg.behav.ACC='no ACC';
end
if ~isfield(cfg.behav,'dropBad')
    cfg.behav.dropBad=0;
end
if ~isfield(cfg.behav,'dropError')
    cfg.behav.dropError=0;
end
if ~isfield(cfg.behav,'dropTimeout')
    cfg.behav.dropTimeout=0;
end
if ~isfield(cfg.behav,'minRT')
    cfg.behav.minRT=[];
end
if ~isfield(cfg.behav,'maxRT')
    cfg.behav.maxRT=[];
end
if ~isfield(cfg.behav,'RTmethod')
    cfg.behav.RTmethod='Median';
end
if ~isfield(cfg.behav,'codeCorrect')
    cfg.behav.codeCorrect='1';
end
if ~isfield(cfg.behav,'codeError')
    cfg.behav.codeError='0';
end
if ~isfield(cfg.behav,'codeTimeout')
    cfg.behav.codeTimeout='2';
end

inputFiles=inputFiles(:);
numFiles = size(inputFiles,1);
elocFlag=1; %method for handling differing elocs.

readArg{1}='format';
readArg{2}=inputFormat;
readArg{3}='screenSize';
readArg{4}=EPmain.scrsz;
readArg{5}='FontSize';
readArg{6}=EPmain.fontsize;
if ~isempty(fileType)
    readArg{7}='type';
    readArg{8}=fileType;
end
SMIsuffix=preferences.general.SMIsuffix;
if ~isempty(SMIsuffix)
    readArg{end+1}='SMIsuffix';
    readArg{end+1}=SMIsuffix;
end
specSuffix=preferences.general.specSuffix;
if ~isempty(specSuffix)
    readArg{end+1}='specSuffix';
    readArg{end+1}=specSuffix;
end
subjectSpecSuffix=preferences.general.subjectSpecSuffix;
if ~isempty(subjectSpecSuffix)
    readArg{end+1}='subjectSpecSuffix';
    readArg{end+1}=subjectSpecSuffix;
end
BVheader=preferences.general.BVheader;
if ~isempty(BVheader)
    readArg{end+1}='BVheader';
    readArg{end+1}=BVheader;
end
noInternal=preferences.general.noInternal;
if ~isempty(noInternal)
    readArg{end+1}='noInternal';
    readArg{end+1}=noInternal;
end

%assume the first session file is representative of the rest.
disp('Reading in the file(s) to determine parameters.');
Name=deblank(inputFiles{1});

disp(['Now checking file ' Name '.']);
thisReadArg=readArg;
thisReadArg{end+1}='file';
[pathstr, fileName, ext]=fileparts(Name);
thisReadArg{end+1}=Name;
[inputData, origEloc, outInfo]=ep_readData(thisReadArg);
if EPtictoc.stop;return;end
if isempty(inputData) || isempty(inputData.data)
    return;
end

[inputData]=ep_stripAdds(inputData);

if ~isempty(multiCellNumber)
    [pathstr, name, ext] = fileparts(Name);
    for iCell=1:length(inputData.cellNames)
        inputData.cellNames{iCell}=name(multiCellNumber);
    end
end

if isempty(inputData) || isempty(inputData.data)
    msg{1}=['Error: The file ' fileName ' had no data left to correct after additions were removed.'];
    [msg]=ep_errorMsg(msg);
    return
end

if (length(inputData.facNames) > 1)
    msg{1}=['Error: The file ' fileName ' is a factor file.'];
    [msg]=ep_errorMsg(msg);
    return
end

if strcmp(inputData.dataType,'continuous') && isempty(inputData.facNames)
    msg{1}=['Error: The file ' fileName ' is a continuous file.'];
    [msg]=ep_errorMsg(msg);
    return
end

if strcmp(inputData.dataType,'average') && strcmp(averagingMethod,'Frequency-Coherence')
    msg{1}=['Error: The file ' fileName ' is an average file, so coherence analysis cannot be performed upon it.'];
    [msg]=ep_errorMsg(msg);
    return
end

if~isempty(multiCellNumber) && (length(unique(inputData.cellNames))>1) && strcmp(averageType,'subject')
    msg{1}=['Error: The file ' fileName ' has more than one cell, so the multi-file cell option cannot be used.'];
    [msg]=ep_errorMsg(msg);
    return
end

if~isempty(multiSubjectNumber) && (length(unique(inputData.subNames))>1) && strcmp(averageType,'subject')
    msg{1}=['Error: The file ' fileName ' has more than one subject, so the multi-file subject option cannot be used.'];
    [msg]=ep_errorMsg(msg);
    return
end

if~isempty(multiSessionNumber) && (length(unique(inputData.sessNums))>1) && strcmp(averageType,'subject')
    msg{1}=['Error: The file ' fileName ' has more than one session, so the multi-file session option cannot be used.'];
    [msg]=ep_errorMsg(msg);
    return
end

if isfield(cfg,'latencyName') && ~isempty(cfg.latencyName)
    if ~strcmp(averagingMethod,'Latency-Lock')
        msg{1}=['Error: A trial spec name has been specified but the averaging method is not latency locking.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    theTrialSpec=find(strcmp(cfg.latencyName,inputData.trialSpecNames));
    if isempty(theTrialSpec)
        msg{1}=['Error: The file ' fileName ' does not contain the specified trial spec: ' cfg.latencyName '.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if cfg.minLatency < inputData.timeNames(1)
        msg{1}=['Error: The file ' fileName ' begins after the specified minimum latency: ' num2str(cfg.minLatency) '.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if cfg.maxLatency > inputData.timeNames(end)
        msg{1}=['Error: The file ' fileName ' ends prior to the specified maximum latency: ' num2str(cfg.maxLatency) '.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if ~strcmp(inputData.dataType,'single_trial')
        msg{1}=['Error: Latency-locked averaging can only be performed with single-trial files, which the file ' fileName ' is not.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if ~isempty(inputData.freqNames)
        msg{1}=['Error: Latency-locked averaging can only be performed with non-spectral files, which the file ' fileName ' is not.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    meanLatency(1)=mean(cell2mat(inputData.trialSpecs(find(~inputData.analysis.badTrials(1,:)),theTrialSpec)),'omitnan'); %calcualate the average latency including only non-empty values of good trials.
end

if isempty(inputData.timeNames) && strcmp(averagingMethod,'RIDE')
    msg{1}=['Error: RIDE can only be performed with files that have time points, which the file ' fileName ' does not.'];
    [msg]=ep_errorMsg(msg);
    return
end

if ~strcmp(inputData.dataType,'single_trial') && strcmp(averagingMethod,'RIDE')
    msg{1}=['Error: RIDE is only intended for single-trial data, which the file ' fileName ' is not.'];
    [msg]=ep_errorMsg(msg);
    return
end

if ~isempty(inputData.facNames) && strcmp(averagingMethod,'RIDE')
    msg{1}=['Error: RIDE is not intended for PCA data, which the file ' fileName ' is.'];
    [msg]=ep_errorMsg(msg);
    return
end

if ~isempty(inputData.relNames) && strcmp(averagingMethod,'RIDE')
    msg{1}=['Error: RIDE is not intended for relational, as in coherence, data, which the file ' fileName ' is.'];
    [msg]=ep_errorMsg(msg);
    return
end

if ~isempty(inputData.freqNames) && strcmp(averagingMethod,'RIDE')
    msg{1}=['Error: RIDE is not intended for frequency-domain data, which the file ' fileName ' is.'];
    [msg]=ep_errorMsg(msg);
    return
end

if isempty(inputData.timeNames) && strcmp(averagingMethod,'ReSynch')
    msg{1}=['Error: ReSynch can only be performed with files that have time points, which the file ' fileName ' does not.'];
    [msg]=ep_errorMsg(msg);
    return
end

if ~strcmp(inputData.dataType,'single_trial') && strcmp(averagingMethod,'ReSynch')
    msg{1}=['Error: ReSynch is only intended for single-trial data, which the file ' fileName ' is not.'];
    [msg]=ep_errorMsg(msg);
    return
end

if ~isempty(inputData.relNames) && strcmp(averagingMethod,'ReSynch')
    msg{1}=['Error: ReSynch is not intended for relational, as in coherence, data, which the file ' fileName ' is.'];
    [msg]=ep_errorMsg(msg);
    return
end

if ~isempty(inputData.freqNames) && strcmp(averagingMethod,'ReSynch')
    msg{1}=['Error: ReSynch is not intended for frequency-domain data, which the file ' fileName ' is.'];
    [msg]=ep_errorMsg(msg);
    return
end

if (elocFlag==3) && (isempty(inputData.eloc) || all(isempty([inputData.eloc(:).cX])))
    msg{1}=['Error: ' fileName ' missing required electrode information for coordinate-corrected averaging.'];
    [msg]=ep_errorMsg(msg);
    return
end

numChans=length(inputData.chanNames);
numPoints=length(inputData.timeNames);
[uniqueCells cellIndex ic]=unique(inputData.cellNames,'stable');
numCells=length(uniqueCells);
numWaves=length(inputData.cellNames);
numFacs=size(inputData.data,5); %dimensionality of the fifth dimension.  One even if no factors.
numFreqs=length(inputData.freqNames);
numCMBfacs=size(inputData.facData,5);
numRels=length(inputData.relNames);
numSpecs=length(inputData.trialSpecNames);
dataType=inputData.dataType;
sampleSize=1000/inputData.Fs;
taskNames=cell(0);

if strcmp(averagingMethod,'Jitter-Correct')
    if isempty(cfg.jitterChan)
        msg{1}=['Error: Jitter correction has been specified but no channel has been indicated.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if ~strcmp(cfg.jitterChan,inputData.chanNames)
        msg{1}=['Error: The indicated channel name(' cfg.jitterChan ') is not present in the dataset.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if ~ismember(cfg.jitterPolar,[1 2])
        msg{1}=['Error: The jitter polarity setting needs to be either 1 or 2.'];
        [msg]=ep_errorMsg(msg);
        return
    end
end

if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))
    if strcmp(inputData.dataType,'continuous')
        deltaT=min(numPoints/inputData.Fs,1); %time window in seconds
    else
        deltaT=numPoints/inputData.Fs; %time window in seconds
    end
    deltaF=1/deltaT; %frequency resolution
    cfgFreq=[];
    cfgFreq.foi=[deltaF:deltaF:inputData.Fs/2];
    numFreqs=length(cfgFreq.foi);
    numRels=numChans;


    if ~isempty(inputData.freqNames)
        msg{1}=['Error: The file ' fileName ' is already an FFT file.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    switch methodName
        case 'Hanning'
            cfgFreq.taper='hanning'; %Fieldtrip recommends Hanning for frequencies below 30Hz
            cfgFreq.method = 'mtmfft';
        case 'multi-taper'
            cfgFreq.method='mtmfft';
            if ~isempty(which('dpss'))
                cfgFreq.taper='dpss';
                if smoothing < (inputData.Fs/numPoints)
                    disp(['Increasing smoothing to minimum value allowed for dpss taper: ' num2str(inputData.Fs/numPoints)]);
                    smoothing=(inputData.Fs/numPoints);
                end
                cfgFreq.tapsmofrq=smoothing;
            else
                cfgFreq.taper='hanning';
                disp('Signal Processing Toolkit not installed so taper defaulting to Hanning');
            end
        case 'phase-lock wavelet'
            cfgFreq.method='wavelet';
            deltaT=min(.5,(numPoints/inputData.Fs)); %time window in seconds, no more than 500 ms
            resT=50; %50 ms sliding window
            deltaF=1/deltaT; %frequency resolution
            cfgFreq.foi=[deltaF:deltaF:inputData.Fs/2];
            cfgFreq.t_ftimwin    = ones(1,length(cfgFreq.foi)).*deltaT;
            cfgFreq.toi          = (inputData.timeNames(ceil(deltaT*inputData.Fs*.5)):resT:inputData.timeNames(numPoints-ceil(deltaT*inputData.Fs*.5)))/1000;
    end

    cfgFreq.feedback='none';
    cfgFreq.output = 'fourier';
    cfgFreq.pad='maxperlen';

    cfgFreq2 = [];
    cfgFreq2.complex = 'complex';

    switch averagingMethod
        case 'Frequency-Coherence'
            cfgFreq2.method = 'coh';
            disp('Using FieldTrip function ft_connectivityanalysis to perform coherence analysis.');
        case 'Frequency-Phase Lock'
            cfgFreq2.method = 'plv';
            cfgFreq2.complex = 'abs';
            disp('Using FieldTrip function ft_connectivityanalysis to perform phase locking analysis.');
    end
end

if strcmp(averagingMethod,'RIDE')
    for iComp=1:length(cfg.comp.name)
        if isempty(cfg.comp.twd{iComp}(1)) || isempty(cfg.comp.twd{iComp}(2))
            msg{1}=['Error: Both window fields of ' cfg.comp.name{iComp} ' need to be filled in with numbers.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        if ~strcmp(cfg.comp.name{iComp},'r')
            if cfg.comp.twd{iComp}(1) < inputData.timeNames(1)
                msg{1}=['Error: Start of time window of ' cfg.comp.name{iComp} ' is specified to start prior to the epoch of the data file.'];
                [msg]=ep_errorMsg(msg);
                return
            end
            if cfg.comp.twd{iComp}(2) > (inputData.timeNames(end) + sampleSize)
                msg{1}=['Error: End of time window of ' cfg.comp.name{iComp} ' is specified to end after the epoch of the data file.'];
                [msg]=ep_errorMsg(msg);
                return
            end
        end
        if cfg.comp.twd{iComp}(2) <= cfg.comp.twd{iComp}(1)
            msg{1}=['Error: End of time window of ' cfg.comp.name{iComp} ' needs to be a larger number than the start of it.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        switch cfg.comp.name{iComp}
            case 's'
                if cfg.comp.latency{iComp} < inputData.timeNames(1)
                    msg{1}=['Error: Latency of ' cfg.comp.name{iComp} ' is specified for before the epoch of the data file.'];
                    [msg]=ep_errorMsg(msg);
                    return
                end
                if cfg.comp.latency{iComp} > (inputData.timeNames(end) + sampleSize)
                    msg{1}=['Error: Latency of ' cfg.comp.name{iComp} ' is specified for after the epoch of the data file.'];
                    [msg]=ep_errorMsg(msg);
                    return
                end
            case {'c1','c2'}
                cfg.comp.latency{iComp}='unknown';
            case 'r'

            otherwise
                disp('oops')
        end
    end
    disp('Using RIDE function (Ouyang, Herzmann, Zhou, & Sommer, 2011; Ouyang, Sommer, & Zhou, 2015)');
    disp('Note that RIDE is not designed to handle trialwise bad channels so only global bad channels will be excluded.')
    disp('If this is a problem, you should first use the Preprocessing function to interpolate the bad channels.')
    cfg.samp_interval=sampleSize;
    cfg.epoch_twd=[inputData.timeNames(1) (inputData.timeNames(end) + sampleSize)];
end

if strcmp(averagingMethod,'ReSynch')
    for iComp=1:length(cfg.rsMin)
        if xor(isempty(cfg.rsMin{iComp}),isempty(cfg.rsMax{iComp}))
            msg{1}=['Error: Both window fields of Window ' num2str(iComp) ' need to either be filled in with numbers or be empty.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        if cfg.rsMin{iComp} < inputData.timeNames(1)
            msg{1}=['Error: Start of time window of ' num2str(iComp) ' is specified to start prior to the epoch of the data file.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        if cfg.rsMax{iComp} > (inputData.timeNames(end) + sampleSize)
            msg{1}=['Error: End of time window of ' num2str(iComp) ' is specified to end after the epoch of the data file.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        if cfg.rsMax{iComp} <= cfg.rsMin{iComp}
            msg{1}=['Error: End of time window of ' num2str(iComp) ' needs to be a larger number than the start of it.'];
            [msg]=ep_errorMsg(msg);
            return
        end
    end
    disp('Using ReSynch function (Ouyang, submitted)');
    disp('Note that ReSynch is not designed to handle trialwise bad channels so only global bad channels will be excluded.')
    disp('If this is a problem, you should first use the Preprocessing function to interpolate the bad channels.')
end

EPdata=ep_newFile;
EPdata.fileFormat = inputData.fileFormat;
EPdata.montage = inputData.montage;
EPdata.chanNames = inputData.chanNames;
if strcmp(averagingMethod,'Frequency-Coherence')
    EPdata.timeNames = [];
    EPdata.Fs = inputData.Fs;
elseif strcmp(averagingMethod,'Frequency-Phase Lock')
    EPdata.timeNames=cfgFreq.toi'*1000;
    EPdata.freqNames=cfgFreq.foi';
    EPdata.Fs = 20;
else
    EPdata.timeNames=inputData.timeNames;
    EPdata.freqNames=inputData.freqNames;
    EPdata.Fs = inputData.Fs;
end

EPdata.cellNames = unique(inputData.cellNames,'stable');
if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))
    EPdata.relNames = inputData.chanNames;
else
    EPdata.relNames = [];
end
EPdata.cellTypes = inputData.cellTypes(cellIndex);
EPdata.chanTypes= inputData.chanTypes;
EPdata.timeUnits= inputData.timeUnits;
EPdata.facNames= inputData.facNames;
EPdata.facTypes = inputData.facTypes;
EPdata.facVecT = inputData.facVecT;
EPdata.facVecS = inputData.facVecS;
EPdata.facVecF = inputData.facVecF;
EPdata.facData = inputData.facData;
EPdata.reference = inputData.reference;

EPdata.baseline = inputData.baseline;
if EPdata.baseline==0
    disp('Note: the baseline equals zero.  The cov parameter will not be calculated correctly, if later desired for MNE analysis.');
end
EPdata.ename = inputData.ename;
EPdata.dataName = inputData.dataName;
EPdata.trialSpecNames = inputData.trialSpecNames;
EPdata.ced = inputData.ced;
EPdata.eloc = inputData.eloc;
EPdata.implicit = inputData.implicit;
EPdata.history = inputData.history;
% EPdata.history{end+1} = {'ep_averageData',inputFiles,inputFormat,fileType,averagingMethod,trimLevel,methodName,smoothing,cfg,multiSessionNumber,multiSubjectNumber,multiCellNumber};
if length(inputFiles) == 1
    EPdata.fileName = inputData.fileName;
else
    EPdata.fileName = 'average';
end
EPdata.dataType=inputData.dataType;
EPdata.stims = inputData.stims;
aveNames=cell(0);
sessNames=cell(0);
elocs=cell(0);
implicits=cell(0);

if strcmp(averageType,'item')
    cellNames=unique(inputData.cellNames,'stable');
    %a difference of item versus subject averages is that with the former there may be repetitions of a stimulus that should then be averaged together, unless they were in separate sessions.
    aveNames=cell(0);
    for iSub=1:size(inputData.subNames)
        if ~isempty(multiSessionNumber)
            [pathstr, name, ext] = fileparts(fileName);
            theSess=name(multiSessionNumber);
        else
            if ~isempty(inputData.sessNums)
                if inputData.sessNums(iSub)
                    theSess=inputData.sessNames{inputData.sessNums(iSub)};
                else
                    theSess='n/a';
                end
            else
                theSess='n/a';
            end
        end
        for iSpec=1:size(inputData.trialSpecs,1)
            theAve=num2str(inputData.trialSpecs{iSpec,find(strcmp(itemSpec,inputData.trialSpecNames))});
            theItem=find(all([strcmp(theAve,aveNames) strcmp(theSess,sessNames)]')); %matches subject/session combination already in list.
            if isempty(aveNames) || isempty(theItem) %else add  the subject/session combination to the list
                aveNames{end+1,1}=theAve;
                sessNames{end+1,1}=theSess;
            end
        end
    end
    subCellIndex=zeros(numFiles,length(inputData.subNames),length(aveNames),length(cellNames));  %index of number of trials with dimensions of file, subject, unique item/subject, and unique cell.
    for iItem=1:length(aveNames)
        for iCell=1:length(cellNames)
            for iSub=1:length(inputData.subNames)
                if ~strcmp(sessNames{iSub},'n/a') && strcmp(sessNames{iSub},inputData.sessNames{inputData.sessNums(iSub)})
                    subCellIndex(1,iSub,iItem,iCell)=length(find(strcmp(aveNames{iItem},inputData.trialSpecs(strcmp(cellNames{iCell},inputData.cellNames),find(strcmp(itemSpec,inputData.trialSpecNames)),iSub))));
                end
            end
        end
    end
else
    if ~isempty(multiCellNumber)
        [pathstr, name, ext] = fileparts(Name);
        for iCell=1:length(inputData.cellNames)
            inputData.cellNames{iCell}=name(multiCellNumber);
        end
    end
    cellNames=unique(inputData.cellNames,'stable');
    if ~isempty(multiSubjectNumber)
        [pathstr, name, ext] = fileparts(Name);
        aveNames{1}=name(multiSubjectNumber);
    else
        aveNames=inputData.subNames;
    end
    elocs{1}=inputData.eloc;
    implicits{1}=inputData.implicit;

    subCellIndex=zeros(numFiles,length(inputData.subNames),length(inputData.subNames),numCells);
    for iCell=1:length(cellNames)
        theCellCount=length(find(strcmp(cellNames{iCell},inputData.cellNames)));
        for iSub=1:length(inputData.subNames)
            subCellIndex(1,iSub,iSub,iCell)=theCellCount;
        end
    end

    if ~isempty(multiSessionNumber)
        [pathstr, name, ext] = fileparts(Name);
        sessNames{1}=name(multiSessionNumber);
    else
        for iSub=1:length(inputData.subNames)
            if ~isempty(inputData.sessNums)
                theSess=inputData.sessNums(iSub);
                if theSess
                    sessNames{iSub}=inputData.sessNames(theSess);
                else
                    sessNames{iSub}='n/a';
                end
            else
                sessNames{iSub}='n/a';
            end
        end
    end
end

for theFile=2:numFiles
    ep_tictoc;if EPtictoc.stop;return;end
    Name2=deblank(inputFiles{theFile});
    disp(['Now checking file ' Name2 '.']);
    thisReadArg2=readArg;
    thisReadArg2{end+1}='file';
    thisReadArg2{end+1}=Name2;
    thisReadArg2{end+1}='silent';
    thisReadArg2{end+1}='on';
    thisReadArg2{end+1}='ced';
    thisReadArg2{end+1}=inputData.ced; %assume all the files averaged together will be using the same ced file.
    thisReadArg2{end+1}='montage';
    thisReadArg2{end+1}=inputData.montage; %assume all the files averaged together will be using the same montage.
    if strcmp(inputFormat,'matlab_mat')
        thisReadArg2{end+1}='matlabDims';
        thisReadArg2{end+1}=outInfo.matlabDims;
    end
    %     deleteFlag=find(strcmp('noInternal',thisReadArg2));
    %     if ~isempty(deleteFlag)
    %         thisReadArg2(deleteFlag:deleteFlag+1)=[];
    %     end
    [data2, origEloc, outInfo]=ep_readData(thisReadArg2);
    if EPtictoc.stop;return;end
    if isempty(data2) || isempty(data2.data)
        return
    end
    [data2]=ep_stripAdds(data2);
    if isempty(data2) || isempty(data2.data)
        return
    end
    if ~isequal(inputData.chanNames,data2.chanNames)
        msg{1}=['Error: The file ' inputFiles{theFile} ' has a different set of electrodes from' inputFiles{1} '.'];
        msg{2}=['If this is a file format that has internal electrode coordinates, like .set, you may need to override them by using the No Internal option under File Preferences so you can use a CED file to fill in the missing channels.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    %     if (numPoints ~= length(data2.timeNames))
    %         msg{1}=['Error: The file ' inputFiles{theFile} ' has a different length epoch.'];
    %         [msg]=ep_errorMsg(msg);
    %         return
    %     end
    if (length(data2.facNames) > 1)
        msg{1}=['Error: The file ' inputFiles{theFile} ' is a factor file.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if (length(inputData.facNames) ~= length(data2.facNames))
        msg{1}=['Error: The file ' inputFiles{theFile} ' has a different set of factors.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if ((length(inputData.freqNames) ~= length(data2.freqNames)))
        msg{1}=['Error: The file ' inputFiles{theFile} ' has a different number of frequencies.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if isempty(data2.data)
        msg{1}=['Error: The file ' inputFiles{theFile} ' had no data left to correct after additions were removed.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if ~strcmp(inputData.dataType,data2.dataType)
        msg{1}=['Error: The file ' inputFiles{theFile} ' is not the same type of data file as ' inputFiles{1} '.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if~isempty(multiCellNumber) && (length(unique(data2.cellNames))>1)
        msg{1}=['Error: The file ' inputFiles{theFile} ' has more than one cell, so the multi-file cell option cannot be used.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if~isempty(multiSubjectNumber) && (length(unique(data2.subNames))>1)
        msg{1}=['Error: The file ' inputFiles{theFile} ' has more than one subject, so the multi-file subject option cannot be used.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if~isempty(multiSessionNumber) && (length(unique(data2.sessNums))>1)
        msg{1}=['Error: The file ' inputFiles{theFile} ' has more than one session, so the multi-file session option cannot be used.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if isfield(cfg,'latencyName')
        if isempty(find(strcmp(cfg.latencyName,data2.trialSpecNames)))
            msg{1}=['Error: The file ' inputFiles{theFile} ' does not contain the specified trial spec: ' cfg.latencyName '.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        if cfg.minLatency < data2.timeNames(1)
            msg{1}=['Error: The file ' inputFiles{theFile} ' begins after the specified minimum latency: ' num2str(cfg.minLatency) '.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        if cfg.maxLatency > data2.timeNames(end)
            msg{1}=['Error: The file ' inputFiles{theFile} ' ends prior to the specified maximum latency: ' num2str(cfg.maxLatency) '.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        if ~strcmp(data2.dataType,'single_trial')
            msg{1}=['Error: Latency-locked averaging can only be performed with single-trial files, which the file file ' inputFiles{theFile} ' is not.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        if ~isempty(data2.freqNames)
            msg{1}=['Error: Latency-locked averaging can only be performed with non-spectral files, which the file ' inputFiles{theFile} ' is not.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        theTrialSpec=find(strcmp(cfg.latencyName,data2.trialSpecNames));
        meanLatency(theFile)=mean(cell2mat(data2.trialSpecs{find(~data2.analysis.badTrials(1,:)),theTrialSpec}),'omitnan');
    end

    if isempty(data2.timeNames) && strcmp(averagingMethod,'RIDE')
        msg{1}=['Error: RIDE can only be performed with files that have time points, which the file ' inputFiles{theFile} ' does not.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    if ~strcmp(data2.dataType,'single_trial') && strcmp(averagingMethod,'RIDE')
        msg{1}=['Error: RIDE is only intended for single-trial data, which the file ' inputFiles{theFile} ' is not.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    if ~isempty(data2.facNames) && strcmp(averagingMethod,'RIDE')
        msg{1}=['Error: RIDE is not intended for PCA data, which the file ' inputFiles{theFile} ' is.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    if ~isempty(data2.freqNames) && strcmp(averagingMethod,'RIDE')
        msg{1}=['Error: RIDE is not intended for frequency-domain data, which the file ' inputFiles{theFile} ' is.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    if ~isempty(data2.relNames) && strcmp(averagingMethod,'RIDE')
        msg{1}=['Error: RIDE is not intended for relational, as in coherence, data, which the file ' inputFiles{theFile} ' is.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    if ~isempty(data2.freqNames) && strcmp(averagingMethod,'ReSynch')
        msg{1}=['Error: ReSynch is not intended for frequency-domain data, which the file ' inputFiles{theFile} ' is.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    if ~isempty(data2.relNames) && strcmp(averagingMethod,'ReSynch')
        msg{1}=['Error: ReSynch is not intended for relational, as in coherence, data, which the file ' inputFiles{theFile} ' is.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    if (elocFlag==3) && (isempty(data2.eloc) || all(isempty([data2.eloc(:).cX])))
        msg{1}=['Error: ' inputFiles{theFile} ' missing required electrode information for coordinate-corrected averaging.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    if ~isempty(multiCellNumber)
        [pathstr, name, ext] = fileparts(inputFiles{theFile});
        for iCell=1:length(data2.cellNames)
            data2.cellNames{iCell}=name(multiCellNumber);
        end
    end

    if ~isempty(setdiff(data2.cellNames,inputData.cellNames))
        [newCells,ia]=setdiff(data2.cellNames,EPdata.cellNames);
        EPdata.cellNames(end+1:end+length(newCells),1)=newCells;
        EPdata.cellTypes(end+1:end+length(newCells),1)=data2.cellTypes(ia);
        numCells=numCells+length(newCells);
    end

    cellList=unique(data2.cellNames,'stable');
    for iTrial=1:length(data2.trialNames)
        ep_tictoc;if EPtictoc.stop;return;end
        for iCell=1:length(cellList)
            for iSub=1:length(data2.subNames)
                theCell=cellList{iCell};
                if strcmp(averageType,'item')
                    theAve=num2str(data2.trialSpecs{iTrial,find(strcmp(itemSpec,data2.trialSpecNames)),1});
                else
                    if ~isempty(multiSubjectNumber)
                        [pathstr, name, ext] = fileparts(Name2);
                        theAve=name(multiSubjectNumber);
                    else
                        theAve=data2.subNames{iSub};
                    end
                end
                if ~isempty(multiSessionNumber)
                    [pathstr, name, ext] = fileparts(Name2);
                    theSess=name(multiSessionNumber);
                else
                    if ~isempty(data2.sessNums)
                        if data2.sessNums(iSub)
                            theSess=data2.sessNames{data2.sessNums(iSub)};
                        else
                            theSess='n/a';
                        end
                    else
                        theSess='n/a';
                    end
                end
                if ~any(strcmp(theCell,cellNames))
                    cellNames{end+1}=theCell;
                    subCellIndex(:,:,:,end+1)=0;
                end
                theSub=find(all([strcmp(theAve,aveNames) strcmp(theSess,sessNames)]')); %matches subject/session combination already in list.
                if isempty(theSub) %else add  the subject/session combination to the list
                    aveNames{end+1,1}=theAve;
                    sessNames{end+1,1}=theSess;
                    subCellIndex(:,:,end+1,:)=0;
                    theSub=length(aveNames);
                    elocs{end+1}=data2.eloc;
                    implicits{end+1}=data2.implicit;
                end
                subCellIndex(theFile,iSub,theSub,find(strcmp(theCell,cellNames)))=subCellIndex(theFile,iSub,theSub,find(strcmp(theCell,cellNames)))+1;
            end
        end
    end
end
EPdata.dataType='average';

numOutAves=length(aveNames); %the total number of unique subjects/items in the output file.
[uniqueCells cellIndex ic]=unique(EPdata.cellNames,'stable');

if any(strcmp(methodName,{'meanSME','meanERA'}))
    SMEoutFiles=cell(numOutAves,1);
end

if any(strcmp(dataType,{'continuous','single_trial'})) %form average files
    EPdata.events = cell(numOutAves,numCells);
    EPdata.subjectSpecNames = inputData.subjectSpecNames; %assume all the files have the same set of subject specs as the first file.
    if ~any(strcmp('fileName',EPdata.subjectSpecNames)) && (strcmp(averageType,'subject') || ~isempty(multiSessionNumber))
        EPdata.subjectSpecNames{end+1,1}='fileName';
    end

    %if using latency-locked or jitter-correction averaging, width of resulting epoch will be equal to the period before the left side of the range and the period after the right side of the range.
    if any(strcmp(averagingMethod,{'Latency-Lock','Jitter-Correct'}))
        minPadSamples=round(100/sampleSize); %if range is not specified, default to having 100 ms before and after the new zero point so latency range is 100 ms shy of start and end of epoch
        if (isempty(cfg.minLatency) || isempty(cfg.maxLatency)) && (numPoints < minPadSamples*2)
            msg{1}=['Error: Epoch is too short for default latency range of at least 100 ms before and after the zero point.'];
            [msg]=ep_errorMsg(msg);
            return
        end
        if isempty(cfg.minLatency)
            cfg.minLatency=inputData.timeNames(minPadSamples+1);
        else
            cfg.minLatency=inputData.timeNames(min(find(inputData.timeNames>=cfg.minLatency)));
        end
        if isempty(cfg.maxLatency)
            cfg.maxLatency=inputData.timeNames(end-minPadSamples);
        else
            cfg.maxLatency=inputData.timeNames(max(find(inputData.timeNames<=cfg.maxLatency-sampleSize))); %convert to left-sided sample times
        end
        leftRangeSample=find(inputData.timeNames == cfg.minLatency); %sample of start of latency range (inclusive)
        rightRangeSample=find(inputData.timeNames == cfg.maxLatency); %sample of end of latency range (inclusive)
        leftRange=leftRangeSample-1; %number of samples to left of latency-lock.
        rightRange=numPoints-rightRangeSample; %number of samples to right of latency-lock.
        epochPoints=leftRange+rightRange;
        numPoints=leftRange+rightRange; %update size of range in samples
        EPdata.timeNames=[-leftRange:rightRange-1]'*sampleSize;
        EPdata.baseline=leftRange;
    end

    if strcmp(averagingMethod,'Frequency-Coherence')
        EPdata.data=nan(numChans,1,numCells,numOutAves,numFacs,max(numFreqs,1),numChans);
    elseif strcmp(averagingMethod,'Frequency-Phase Lock')
        EPdata.data=nan(numChans,max(length(EPdata.timeNames),1),numCells,numOutAves,numFacs,max(length(EPdata.freqNames),1),numChans);
    else
        EPdata.data=nan(numChans,max(numPoints,1),numCells,numOutAves,numFacs,max(numFreqs,1),1);
        if ~dropNoise
            EPdata.noise=nan(numChans,max(numPoints,1),numCells,numOutAves,numFacs);
        end
        if isempty(inputData.relNames)
            switch dropSD
                case 1 %SD only
                    EPdata.covAVE=NaN(numChans,max(numPoints,1),numCells,numOutAves,numFacs,max(numFreqs,1),1);
                case 2 %covariances
                    EPdata.covAVE=NaN(numChans,max(numPoints,1),numCells,numOutAves,numFacs,max(numFreqs,1),numChans);
                case 3 %none
                    EPdata.covAVE=[];
                otherwise
                    disp('oops.  Programmer error in ep_averageData.  dropSD option not recognized.')
                    return
            end
        else
            EPdata.covAVE=[];
        end
    end
    EPdata.cov.covMatrix=NaN(numOutAves,numChans,numChans);
    EPdata.cov.Nq=NaN;

    fprintf('%60s\n',' ' );
    for iAve = 1:numOutAves
        fprintf('Working on %4d of %4d: %s.\n', iAve, numOutAves, aveNames{iAve})
        if any(strcmp(methodName,{'meanSME','meanERA'}))
            SMEgoodList=[];
        end
        subFilesList=find(squeeze(mean(mean(subCellIndex(:,:,iAve,:),4,'omitnan'),2,'omitnan'))); %the list of files that have this unique subject/item
        for iFile=1:length(subFilesList)
            ep_tictoc;if EPtictoc.stop;return;end
            theFile=subFilesList(iFile);
            Name=deblank(inputFiles{theFile});
            [pathstr, fileName, ext]=fileparts(Name);

            if (iFile == 1) && (iAve == 1)
                tempData=inputData; %since sublist is in 'stable' order the first one will always be the first file, already loaded.
            else
                thisReadArg=readArg;
                thisReadArg{end+1}='file';
                thisReadArg{end+1}=Name;
                thisReadArg{end+1}='silent';
                thisReadArg{end+1}='on';
                thisReadArg{end+1}='ced';
                thisReadArg{end+1}=EPdata.ced; %assume all the files averaged together will be using the same ced file.
                thisReadArg{end+1}='montage';
                thisReadArg{end+1}=EPdata.montage; %assume all the files averaged together will be using the same montage.
                SMIsuffix=preferences.general.SMIsuffix;
                if ~isempty(SMIsuffix)
                    thisReadArg{end+1}='SMIsuffix';
                    thisReadArg{end+1}=SMIsuffix;
                end
                specSuffix=preferences.general.specSuffix;
                if ~isempty(specSuffix)
                    thisReadArg{end+1}='specSuffix';
                    thisReadArg{end+1}=specSuffix;
                end
                subjectSpecSuffix=preferences.general.subjectSpecSuffix;
                if ~isempty(subjectSpecSuffix)
                    thisReadArg{end+1}='subjectSpecSuffix';
                    thisReadArg{end+1}=subjectSpecSuffix;
                end
                if strcmp(inputFormat,'matlab_mat')
                    thisReadArg{end+1}='matlabDims';
                    thisReadArg{end+1}=outInfo.matlabDims;
                end
                [tempData, origEloc, outInfo]=ep_readData(thisReadArg);
                if EPtictoc.stop;return;end
                if isempty(tempData) || isempty(tempData.data)
                    msg{1}=['Error: Something went wrong with:' Name];
                    [msg]=ep_errorMsg(msg);
                    return
                end
                if ~isempty(multiCellNumber)
                    [pathstr, name, ext] = fileparts(Name);
                    for iCell=1:length(tempData.cellNames)
                        tempData.cellNames{iCell}=name(multiCellNumber);
                    end
                end
            end
            [tempData]=ep_stripAdds(tempData);
            if isempty(tempData) || isempty(tempData.data)
                msg{1}=['Error: Something went wrong with:' Name];
                [msg]=ep_errorMsg(msg);
                return
            end

            if ~isempty(inputData.timeNames) && ~isempty(setxor(inputData.timeNames,tempData.timeNames))
                disp(['Adjusting timing for ' Name ' to match that of the first file.']);
                [tempData]=ep_interpTime(tempData,inputData.timeNames);
                ep_tictoc;if EPtictoc.stop;return;end
                if isempty(tempData)
                    msg{1}=['Error: The file ' Name ' was unable to be time shifted.'];
                    [msg]=ep_errorMsg(msg);
                    return
                end
            end
            if (elocFlag==3)
                hasLocsOld=find(~cellfun(@isempty,{inputData.eloc.X}));
                hasLocsNew=find(~cellfun(@isempty,{inputData.eloc.cX}));
                [sevenDdata]=ep_interpChans(inputData.data(hasLocsOld,:,:,:,:,:,:,:), oldElocs(hasLocsOld), inputData.eloc(hasLocsNew));
                if isempty(sevenDdata)
                    msg{1}=['Error: The file ' Name ' was unable to be coordinate-corrected.'];
                    [msg]=ep_errorMsg(msg);
                    return
                end
                inputData.data(hasLocsNew,:,:,:,:,:,:,:)=sevenDdata;
            end
            if (iFile > 1) && ~isempty(inputData)
                if strcmp(averageType,'item')
                    %keep only the trials with the right stimulus name, figure out the session part later.
                    cellList=find(strcmp(aveNames{iAve},cellfun(@num2str,tempData.trialSpecs(:,find(strcmp(itemSpec,tempData.trialSpecNames)),1),'UniformOutput',false)));
                else
                    cellList=[1:length(tempData.cellNames)];
                end
                cellList=intersect(cellList,find(ismember(tempData.cellNames,cellNames(find(subCellIndex(theFile,1,iAve,:))))));%keep only the desired cells.
                if ~isempty(cellList)
                    %if there is more than one file with this info, concatenate them into a single file first
                    inputData=ep_addData(inputData,ep_selectData(tempData,{[],[],[cellList],[],[],[]}),'cells');
                    if isempty(inputData)
                        msg{1}=['Error: Something went wrong with:' Name];
                        [msg]=ep_errorMsg(msg);
                        return
                    end
                end
            else
                if strcmp(averageType,'item')
                    %keep only the trials with the right stimulus name, figure out the session part later.
                    cellList=find(strcmp(aveNames{iAve},cellfun(@num2str,tempData.trialSpecs(:,find(strcmp(itemSpec,tempData.trialSpecNames)),1),'UniformOutput',false)));
                else
                    cellList=[1:length(tempData.cellNames)];
                end
                cellList=intersect(cellList,find(ismember(tempData.cellNames,cellNames(find(subCellIndex(theFile,1,iAve,:))))));%keep only the desired cells.
                if ~isempty(cellList)
                    inputData=ep_selectData(tempData,{[],[],[cellList],[],[],[]});
                else
                    inputData=[];
                end
            end
        end
        if ~isempty(multiSubjectNumber)
            theSubName=['sub' aveNames{iAve}];
        else
            theSubName=aveNames{iAve};
        end
        theSessName=sessNames{iAve};
        EPdata.subNames{iAve,1}=theSubName;
        EPdata.subTypes{iAve,1}='AVG';
        if ~any(strcmp(theSessName,EPdata.sessNames))
            EPdata.sessNames{end+1,1}=theSessName;
        end
        EPdata.sessNums(iAve,1)=find(strcmp(theSessName,EPdata.sessNames));
        [pathstr, name, ext] = fileparts(inputData.fileName);
        for iSpec=1:length(inputData.subjectSpecs)
            theSpec=max(find(strcmp(inputData.subjectSpecNames{iSpec},EPdata.subjectSpecNames)));
            if ~isempty(theSpec)
                EPdata.subjectSpecs{iAve,theSpec}=inputData.subjectSpecs{iSpec};
            else
                EPdata.subjectSpecNames{end+1}=inputData.subjectSpecNames{iSpec};
                EPdata.subjectSpecs{iAve,end+1}=inputData.subjectSpecs{iSpec};
            end
        end
        theSpec=find(strcmp('fileName',EPdata.subjectSpecNames));
        if ~isempty(theSpec)
            EPdata.subjectSpecs{iAve,theSpec}=[name ext];
        end

        newStims=find(~ismember({inputData.stims.name},{EPdata.stims.name}));
        if ~isempty(newStims)
            EPdata.stims(end+1:end+length(newStims)) = inputData.stims(newStims);
        end

        if ~isempty(inputData.impedances.channels)
            EPdata.impedances.channels(:,iAve)=inputData.impedances.channels;
        elseif ~isempty(EPdata.impedances.channels)
            EPdata.impedances.channels(:,iAve)=NaN;
        end
        if ~isempty(inputData.impedances.ground)
            EPdata.impedances.ground(iAve,1)=inputData.impedances.ground;
        elseif ~isempty(EPdata.impedances.ground)
            EPdata.impedances.ground(iAve,1)=NaN;
        end

        sigDet=zeros(length(taskNames),numCells,4); %table of signal detection information (hits, false alarms, rejects, misses)

        for iCell=1:numCells
            ep_tictoc;if EPtictoc.stop;return;end
            theCell=uniqueCells{iCell}; %in SME mode, output is trials not cells.
            if ~ismember(theCell,inputData.cellNames)
                theGoodTrials=[];
            else
                theTrials=find(strcmp(theCell,inputData.cellNames));
                badTrials=zeros(1,length(theTrials));
                theGoodTrials=theTrials;
                theSpecTrials=theGoodTrials; %the trials that will be used to calculate the RT and accuracy scores

                if cfg.behav.dropBad
                    badTrials=theTrials(find(inputData.analysis.badTrials(1,theTrials)));
                    if ~isempty(badTrials)
                        disp([theCell ': Dropped ' num2str(length(badTrials)) ' trials due to bad trials.']);
                    end
                end

                if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))
                    %bad channels are very problematic.  To keep the data for each coherence calculation consistent,
                    %will need to drop trials with any bad channels at all.
                    badTrials=union(badTrials,any(inputData.analysis.badChans(1,theTrials,:)==-1,3));
                end

                EPdata.analysis.badTrials(iAve,iCell)= length(badTrials);

                if strcmp(averagingMethod,'Jitter-Correct')
                    %if jitter-correcting, then trials with a bad jitter channel must be counted as bad.
                    badJitter=theTrials(find(squeeze(inputData.analysis.badChans(iAve,theTrials,find(strcmp(cfg.jitterChan,inputData.chanNames)))==-1)));
                    if ~isempty(badJitter)
                        disp([theCell ': Dropped ' num2str(length(badJitter)) ' trials due to bad jitter channels.']);
                    end
                    badTrials=union(badTrials,badJitter);
                end
                theGoodTrials=setdiff(theGoodTrials,badTrials);

                if isfield(cfg,'latencyName') && ~isempty(cfg.latencyName) %if using latency-locking, drop trials where the spec is empty or outside the bounds of the latency range
                    theTrialSpec=find(strcmp(cfg.latencyName,inputData.trialSpecNames));
                    theNonEmptySpecs=find(~cellfun(@isempty,inputData.trialSpecs(theGoodTrials,theTrialSpec)));
                    numGood=length(theGoodTrials);
                    theGoodTrials=intersect(theGoodTrials,theGoodTrials(theNonEmptySpecs)); %drop trials where the spec is empty
                    theGoodTrials=theGoodTrials(find([inputData.trialSpecs{theGoodTrials,theTrialSpec}]>=cfg.minLatency));
                    theGoodTrials=theGoodTrials(find([inputData.trialSpecs{theGoodTrials,theTrialSpec}]<=cfg.maxLatency));
                    numBad=numGood-length(theGoodTrials);
                    if numBad>0
                        disp([theCell ': Dropped ' num2str(numBad) ' trials due to bad latency values.']);
                    end
                end

                theACCspec=find(strcmp(cfg.behav.ACC,inputData.trialSpecNames));
                if length(theACCspec) > 1
                    theACCspec=theACCspec(1); %if there are multiple specs with the same name, match to the first one.
                end
                theRTspec=find(strcmp(cfg.behav.RT,inputData.trialSpecNames));
                if length(theRTspec) > 1
                    theRTspec=theRTspec(1); %if there are multiple specs with the same name, match to the first one.
                end
                theTaskSpec=find(strcmp('EPtask',inputData.trialSpecNames));
                if length(theTaskSpec) > 1
                    theTaskSpec=theTaskSpec(1); %if there are multiple specs with the same name, match to the first one.
                end

                %drop trials based on accuracy scores
                if ~isempty(theACCspec) && (cfg.behav.dropError || cfg.behav.dropTimeout)
                    theACCSpecs=inputData.trialSpecs(theGoodTrials,theACCspec);
                    theStrSpecs=find(cellfun(@ischar,theACCSpecs));
                    for iStrSpec=1:length(theStrSpecs)
                        theStrSpec=theStrSpecs(iStrSpec);
                        if strcmp(theACCSpecs{theStrSpec},cfg.behav.codeCorrect)
                            theACCSpecs{theStrSpec}=1;
                        else
                            theACCSpecs{theStrSpec}=str2double(theACCSpecs{theStrSpec});
                        end
                    end
                    ACClist=cell2mat(theACCSpecs);
                    dropTrials=[];
                    if cfg.behav.dropError
                        dropTrials=find(theGoodTrials(ACClist==0));
                    end
                    if cfg.behav.dropTimeout
                        dropTrials=union(dropTrials,find(theGoodTrials(ACClist==2)));
                    end
                    theGoodTrials(dropTrials)=[];
                    if ~isempty(dropTrials)
                        disp([theCell ': Dropped ' num2str(length(dropTrials)) ' trials due to accuracy scores.']);
                    end
                end

                %drop trials based on RT scores
                if ~isempty(theRTspec) && (~isempty(cfg.behav.minRT) || ~isempty(cfg.behav.maxRT))
                    theRTSpecs=inputData.trialSpecs(theGoodTrials,theRTspec);
                    theStrSpecs=find(cellfun(@ischar,theRTSpecs));
                    for iStrSpec=1:length(theStrSpecs)
                        theStrSpec=theStrSpecs(iStrSpec);
                        theRTSpecs{theStrSpec}=str2double(theRTSpecs{theStrSpec});
                    end
                    RTlist=cell2mat(theRTSpecs);
                    dropTrials=[];
                    if ~isempty(cfg.behav.minRT)
                        dropTrials=find(theGoodTrials((RTlist<cfg.behav.minRT)&(RTlist~=0)));
                    end
                    if ~isempty(cfg.behav.maxRT)
                        dropTrials=union(dropTrials,find(theGoodTrials(((RTlist-mean(RTlist,'omitnan'))/std(RTlist))>cfg.behav.maxRT)));
                    end
                    theGoodTrials(dropTrials)=[];
                    if ~isempty(dropTrials)
                        disp([theCell ': Dropped ' num2str(length(dropTrials)) ' trials due to RT scores.']);
                    end
                end

                EPdata.analysis.blinkTrial(iAve,iCell)= sum(inputData.analysis.blinkTrial(1,theGoodTrials));
                EPdata.analysis.saccadeTrial(iAve,iCell)= sum(inputData.analysis.saccadeTrial(1,theGoodTrials));
                if EPdata.analysis.saccadeTrial(iAve,iCell) == 0
                    EPdata.analysis.saccadeOnset(iAve,iCell)=0;
                else
                    EPdata.analysis.saccadeOnset(iAve,iCell)=sum(inputData.analysis.saccadeOnset(1,theGoodTrials))/inputData.analysis.saccadeTrial(1,iCell); %compute average saccade onset
                end

                EPdata.analysis.saccadeOnset(iAve,iCell)= sum(inputData.analysis.saccadeOnset(1,theGoodTrials));
                EPdata.analysis.moveTrial(iAve,iCell)= sum(inputData.analysis.moveTrial(1,theGoodTrials));
                for iChan=1:numChans
                    if all(inputData.analysis.badChans(1,theGoodTrials,iChan) < 0) %if the channel is bad for all the available good trials
                        EPdata.analysis.badChans(iAve,iCell,iChan) = NaN;
                    else
                        EPdata.analysis.badChans(iAve,iCell,iChan)= sum(inputData.analysis.badChans(1,theGoodTrials,iChan).*(inputData.analysis.badChans(1,theGoodTrials,iChan)>0),2); %only good channels
                    end
                end
            end

            if any(strcmp(methodName,{'meanSME','meanERA'}))
                theGoodTrials=intersect(theGoodTrials,find(squeeze(all(all(~isnan(inputData.data),1),2)))); %drop any trials with NaN as SME can't handle them.
                SMEgoodList=[SMEgoodList; theGoodTrials];
            else
                if isempty(theGoodTrials) %if no good trials for this cell, fill out values and move on
                    EPdata.analysis.blinkTrial(iAve,iCell)=0;
                    EPdata.analysis.saccadeTrial(iAve,iCell)=0;
                    EPdata.analysis.saccadeOnset(iAve,iCell)=0;
                    EPdata.analysis.moveTrial(iAve,iCell)=0;
                    EPdata.analysis.badTrials(iAve,iCell)=0;
                    EPdata.analysis.badChans(iAve,iCell,1:numChans)=NaN;
                    EPdata.avgNum(iAve,iCell)=-1;
                    EPdata.subNum(iAve,iCell)=-1;
                    EPdata.covNum(iAve,iCell)=-1;
                    if strcmp(averagingMethod,'Frequency-Coherence')
                        EPdata.data(:,:,iCell,iAve,:,:,:)=NaN(numChans,1,1,1,numFacs,max(numFreqs,1),numChans);
                    elseif strcmp(averagingMethod,'Frequency-Phase Lock')
                        EPdata.data(:,:,iCell,iAve,:,:,:)=NaN(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),numChans);
                    else
                        EPdata.data(:,:,iCell,iAve,:,:,:)=NaN(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1));
                        if ~dropNoise
                            EPdata.noise(:,:,iCell,iAve,:)=NaN(numChans,max(numPoints,1),1,1,numFacs);
                        end
                    end
                    switch dropSD
                        case 1 %SD only
                            EPdata.covAVE(:,:,iCell,iAve,:,:)=NaN(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),1);
                        case 2 %covariances
                            EPdata.covAVE(:,:,iCell,iAve,:,:)=NaN(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),numChans);
                        case 3 %none
                        otherwise
                            disp('oops.  Programmer error in ep_averageData.  dropSD option not recognized.')
                            return
                    end
                    EPdata.recTime(iCell)=1;
                    if numSpecs > 0
                        EPdata.trialSpecs{iCell,numSpecs,iAve}=[];
                    end
                    if strcmp(averageType,'subject')
                        disp(['Warning: The cell ' EPdata.cellNames{iCell} ' for ' fileName ' has zero trials.']);
                    end
                    continue
                end

                EPdata.recTime(iCell)=min(inputData.recTime(theGoodTrials));
                numTrials=length(theGoodTrials);
                EPdata.avgNum(iAve,iCell)=numTrials;
                EPdata.subNum(iAve,iCell)=1;
                EPdata.covNum(iAve,iCell)=numTrials;

                switch averagingMethod
                    %first build a new version of the data matrix (per cell) with the appropriate time-shifting
                    case {'Average','Latency-Lock','Jitter-Correct'}
                        shiftedData=zeros(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),1);
                        for iFactor = 1:numFacs
                            for iFreq = 1:max(numFreqs,1)
                                for iTrial=1:numTrials
                                    ep_tictoc;if EPtictoc.stop;return;end
                                    theTrial=theGoodTrials(iTrial);
                                    if strcmp(averagingMethod,'Latency-Lock')
                                        theLockSample=floor(inputData.trialSpecs{theTrial,theTrialSpec}/sampleSize)+inputData.baseline+1;
                                        thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];
                                    elseif strcmp(averagingMethod,'Jitter-Correct')
                                        thePoints=[leftRangeSample:rightRangeSample];
                                        if cfg.jitterPolar==1
                                            [a,theLockSample]=max(inputData.data(strcmp(cfg.jitterChan,inputData.chanNames),thePoints,theTrial,:,iFactor,iFreq));
                                        else
                                            [a,theLockSample]=min(inputData.data(strcmp(cfg.jitterChan,inputData.chanNames),thePoints,theTrial,:,iFactor,iFreq));
                                        end
                                        theLockSample=theLockSample+leftRangeSample-1;
                                        thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];
                                    else
                                        thePoints=[1:numPoints];
                                        if isempty(thePoints)
                                            thePoints=1;
                                        end
                                    end
                                    shiftedData(:,:,iTrial,:,iFactor,iFreq)=inputData.data(:,thePoints,theTrial,:,iFactor,iFreq);
                                end
                            end
                        end
                        for iChan = 1:numChans
                            ep_tictoc;if EPtictoc.stop;return;end
                            chanGoodTrials=theGoodTrials(find(inputData.analysis.badChans(1,theGoodTrials,iChan) > -1));
                            numChanGoodTrials=length(chanGoodTrials);
                            if numChanGoodTrials==0 %if the channel is bad for all the available good trials
                                EPdata.data(iChan,:,iCell,iAve,:,:)=NaN(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));
                                switch dropSD
                                    case 1 %SD only
                                        EPdata.covAVE(iChan,:,iCell,iAve,:,:,:)=NaN(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1),1);
                                    case 2 %covariances
                                        EPdata.covAVE(iChan,:,iCell,iAve,:,:,:)=NaN(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1),numChans);
                                    case 3 %none
                                    otherwise
                                        disp('oops.  Programmer error in ep_averageData.  dropSD option not recognized.')
                                        return
                                end
                                if ~dropNoise
                                    EPdata.noise(iChan,:,iCell,iAve,:)=zeros(1,max(numPoints,1),1,1,numFacs);
                                end
                            else
                                if strcmp(methodName,'Trimmed_Mean')
                                    trimTrials=floor(numChanGoodTrials*trimLevel);
                                end
                                theSigns=ones(numChanGoodTrials,1);
                                if numChanGoodTrials > 1
                                    theSigns(2:2:end)=-1;
                                end
                                for iFactor = 1:numFacs
                                    for iFreq = 1:max(numFreqs,1)
                                        theData=zeros(numChanGoodTrials,max(numPoints,1));
                                        if ~dropNoise
                                            noiseData=zeros(numChanGoodTrials,max(numPoints,1));
                                        end
                                        for iTrial=1:numChanGoodTrials
                                            theData(iTrial,:)=shiftedData(iChan,:,iTrial,:,iFactor,iFreq);
                                            if ~dropNoise
                                                noiseData(iTrial,:)=theSigns(iTrial)*shiftedData(iChan,thePoints,iTrial,:,iFactor,iFreq);
                                            end
                                        end
                                        if isempty(EPdata.freqNames) && ~dropNoise
                                            EPdata.noise(iChan,:,iCell,iAve,iFactor,:)=mean(noiseData,1,'omitnan');
                                        end
                                        if ~isempty(inputData.freqNames) && any(strcmp(inputData.chanTypes{iChan},{'EEG','REG'}))
                                            theData=abs(theData); %convert to amplitude scaling when adding freq data together since it can't be assumed that the different epochs are phase-aligned.
                                        end
                                        switch methodName
                                            case 'Mean'
                                                EPdata.data(iChan,:,iCell,iAve,iFactor,iFreq)=mean(theData,1,'omitnan');
                                            case 'Median'
                                                EPdata.data(iChan,:,iCell,iAve,iFactor,iFreq)=median(theData,1,'omitnan');
                                            case 'Trimmed_Mean'
                                                for iPoint = 1:max(numPoints,1)
                                                    sortedValues=sort(theData(:,iPoint));
                                                    EPdata.data(iChan,iPoint,iCell,iAve,iFactor,iFreq)=mean(sortedValues(trimTrials+1:numChanGoodTrials-trimTrials),1,'omitnan');
                                                end
                                            otherwise
                                                disp('oops - programming error in averageData.')
                                                return
                                        end
                                    end
                                end
                            end
                        end

                        if isempty(inputData.relNames) && (dropSD<3)
                            %the covariance matrix is not affected by median or trimmed mean operations.  They are computed the same as the mean operation.
                            for iFactor = 1:numFacs
                                for iFreq = 1:max(numFreqs,1)
                                    %compute channel variances
                                    for iChan = 1:numChans
                                        for iPoint=1:max(numPoints,1)
                                            chanGoodTrials=find(inputData.analysis.badChans(1,theGoodTrials,iChan) > -1);
                                            if dropSD==1
                                                EPdata.covAVE(iChan,iPoint,iCell,iAve,iFactor,iFreq,1)=std(squeeze(shiftedData(iChan,iPoint,chanGoodTrials,1,iFactor,iFreq)),'omitnan');
                                            else
                                                EPdata.covAVE(iChan,iPoint,iCell,iAve,iFactor,iFreq,iChan)=var(squeeze(shiftedData(iChan,iPoint,chanGoodTrials,1,iFactor,iFreq)),'omitnan');
                                            end
                                        end
                                    end
                                    if dropSD==2
                                        %compute channel covariances
                                        for iChan = 1:numChans
                                            ep_tictoc;if EPtictoc.stop;return;end
                                            chanGoodTrials=find(inputData.analysis.badChans(1,theGoodTrials,iChan) > -1);
                                            for iChan2=iChan+1:numChans
                                                %can't just compute cov pairwise because the cov matrix would end up being degenerate when there are bad channels in some of the trials
                                                %instead computing R pairwise on channels and then reweight with the variances.  This is the equivalent of missing data imputation based on the intact data.
                                                chanGoodTrials2=find(inputData.analysis.badChans(1,theGoodTrials,iChan2) > -1);
                                                bothChanGoodTrials=intersect(chanGoodTrials,chanGoodTrials2);
                                                if ~isempty(bothChanGoodTrials)
                                                    for iPoint=1:max(numPoints,1)
                                                        chanData1=squeeze(shiftedData(iChan,iPoint,bothChanGoodTrials,1,iFactor,iFreq));
                                                        chanData2=squeeze(shiftedData(iChan2,iPoint,bothChanGoodTrials,1,iFactor,iFreq));
                                                        std1=std(chanData1,'omitnan');
                                                        std2=std(chanData2,'omitnan');
                                                        if ~isnan(std1) && ~isnan(std2) && std1 && std2
                                                            theCor=corrcoef([chanData1 chanData2]);
                                                            theCov=theCor(2,1)*sqrt(EPdata.covAVE(iChan,iPoint,iCell,iAve,iFactor,iFreq,iChan))*sqrt(EPdata.covAVE(iChan2,iPoint,iCell,iAve,iFactor,iFreq,iChan2));
                                                        else
                                                            theCov=0; %correlation with zeros, as in the reference, result in NaN
                                                        end
                                                        EPdata.covAVE(iChan,iPoint,iCell,iAve,iFactor,iFreq,iChan2)=theCov;
                                                        EPdata.covAVE(iChan2,iPoint,iCell,iAve,iFactor,iFreq,iChan)=theCov;
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        %add events and adjust latency values if necessary
                        for iTrial=1:numChanGoodTrials
                            ep_tictoc;if EPtictoc.stop;return;end
                            theTrial=theGoodTrials(iTrial);
                            for iEvent=1:length(inputData.events{1,theTrial})
                                if isfield(cfg,'latencyName') %if using latency-locking, drop events outside the latency range and adjust the event sample
                                    eventSample=inputData.events{1,theTrial}(iEvent).sample;
                                    theLockSample=floor(inputData.trialSpecs{theTrial,theTrialSpec}/sampleSize)+inputData.baseline+1;
                                    thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];
                                    if ismember(eventSample,thePoints)
                                        EPdata.events{iAve,iCell}(end+1)=inputData.events{1,theTrial}(iEvent);
                                        EPdata.events{iAve,iCell}(end).sample=EPdata.events{iAve,iCell}(end).sample-thePoints(1)+1;
                                    end
                                else
                                    EPdata.events{iAve,iCell}(end+1)=inputData.events{1,theTrial}(iEvent);
                                end
                            end
                        end
                    case 'Frequency-Coherence'
                        %bad channels are very problematic.  To keep the data for each coherence calculation consistent,
                        %will need to drop trials with any bad channels at all.

                        fprintf('Applying coherence transform to cell #%4d of %4d\n', iCell, numCells)
                        for iFactor = 1:numFacs
                            ftData=ep_ep2ft(ep_selectData(inputData,{[],[],theGoodTrials,[],iFactor,[]}));
                            if ~isempty(ftData)
                                evalc('[freq] = ft_freqanalysis(cfgFreq,ftData);'); %amplitude spectrum
                                evalc('coh = ft_connectivityanalysis(cfgFreq2, freq);');

                                for iFreq=1:length(coh.freq)
                                    EPdata.data(:,1,iCell,iAve,iFactor,iFreq,:) = squeeze(coh.cohspctrm(:,:,iFreq));
                                end
                            end
                        end
                    case 'Frequency-Phase Lock'
                        %bad channels are very problematic.  To keep the data for each coherence calculation consistent,
                        %will need to drop trials with any bad channels at all.

                        fprintf('Applying phase locking transform to cell #%4d of %4d\n', iCell, numCells)
                        for iFactor = 1:numFacs
                            ftData=ep_ep2ft(ep_selectData(inputData,{[],[],theGoodTrials,[],iFactor,[]}));
                            if ~isempty(ftData)
                                evalc('[freq] = ft_freqanalysis(cfgFreq,ftData);'); %amplitude spectrum
                                evalc('plv = ft_connectivityanalysis(cfgFreq2, freq);');
                                if ~isfield(plv,'time')
                                    msg{1}=['The attempt to run the phase locking analysis resulted in the error:' lasterr];
                                    [msg]=ep_errorMsg(msg);
                                    return
                                else
                                    for iPoint=1:length(plv.time)
                                        for iFreq=1:length(plv.freq)
                                            EPdata.data(:,iPoint,iCell,iAve,iFactor,iFreq,:) = squeeze(plv.plvspctrm(:,:,iFreq,iPoint));
                                        end
                                    end
                                end
                            end
                        end
                        if isempty(EPdata.freqNames)
                            EPdata.freqNames=freq.freq; %assuming they are the same for all the data
                        end
                    case 'RIDE'
                        fprintf('Applying RIDE to cell #%4d of %4d\n', iCell, numCells)
                        EEGchans=find(strcmp('EEG',inputData.chanTypes));
                        badChans=find(inputData.analysis.badChans(iAve,iCell,:)==-1);
                        chans = setdiff(EEGchans,badChans);
                        cfg2=cfg;
                        rComp=find(strcmp(cfg.comp.name,'r'));
                        if isempty(theRTspec) && ~isempty(rComp)
                            disp(['Warning: The file ' Name ' does not have reaction time data so R will not be computed for it.'])
                            cfg2.comp.name(rComp) = [];
                            cfg2.comp.twd(rComp) = [];
                            cfg2.comp.latency(rComp) = [];
                        else
                            cfg2.comp.latency{rComp}=cellfun(@str2double,inputData.trialSpecs(theGoodTrials,theRTspec));
                        end
                        cfg3 = RIDE_cfg(cfg2);
                        %RIDE is not designed to handle bad channels so all trialwise bad channels will be included.  Bad channel replacement is recommended.
                        %The unique nature of the RIDE algorithm does not support generation of the std and noise fields.
                        switch dropSD
                            case 1 %SD only
                                EPdata.covAVE(iChan,:,iCell,iAve,:,:,:)=NaN(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1),1);
                            case 2 %covariances
                                EPdata.covAVE(iChan,:,iCell,iAve,:,:,:)=NaN(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1),numChans);
                            case 3 %none
                            otherwise
                                disp('oops.  Programmer error in ep_averageData.  dropSD option not recognized.')
                                return
                        end
                        if ~dropNoise
                            EPdata.noise(:,:,iCell,iAve,:)=zeros(numChans,max(numPoints,1),1,1,numFacs);
                        end
                        theData=squeeze(inputData.data(chans,:,theGoodTrials,1,1,1));
                        theData=permute(theData,[2,1,3]);
                        evalc('RIDEresults = RIDE_call(theData,cfg3);');
                        EPdata.data(chans,:,iCell,iAve,:,1)=RIDEresults.erp_new';
                        for iTrial=1:length(theGoodTrials)
                            theTrial=theGoodTrials(iTrial);
                            for iEvent=1:length(inputData.events{1,theTrial})
                                EPdata.events{iAve,iCell}(end+1)=inputData.events{1,theTrial}(iEvent);
                            end
                        end
                    case 'ReSynch'
                        fprintf('Applying ReSynch to cell #%4d of %4d\n', iCell, numCells)
                        %ReSynch is not designed to handle bad channels so all trialwise bad channels will be included.  Bad channel replacement is recommended.
                        %The unique nature of the ReSynch algorithm does not support generation of the std and noise fields.
                        switch dropSD
                            case 1 %SD only
                                EPdata.covAVE(:,:,iCell,iAve,:,:,:)=NaN(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),1);
                            case 2 %covariances
                                EPdata.covAVE(:,:,iCell,iAve,:,:,:)=NaN(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),numChans);
                            case 3 %none
                            otherwise
                                disp('oops.  Programmer error in ep_averageData.  dropSD option not recognized.')
                                return
                        end
                        if ~dropNoise
                            EPdata.noise(:,:,iCell,iAve,:)=zeros(numChans,max(numPoints,1),1,1,numFacs);
                        end

                        cfg2 = [];
                        cfg2.epoch_twd = [inputData.timeNames(1),inputData.timeNames(end)+round(1000/inputData.Fs)]; %in millisecond
                        cfg2.base_twd = [inputData.timeNames(1),0];

                        for iFactor = 1:numFacs
                            [ALLEEGin]=ep_ep2alleeg(ep_selectData(inputData,{[],[],theGoodTrials,iAve,iFactor,[]}));
                            for iEEG=1:length(ALLEEGin)
                                EEGin=ALLEEGin(iEEG);
                                for iTrial=1:size(EEGin.data,3)
                                    EEGin.event(end+1).type='EP_ReSync';
                                    EEGin.event(end).value=ALLEEGin(iEEG).condition;
                                    EEGin.event(end).latency=(iTrial-1)*ALLEEGin(iEEG).pnts+inputData.baseline+1;
                                    EEGin.event(end).duration=0;
                                    EEGin.event(end).epoch=iTrial;
                                end
                                for iWindow=1:5
                                    if ~isempty(cfg.rsMin{iWindow}) && ~isempty(cfg.rsMax{iWindow})
                                        cfg2.resync_twd = [cfg.rsMin{iWindow},cfg.rsMax{iWindow}];
                                        if cfg.rsChannel{iWindow}==1
                                            cfg2.selected_elec = 'global';
                                            cfg2.glb = 1;
                                        else
                                            theChannel=cfg.rsChannel{iWindow}-1;
                                            if theChannel > length(inputData.chanNames)
                                                msg{1}=['ReSynch failed.  The selected channel number was larger than that available in the dataset.  Perhaps the data did not match the model data.'];
                                                [msg]=ep_errorMsg(msg);
                                                return
                                            else
                                                cfg2.selected_elec = inputData.chanNames(theChannel);
                                            end
                                            cfg2.glb = 0;
                                        end
                                        cfg2.selected_marker = 'EP_ReSync';
                                        try
                                            evalc('EEGout = RS_resyncERP(EEGin,cfg2);');
                                        catch ME
                                            msg{1}=['ReSynch failed.  The error message was:' ME.identifier];
                                            msg{2}=ME.message;
                                            [msg]=ep_errorMsg(msg);
                                            return
                                        end
                                        EEGin=EEGout;
                                    end
                                end

                                for iChan = 1:numChans
                                    ep_tictoc;if EPtictoc.stop;return;end
                                    chanGoodTrials=find(inputData.analysis.badChans(1,theGoodTrials,iChan) > -1);
                                    numChanGoodTrials=length(chanGoodTrials);
                                    if numChanGoodTrials==0 %if the channel is bad for all the available good trials
                                        EPdata.data(iChan,:,iCell,iAve,:,:)=NaN(1,max(numPoints,1),1,1,numFacs,1);
                                    else
                                        if strcmp(methodName,'Trimmed_Mean')
                                            trimTrials=floor(numChanGoodTrials*trimLevel);
                                        end

                                        theData=zeros(numChanGoodTrials,max(numPoints,1));
                                        if any(strcmp(inputData.chanTypes(iChan),{'EEG','REG'}))
                                            for iTrial=1:numChanGoodTrials
                                                theTrial=chanGoodTrials(iTrial);
                                                theData(iTrial,:)=EEGout.data(iChan,:,theTrial);
                                            end
                                        else
                                            theData(iTrial,:)=inputData.data(iChan,:,iCell,iAve,iFactor,:,:);
                                        end
                                        switch methodName
                                            case 'Mean'
                                                EPdata.data(iChan,:,iCell,iAve,iFactor,1)=mean(theData,1,'omitnan');
                                            case 'Median'
                                                EPdata.data(iChan,:,iCell,iAve,iFactor,1)=median(theData,1,'omitnan');
                                            case 'Trimmed_Mean'
                                                for iPoint = 1:max(numPoints,1)
                                                    sortedValues=sort(theData(:,iPoint));
                                                    EPdata.data(iChan,iPoint,iCell,iAve,iFactor,1)=mean(sortedValues(trimTrials+1:numChanGoodTrials-trimTrials),1,'omitnan');
                                                end
                                            otherwise
                                                disp('oops - programming error in averageData.')
                                                return
                                        end
                                    end
                                end
                            end
                        end

                    otherwise
                        msg{1}=['Error: The averaging method ' averagingMethod ' is not recognized.'];
                        [msg]=ep_errorMsg(msg);
                        return
                end

                %generate the accuracy and RT summary scores based on all trials not just the good ones
                goodRTs=theSpecTrials;
                ACClist=[];
                if ~isempty(theACCspec) && ~isempty(theSpecTrials)
                    EPdata.trialSpecs{iCell,theACCspec,iAve}=nan;
                    theACCSpecs=inputData.trialSpecs(theSpecTrials,theACCspec);
                    theStrSpecs=find(cellfun(@ischar,theACCSpecs));
                    for iStrSpec=1:length(theStrSpecs)
                        theStrSpec=theStrSpecs(iStrSpec);
                        theACCSpecs{theStrSpec}=str2double(theACCSpecs{theStrSpec});
                    end
                    ACClist=cell2mat(theACCSpecs);
                    if ~isempty(ACClist)
                        keepACC=find((ACClist==1)|(ACClist==0));
                        ACClist=ACClist(keepACC);
                        theSpecTrials=theSpecTrials(keepACC);
                        goodRTs=goodRTs(ACClist==1); %compute summary RT number based only on correct trials.
                    else
                        theSpecTrials=[];
                        goodRTs=[];
                    end
                end
                goodACCs=theSpecTrials;
                if ~isempty(theRTspec) && ~isempty(theSpecTrials)
                    theSpecs=inputData.trialSpecs(goodRTs,theRTspec);
                    theStrSpecs=find(cellfun(@ischar,theSpecs));
                    for iStrSpec=1:length(theStrSpecs)
                        theStrSpec=theStrSpecs(iStrSpec);
                        theSpecs{theStrSpec}=str2double(theSpecs{theStrSpec});
                    end
                    RTlist=cell2mat(theSpecs); %RT numbers based only on correct trials.
                    if ~isempty(RTlist)
                        %drop premature responses
                        if cfg.behav.minRT ~=0
                            badRTs=goodRTs((RTlist<cfg.behav.minRT)&(RTlist~=0));
                            goodRTs(RTlist<cfg.behav.minRT)=[];
                            RTlist(RTlist<cfg.behav.minRT)=[];
                            if ~isempty(ACClist)
                                ACClist=ACClist(~ismember(goodACCs,badRTs));
                            end
                            goodACCs=setdiff(goodACCs,badRTs);
                        end
                        if ~isempty(RTlist)
                            %drop outlier slow responses not including premature responses
                            if cfg.behav.maxRT ~=0
                                badRTs=goodRTs(((RTlist-mean(RTlist,'omitnan'))/std(RTlist))>cfg.behav.maxRT);
                                goodRTs(((RTlist-mean(RTlist,'omitnan'))/std(RTlist))>cfg.behav.maxRT)=[];
                                RTlist(((RTlist-mean(RTlist,'omitnan'))/std(RTlist))>cfg.behav.maxRT)=[];
                                if ~isempty(ACClist)
                                    ACClist=ACClist(~ismember(goodACCs,badRTs));
                                end
                                goodACCs=setdiff(goodACCs,badRTs);
                            end
                        end
                    end
                end
                summaryRT=nan;
                summaryACC=nan;
                if ~isempty(goodRTs) && ~isempty(theRTspec)
                    switch cfg.behav.RTmethod
                        case 'Median'
                            summaryRT=median(RTlist);
                        case 'Mean'
                            summaryRT=mean(RTlist,'omitnan');
                        case 'Trimmed Mean'
                            trimTrials=floor(length(RTlist)*trimLevel);
                            summaryRT=mean(trimTrials+1:length(RTlist)-trimTrials,'omitnan');
                        otherwise
                            %oops, not a valid option.
                    end
                end
                if ~isempty(goodACCs) && ~isempty(theACCspec)
                    summaryACC=mean(ACClist,'omitnan');
                end

                %generate the signal detection summary statistics
                if ~isempty(theTaskSpec) && ~isempty(ACClist)
                    goodTasks=goodACCs; %don't include premature responses.
                    taskList=inputData.trialSpecs(goodTasks,theTaskSpec);
                    if any(~cellfun(@isempty,taskList))
                        taskList=taskList(~cellfun(@isempty,taskList)); %ignore trials where EPtask is empty.
                        if ~all(strcmp(taskList{1},taskList))
                            disp(['Error - there were multiple task names for cell ' num2str(iCell) '.'])
                        else
                            taskName=taskList{1};
                            if ~any(strcmp(taskName(end),{'-','+'}))
                                disp(['Error - the task name for cell ' num2str(iCell) ' did not end in a + or a -.'])
                            else
                                if ~any(strcmp(taskName(1:end-1),taskNames))
                                    taskNames{end+1}=taskName(1:end-1);
                                end
                                theTask=find(strcmp(taskName(1:end-1),taskNames));
                                if strcmp(taskName(end),'+')
                                    sigDet(theTask,iCell,1)=length(find(ACClist==1)); %hits
                                    sigDet(theTask,iCell,4)=length(find(ACClist==0)); %misses
                                elseif strcmp(taskName(end),'-')
                                    sigDet(theTask,iCell,2)=length(find(ACClist==0)); %false alarms
                                    sigDet(theTask,iCell,3)=length(find(ACClist==1)); %rejects
                                end
                            end
                        end
                    end
                end

                %generate the averaged trial specs
                for iSpec=1:length(inputData.trialSpecNames)
                    theSpec=find(strcmp(inputData.trialSpecNames{iSpec},EPdata.trialSpecNames));
                    if length(theSpec) > 1
                        theSpec=theSpec(1); %if there are multiple specs with the same name, match to the first one.
                    end
                    if isempty(theSpec)
                        EPdata.trialSpecNames{end+1}=inputData.trialSpecNames{iSpec};
                        theSpec=length(EPdata.trialSpecNames);
                    end
                    if strcmp(inputData.trialSpecNames{iSpec},'RT')
                        EPdata.trialSpecs{iCell,theSpec,iAve}=summaryRT;
                    elseif strcmp(inputData.trialSpecNames{iSpec},'ACC')
                        EPdata.trialSpecs{iCell,theSpec,iAve}=summaryACC;
                    elseif ischar(inputData.trialSpecs{theGoodTrials(1),iSpec}) && all(strcmp(inputData.trialSpecs{theGoodTrials(1),iSpec},inputData.trialSpecs(theGoodTrials,iSpec)))
                        EPdata.trialSpecs{iCell,theSpec,iAve}=inputData.trialSpecs{1,iSpec};
                    else
                        theSpecs=inputData.trialSpecs(theGoodTrials,iSpec);
                        theStrSpecs=find(cellfun(@ischar,theSpecs));
                        for iStrSpec=1:length(theStrSpecs)
                            theStrSpec=theStrSpecs(iStrSpec);
                            theSpecs{theStrSpec}=str2double(theSpecs{theStrSpec});
                        end
                        EPdata.trialSpecs{iCell,theSpec,iAve}=mean(cell2mat(theSpecs),'omitnan');
                    end
                end
            end

            %apply .calibration to eye location channels
            if isfield(EPdata.calibration,'ET') && isfield(EPdata.calibration.ET,'Xzero') && isfield(EPdata.calibration.ET,'Yzero') && isfield(EPdata.calibration.ET,'Xscale') && isfield(EPdata.calibration.ET,'Yscale')
                XEYchan=find(strcmp('XEY',EPdata.chanTypes));
                if length(XEYchan) > 1
                    XEYchan=XEYchan(1);
                end
                YEYchan=find(strcmp('YEY',EPdata.chanTypes));
                if length(YEYchan) > 1
                    YEYchan=YEYchan(1);
                end
                EPdata.data(XEYchan,:,:,iAve,:,:,:)=(EPdata.data(XEYchan,:,:,iAve,:,:,:)-EPdata.calibration.ET.Xzero)/EPdata.calibration.ET.Xscale;
                EPdata.data(YEYchan,:,:,iAve,:,:,:)=(EPdata.data(YEYchan,:,:,iAve,:,:,:)-EPdata.calibration.ET.Yzero)/EPdata.calibration.ET.Yscale;
            end
            if isfield(EPdata.calibration,'SAC') && isfield(EPdata.calibration.SAC,'Xzero') && isfield(EPdata.calibration.SAC,'Yzero') && isfield(EPdata.calibration.SAC,'Xscale') && isfield(EPdata.calibration.SAC,'Yscale')
                XEYchan=find(strcmp('Hsaccade',EPdata.chanNames));
                if length(XEYchan) > 1
                    XEYchan=XEYchan(1);
                end
                YEYchan=find(strcmp('Vsaccade',EPdata.chanNames));
                if length(YEYchan) > 1
                    YEYchan=YEYchan(1);
                end
                EPdata.data(XEYchan,:,:,iAve,:,:,:)=(EPdata.data(XEYchan,:,:,iAve,:,:,:)-EPdata.calibration.SAC.Xzero)/EPdata.calibration.SAC.Xscale;
                EPdata.data(YEYchan,:,:,iAve,:,:,:)=(EPdata.data(YEYchan,:,:,iAve,:,:,:)-EPdata.calibration.SAC.Yzero)/EPdata.calibration.SAC.Yscale;
            end

            %calculate the .cov field
            if isempty(inputData.facNames) %doesn't make sense to calculate for PCA data.
                if isempty(inputData.cov)
                    EPdata.cov.covMatrix(iAve,:,:)=NaN(numChans,numChans);
                    EPdata.cov.Nq(iAve)=NaN;
                    if isempty(inputData.freqNames)
                        goodChans=setdiff([1:numChans],any(isnan(squeeze(inputData.analysis.badChans(1,:,:))))); %if channel entirely bad in any of the cells, then leave out of cov calculation
                        covData=[];
                        EEGchans=find(strcmp('EEG',inputData.chanTypes));
                        for iCell=1:length(inputData.cellNames)
                            if ~any(inputData.analysis.badChans(1,iCell,goodChans) < 0) && ~inputData.analysis.badTrials(1,iCell)
                                theData=squeeze(inputData.data(goodChans,:,iCell,1,:,:));
                                if inputData.baseline
                                    theData=theData-diag(squeeze(mean(theData(:,1:round(inputData.baseline)),2,'omitnan')))*ones(length(goodChans),size(theData,2)); %baseline the data prior to calculating the cov matrix
                                end
                                theData=theData-ones(length(goodChans),size(theData,2))*diag(squeeze(mean(theData,1))); %average reference prior to cov calculation
                                covData=[covData, theData];
                            end
                        end
                        if ~isempty(covData)
                            Nq=size(covData,2);
                            EPdata.cov.covMatrix(iAve,goodChans,goodChans)=(covData*covData')./Nq; %per MNE recommended procedure, the cov is calculated as an SSCP matrix where the variables have been baseline corrected for each epoch.
                            EPdata.cov.Nq(iAve)=Nq; %degrees of freedom, for weighting cov matrices when later combined.
                        end
                    end
                else
                    EPdata.cov.covMatrix(iAve,:,:)=inputData.cov.covMatrix; %per MNE recommended procedure, the cov is calculated as an SSCP matrix where the variables have been baseline corrected for each epoch.
                    EPdata.cov.Nq(iAve)=inputData.cov.Nq; %degrees of freedom, for weighting cov matrices when later combined.
                end
            end
            if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock','RIDE','ReSynch'}))
                fprintf('%60s\n',' ' );
            end

            %signal detection
            if ~isempty(sigDet)
                if ~any(strcmp('D-Prime',EPdata.taskMeasNames))
                    EPdata.taskMeasNames{end+1}='D-Prime';
                end
                if iAve==1
                    disp('Using dprime function written by Martin Backmann-Barthel.');
                end
                theDprime=find(strcmp('D-Prime',EPdata.taskMeasNames));
                if ~any(strcmp('c',EPdata.taskMeasNames))
                    EPdata.taskMeasNames{end+1}='c';
                end
                theC=find(strcmp('c',EPdata.taskMeasNames));
                if ~any(strcmp('taskACC',EPdata.taskMeasNames))
                    EPdata.taskMeasNames{end+1}='taskACC';
                end
                theAcc=find(strcmp('taskACC',EPdata.taskMeasNames));
                for iTask=1:length(taskNames)
                    nTarget=(sum(sigDet(iTask,:,1))+sum(sigDet(iTask,:,4)));
                    pHit=sum(sigDet(iTask,:,1))/nTarget;
                    nDistract=(sum(sigDet(iTask,:,2))+sum(sigDet(iTask,:,3)));
                    pFA=sum(sigDet(iTask,:,2))/nDistract;
                    [dpri,ccrit] = dprime(pHit,pFA,nTarget,nDistract);
                    if ~any(strcmp(taskNames{iTask},EPdata.taskNames))
                        EPdata.taskNames{end+1}=taskNames{iTask};
                    end
                    theTask=find(strcmp(taskNames{iTask},EPdata.taskNames));
                    EPdata.taskSpecs(iAve,theTask,theAcc)=pHit;
                    EPdata.taskSpecs(iAve,theTask,theDprime)=dpri;
                    EPdata.taskSpecs(iAve,theTask,theC)=ccrit;
                end
            end
        end
        if any(strcmp(methodName,{'meanSME','meanERA'}))
            EPdata=ep_selectData(inputData,{[],[],SMEgoodList,[],[],[]});
            EPdata.subNames{1}=['sub' aveNames{iAve}];
            sameName=1;
            theNumber=0;
            fileName=['EPtempSME' num2str(iAve)];

            fileNameStem=fileName;
            while sameName
                sameName=0;
                if exist([activeDirectory filesep fileName '.ept'],'file')
                    sameName=1;
                end
                if sameName
                    theNumber=theNumber+1;
                    fileName=[fileNameStem '-' num2str(theNumber)];
                end
            end

            lastwarn('');
            warning('off','MATLAB:save:sizeTooBigForMATFile')
            save('-mat', [activeDirectory filesep fileName '.ept'], 'EPdata');
            warning('on')
            SMEoutFiles{iAve,1}=[activeDirectory filesep fileName '.ept'];
        end
    end
    fprintf('%60s\n',' ' );

elseif strcmp(dataType,'average') %form grand average

    if any(strcmp(averagingMethod,{'Latency-Lock','Jitter-Correct'}))
        msg{1}=['Error: Latency-locked and jitter-correction averaging not available for grand averages.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    EPdata.subNames{1}='grand average';
    EPdata.subTypes{1}='GAV';
    EPdata.subjectSpecs={};
    EPdata.subjectSpecNames={};
    EPdata.events = cell(1,numCells);
    avgNum=[];
    subNum=[];
    covNum=[];
    covMatrix=[];
    covNq=[];
    trialSpecs=cell(0);
    gavData=zeros(size(inputData.data,1),size(inputData.data,2),length(EPdata.cellNames),size(inputData.data,4),size(inputData.data,5),size(inputData.data,6),size(inputData.data,7));
    covData=zeros(size(inputData.covAVE,1),size(inputData.covAVE,2),length(EPdata.cellNames),size(inputData.covAVE,4),size(inputData.covAVE,5),size(inputData.covAVE,6),size(inputData.covAVE,7));
    noiseData=zeros(size(inputData.noise,1),size(inputData.noise,2),length(EPdata.cellNames),size(inputData.noise,4),size(inputData.noise,5),size(inputData.noise,6),size(inputData.noise,7));

    impCount=0;
    impGrdCount=0;

    %glue together the various subject average files
    totNumSubs=0;
    for iSession = 1:numFiles
        ep_tictoc;if EPtictoc.stop;return;end
        Name=deblank(inputFiles{iSession});
        [pathstr, fileName, ext]=fileparts(Name);

        disp(['Working on: ' Name '.']);

        if iSession > 1
            thisReadArg=readArg;
            thisReadArg{end+1}='file';
            thisReadArg{end+1}=Name;
            thisReadArg{end+1}='silent';
            thisReadArg{end+1}='on';
            thisReadArg{end+1}='ced';
            thisReadArg{end+1}=inputData.ced; %assume all the files averaged together will be using the same ced file.
            SMIsuffix=preferences.general.SMIsuffix;
            if ~isempty(SMIsuffix)
                thisReadArg{end+1}='SMIsuffix';
                thisReadArg{end+1}=SMIsuffix;
            end
            specSuffix=preferences.general.specSuffix;
            if ~isempty(specSuffix)
                thisReadArg{end+1}='specSuffix';
                thisReadArg{end+1}=specSuffix;
            end
            subjectSpecSuffix=preferences.general.subjectSpecSuffix;
            if ~isempty(subjectSpecSuffix)
                thisReadArg{end+1}='subjectSpecSuffix';
                thisReadArg{end+1}=subjectSpecSuffix;
            end
            if strcmp(inputFormat,'matlab_mat')
                thisReadArg{end+1}='matlabDims';
                thisReadArg{end+1}=outInfo.matlabDims;
            end
            [inputData, origEloc, outInfo]=ep_readData(thisReadArg);
            if EPtictoc.stop;return;end
            if isempty(inputData) || isempty(inputData.data)
                return;
            end
            [inputData]=ep_stripAdds(inputData);
            if isempty(inputData) || isempty(inputData.data)
                return;
            end
        end

        numSubs=length(inputData.subNames);
        totNumSubs=totNumSubs+numSubs;

        [theFileCells cellIndex]=ismember(EPdata.cellNames,inputData.cellNames);
        cellIndex=cellIndex(find(cellIndex));
        EPdata.analysis.blinkTrial(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.blinkTrial(:,cellIndex);
        EPdata.analysis.saccadeTrial(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.saccadeTrial(:,cellIndex);
        EPdata.analysis.saccadeOnset(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.saccadeOnset(:,cellIndex);
        EPdata.analysis.moveTrial(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.moveTrial(:,cellIndex);
        EPdata.analysis.badTrials(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.badTrials(:,cellIndex);
        for iCell=1:length(inputData.cellNames)
            whichCells=find(theFileCells);
            EPdata.analysis.badChans(totNumSubs-numSubs+1:totNumSubs,whichCells(iCell),:)= inputData.analysis.badChans(1:numSubs,cellIndex(iCell),:);
            for iSpec=1:length(inputData.trialSpecNames)
                theSpec=find(strcmp(inputData.trialSpecNames{iSpec},EPdata.trialSpecNames));
                if length(theSpec) > 1
                    theSpec=theSpec(1); %if there are multiple specs with the same name, match to the first one.
                end
                if isempty(theSpec)
                    EPdata.trialSpecNames{end+1}=inputData.trialSpecNames{iSpec};
                    theSpec=length(EPdata.trialSpecNames);
                end
                trialSpecs(whichCells(iCell),theSpec,totNumSubs-numSubs+1:totNumSubs)=inputData.trialSpecs(iCell,theSpec,:);
            end
        end

        for iSub=1:numSubs
            for iCell=1:length(cellIndex)
                theCell=cellIndex(iCell);
                for iEvent=1:length(inputData.events{iSub,theCell})
                    EPdata.events{1,theCell}(end+1)=inputData.events{iSub,theCell}(iEvent);
                end
            end
        end

        EPdata.recTime(theFileCells)=min(inputData.recTime(cellIndex));
        newStims=find(~ismember({inputData.stims.name},{EPdata.stims.name}));
        if ~isempty(newStims)
            EPdata.stims(end+1:end+length(newStims)) = inputData.stims(newStims);
        end

        avgNum(end+1:end+numSubs,1:numCells)=-1;
        subNum(end+1:end+numSubs,1:numCells)=-1;
        covNum(end+1:end+numSubs,1:numCells)=-1;
        avgNum(end-numSubs+1:end,theFileCells)=inputData.avgNum(:,cellIndex);
        subNum(end-numSubs+1:end,theFileCells)=inputData.subNum(:,cellIndex);
        covNum(end-numSubs+1:end,theFileCells)=inputData.covNum(:,cellIndex);
        if ~isempty(inputData.cov)
            covMatrix(end+1:end+numSubs,:,:)=inputData.cov.covMatrix;
            covNq(end+1:end+numSubs)=inputData.cov.Nq;
        end
        if iSession ==1
            gavData(:,:,theFileCells,:,:,:,:)=inputData.data(:,:,cellIndex,:,:,:,:);
        else
            gavData(:,:,theFileCells,end+1:end+numSubs,:,:,:)=inputData.data(:,:,cellIndex,:,:,:,:);
        end

        if ~isempty(inputData.covAVE)
            if iSession ==1
                noiseData(:,:,theFileCells,:,:,:,:)=inputData.noise(:,:,cellIndex,:,:,:,:);
            else
                noiseData(:,:,theFileCells,end+1:end+numSubs,:,:,:)=inputData.noise(:,:,cellIndex,:,:,:,:);
            end
        else
            noiseData=[];
        end

        if ~isempty(inputData.covAVE)
            if iSession ==1
                covData(:,:,theFileCells,:,:,:,:)=inputData.covAVE(:,:,cellIndex,:,:,:,:);
            else
                covData(:,:,theFileCells,end+1:end+numSubs,:,:,:)=inputData.covAVE(:,:,cellIndex,:,:,:,:);
            end
        else
            covData=[];
        end

        if ~isempty(inputData.impedances.channels)
            impCount=impCount+1;
            EPdata.impedances.channels=EPdata.impedances.channels+inputData.impedances.channels;
        end
        if ~isempty(inputData.impedances.ground)
            impGrdCount=impGrdCount+1;
            EPdata.impedances.ground=EPdata.impedances.ground+inputData.impedances.ground;
        end

        elocs{end+1}=inputData.eloc;
        implicits{end+1}=inputData.implicit;
    end
    numSubs=totNumSubs;
    if numSubs==1
        msg{1}=['Error: Cannot compute a grand average as there is only one subject.'];
        [msg]=ep_errorMsg(msg);
        return
    end

    if impCount
        EPdata.impedances.channels=EPdata.impedances.channels/impCount;
    end
    if impGrdCount
        EPdata.impedances.ground=EPdata.impedances.ground/impGrdCount;
    end

    %compute the grand average

    EPdata.data=NaN(numChans,max(numPoints,1),numCells,1,numFacs,max(numFreqs,1),max(numRels,1));
    if ~any(noiseData,'all') %if none of the files had noise information, then just drop the noise matrix entirely.
        dropNoise=1;
    end
    if ~dropNoise
        EPdata.noise=zeros(numChans,max(numPoints,1),numCells,1,numFacs);
    end
    EPdata.covAVE=[];
    EPdata.GAVsubs=[];
    EPdata.trialSpecs=cell(numCells,length(inputData.trialSpecNames),1);
    if ~isempty(covMatrix)
        %assume cov matrix is different so need to figure out new covariance matrix as well as the new effective sample size for the new combination
        %add together cov matrices weighted by their sample size, per MNE manual 2.7.3 p.90.
        EPdata.cov.covMatrix=zeros(1,numChans,numChans);
        for iSub=1:numSubs
            EPdata.cov.covMatrix=EPdata.cov.covMatrix+covMatrix(iSub,:,:)*covNq(iSub);
        end
        EPdata.cov.Nq=sum(covNq);
        EPdata.cov.covMatrix=EPdata.cov.covMatrix/EPdata.cov.Nq;
    else
        EPdata.cov=[];
    end
    for iCell = 1:numCells %the output cell
        ep_tictoc;if EPtictoc.stop;return;end
        theSubs=[1:numSubs];
        badSubs=(avgNum(:,iCell)<0);
        theGoodSubs=theSubs(~badSubs);
        if isempty(theGoodSubs) %if no good subjects for this cell, fill out values and move on
            EPdata.avgNum(1,iCell)=-1;
            EPdata.subNum(1,iCell)=-1;
            EPdata.covNum(1,iCell)=-1;
            EPdata.data(:,:,iCell,1,:)=NaN(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),max(numRels,1));
            if ~dropNoise
                EPdata.noise(:,:,iCell,1,:)=NaN(numChans,max(numPoints,1),1,1,numFacs);
            end
            switch dropSD
                case 1 %SD only
                    EPdata.covAVE(:,:,iCell,1,:)=NaN(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),1);
                case 2 %covariances
                    EPdata.covAVE(:,:,iCell,1,:)=NaN(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),numChans);
                case 3 %none
                otherwise
                    disp('oops.  Programmer error in ep_averageData.  dropSD option not recognized.')
                    return
            end
            if strcmp(averageType,'subject')
                disp(['Warning: The cell ' EPdata.cellNames{iCell} ' has zero trials.']);
            end
            continue
        end
        EPdata.avgNum(1,iCell)=sum(avgNum(theGoodSubs,iCell));

        %per p.128 of the 3.7.2 MNE manual, 1/Leff=Sigma weight-squared/L
        EPdata.covNum(1,iCell)=sum([covNum(theGoodSubs,iCell).^-1]*(1/length(theGoodSubs)).^2).^-1;
        EPdata.subNum(1,iCell)=sum(subNum(theGoodSubs,iCell));
        switch methodName
            case 'Mean'
                for iChan = 1:numChans
                    chanGoodSubs=theGoodSubs(~isnan(EPdata.analysis.badChans(theGoodSubs,iCell,iChan)));
                    numChanGoodSubs=length(chanGoodSubs);
                    if numChanGoodSubs==0 %if the channel is bad for all the available good subjects
                        EPdata.data(iChan,:,iCell,1,:,:)=NaN(1,max(numPoints,1),1,1,numFacs,numFreqs,max(numRels,1));
                        if ~isempty(EPdata.covAVE)
                            switch dropSD
                                case 1 %SD only
                                    EPdata.covAVE(iChan,:,iCell,1,:,:,1)=NaN;
                                case 2 %covariances
                                    EPdata.covAVE(iChan,:,iCell,1,:,:,:)=NaN;
                                    EPdata.covAVE(:,:,iCell,1,:,:,iChan)=NaN;
                                case 3 %none
                                otherwise
                                    disp('oops.  Programmer error in ep_averageData.  dropSD option not recognized.')
                                    return
                            end
                        end
                        if ~dropNoise
                            EPdata.noise(iChan,:,iCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs);
                        end
                        EPdata.analysis.badChans(1,iCell,iChan)=NaN;
                    else
                        EPdata.analysis.badChans(1,iCell,iChan)=sum(EPdata.analysis.badChans(chanGoodSubs,iCell,iChan),1);
                        for iFactor = 1:numFacs
                            EPdata.data(iChan,:,iCell,1,iFactor,:,:)=mean(gavData(iChan,:,iCell,chanGoodSubs,iFactor,:,:),4,'omitnan');
                            if isempty(EPdata.freqNames) && ~isempty(noiseData) && ~dropNoise
                                EPdata.noise(iChan,:,iCell,1,iFactor)=mean(noiseData(iChan,:,iCell,chanGoodSubs,iFactor),4,'omitnan');
                            end
                        end
                    end
                end
            case 'Median'
                for iChan = 1:numChans
                    chanGoodSubs=theGoodSubs(~isnan(EPdata.analysis.badChans(theGoodSubs,iCell,iChan)));
                    numChanGoodSubs=length(chanGoodSubs);
                    if numChanGoodSubs==0 %if the channel is bad for all the available good subjects
                        EPdata.data(iChan,:,iCell,1,:)=NaN(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1),max(numRels,1));
                        if ~isempty(EPdata.covAVE)
                            switch dropSD
                                case 1 %SD only
                                    EPdata.covAVE(iChan,:,iCell,1,:,:,1)=NaN;
                                case 2 %covariances
                                    EPdata.covAVE(iChan,:,iCell,1,:,:,:)=NaN;
                                    EPdata.covAVE(:,:,iCell,1,:,:,iChan)=NaN;
                                case 3 %none
                                otherwise
                                    disp('oops.  Programmer error in ep_averageData.  dropSD option not recognized.')
                                    return
                            end
                        end
                        if ~dropNoise
                            EPdata.noise(iChan,:,iCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs);
                        end
                        EPdata.analysis.badChans(1,iCell,iChan)=NaN;
                    else
                        EPdata.analysis.badChans(1,iCell,iChan)=sum(EPdata.analysis.badChans(chanGoodSubs,iCell,iChan),1);
                        for iFactor = 1:numFacs
                            EPdata.data(iChan,:,iCell,1,iFactor,:,:)=median(gavData(iChan,:,iCell,chanGoodSubs,iFactor,:,:),4);
                        end
                        if isempty(EPdata.freqNames) && ~isempty(EPdata.noise) && ~dropNoise
                            EPdata.noise(iChan,:,iCell,1,iFactor)=mean(EPdata.noise(iChan,:,iCell,chanGoodSubs,iFactor),4,'omitnan');
                        end
                    end
                end
            case 'Trimmed_Mean'
                for iChan = 1:numChans
                    chanGoodSubs=theGoodSubs(~isnan(EPdata.analysis.badChans(theGoodSubs,iCell,iChan)));
                    numChanGoodSubs=length(chanGoodSubs);
                    if numChanGoodSubs==0 %if the channel is bad for all the available good subjects
                        EPdata.data(iChan,:,iCell,1,:)=NaN(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1),max(numRels,1));
                        if ~isempty(EPdata.covAVE)
                            switch dropSD
                                case 1 %SD only
                                    EPdata.covAVE(iChan,:,iCell,1,:,:,1)=NaN;
                                case 2 %covariances
                                    EPdata.covAVE(iChan,:,iCell,1,:,:,:)=NaN;
                                    EPdata.covAVE(:,:,iCell,1,:,:,iChan)=NaN;
                                case 3 %none
                                otherwise
                                    disp('oops.  Programmer error in ep_averageData.  dropSD option not recognized.')
                                    return
                            end
                        end
                        if ~dropNoise
                            EPdata.noise(iChan,:,iCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));
                        end
                        EPdata.analysis.badChans(1,iCell,iChan)=NaN;
                    else
                        EPdata.analysis.badChans(1,iCell,iChan)=sum(EPdata.analysis.badChans(chanGoodSubs,iCell,iChan),1);
                        trimSubs=floor(numChanGoodSubs*trimLevel);
                        numTrimmedSubs=length(trimSubs+1:numChanGoodSubs-trimSubs);
                        for theSample = 1:max(numPoints,1)
                            for iFactor = 1:numFacs
                                for iFreq = 1:max(numFreqs,1)
                                    for theRel = 1:max(numRels,1)
                                        [sortedValues index]=sort(squeeze(gavData(iChan,theSample,iCell,chanGoodSubs,iFactor,iFreq,theRel))); %how to make this work with relationship data? ***
                                        EPdata.data(iChan,theSample,iCell,1,iFactor,iFreq,theRel)=mean(sortedValues(trimSubs+1:numTrimmedSubs-trimSubs),'omitnan');
                                        if isempty(EPdata.freqNames) && ~isempty(EPdata.noise) && ~dropNoise
                                            EPdata.noise(iChan,:,iCell,1,iFactor)=mean(EPdata.noise(iChan,:,iCell,chanGoodSubs,iFactor),4,'omitnan');
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            otherwise
                msg{1}=['Error: The averaging method ' averagingMethod ' is not recognized.'];
                [msg]=ep_errorMsg(msg);
                return
        end

        if isempty(inputData.relNames)  && ~isempty(EPdata.covAVE)
            %the covariance matrix is not affected by median or trimmed mean operations.  They are computed the same as the mean operation.
            for iFactor = 1:numFacs
                for iFreq = 1:max(numFreqs,1)
                    %compute channel variances
                    for iChan = 1:numChans
                        for iPoint=1:max(numPoints,1)
                            chanGoodSubs=theGoodSubs(~isnan(EPdata.analysis.badChans(theGoodSubs,iCell,iChan)));
                            if dropSD==1
                                EPdata.covAVE(iChan,iPoint,iCell,1,iFactor,iFreq,1)=var(squeeze(covData(iChan,iPoint,iCell,chanGoodSubs,iFactor,iFreq)),'omitnan');
                            else
                                EPdata.covAVE(iChan,iPoint,iCell,1,iFactor,iFreq,iChan)=var(squeeze(covData(iChan,iPoint,iCell,chanGoodSubs,iFactor,iFreq,iChan)),'omitnan');
                            end
                        end
                    end
                    %compute channel covariances
                    if dropSD==2
                        for iChan = 1:numChans
                            chanGoodSubs=theGoodSubs(~isnan(EPdata.analysis.badChans(theGoodSubs,iCell,iChan)));
                            for iChan2=iChan+1:numChans
                                %can't just compute cov pairwise because the cov matrix would end up being degenerate when there are bad channels in some of the trials
                                %instead computing R pairwise on channels and then reweight with the variances.  This is the equivalent of missing data imputation based on the intact data.
                                chanGoodSubs2=theGoodSubs(~isnan(EPdata.analysis.badChans(theGoodSubs,iCell,iChan2)));
                                bothChanGoodSubs=intersect(chanGoodSubs,chanGoodSubs2);
                                for iPoint=1:max(numPoints,1)
                                    theCov=mean(squeeze(covData(iChan,iPoint,iCell,bothChanGoodSubs,iFactor,iFreq,iChan)),'omitnan');
                                    EPdata.covAVE(iChan,iPoint,iCell,1,iFactor,iFreq,iChan2)=theCov;
                                    EPdata.covAVE(iChan2,iPoint,iCell,1,iFactor,iFreq,iChan)=theCov;
                                end
                            end
                        end
                    end
                end
            end
        end

        %generate the averaged trial specs
        for iSpec=1:length(inputData.trialSpecNames)
            theSpec=find(strcmp(inputData.trialSpecNames{iSpec},EPdata.trialSpecNames));
            if length(theSpec) > 1
                theSpec=theSpec(1); %if there are multiple specs with the same name, match to the first one.
            end
            if ischar(trialSpecs{iCell,theSpec,1}) && all(strcmp(trialSpecs{iCell,theSpec,1},trialSpecs(iCell,theSpec,:)))
                EPdata.trialSpecs{iCell,theSpec,1}=trialSpecs{1,theSpec,1};
            else
                theSpecs=squeeze(trialSpecs(iCell,theSpec,:));
                theStrSpecs=find(cellfun(@ischar,theSpecs));
                for iStrSpec=1:length(theStrSpecs)
                    theStrSpec=theStrSpecs(iStrSpec);
                    theSpecs{theStrSpec}=str2double(theSpecs{theStrSpec});
                end
                EPdata.trialSpecs{iCell,theSpec,1}=mean(cell2mat(theSpecs),'omitnan');
            end
        end
    end

    EPdata.analysis.blinkTrial=sum(EPdata.analysis.blinkTrial,1);
    EPdata.analysis.saccadeTrial=sum(EPdata.analysis.saccadeTrial,1);
    saccadeOnset=EPdata.analysis.saccadeOnset;
    EPdata.analysis.saccadeOnset=zeros(1,length(EPdata.analysis.saccadeTrial));
    for i=1:length(EPdata.analysis.saccadeTrial)
        if EPdata.analysis.saccadeTrial(i) == 0
            EPdata.analysis.saccadeOnset(i)=0;
        else
            EPdata.analysis.saccadeOnset(i)=sum(saccadeOnset(:,i))/EPdata.analysis.saccadeTrial(i); %compute average saccade onset
        end
    end
    EPdata.analysis.moveTrial=sum(EPdata.analysis.moveTrial,1);
    EPdata.analysis.badTrials=sum(EPdata.analysis.badTrials,1);
    EPdata.analysis.badChans=EPdata.analysis.badChans(1,:,:);

else
    msg{1}=['Error: The data type ' dataType ' is not recognized.'];
    [msg]=ep_errorMsg(msg);
    return
end

diffElocs=0;
baseEloc=ep_elocFormat('initialize');
baseImplicit=ep_elocFormat('initialize');
for iEloc=1:length(elocs)
    if ~isempty(elocs{iEloc})
        if isempty(baseEloc)
            baseEloc=elocs{iEloc};
            baseImplicit=implicits{iEloc};
        else
            if ~diffElocs
                diffElocs=~isequal(baseEloc,elocs{iEloc}) | ~isequal(baseImplicit,implicits{iEloc});
                if diffElocs
                    break
                end
            end
        end
    end
end

if diffElocs
    disp('Warning: differing sets of electrode coordinates detected.')
    switch elocFlag
        case 1
            disp('Will use the first non-empty set of electrode coordinates in the list of files.')
            EPdata.eloc=baseEloc; %by default, use first non-empty eloc
            EPdata.implicit=baseImplicit;
        case 2
            disp('Will average together the electrode coordinates.')
            newEloc=ep_elocFormat('initialize');
            newImplicit=ep_elocFormat('initialize');
            elocNum=0;
            implicitNum=0;
            for iEloc=1:length(elocs)
                if ~isempty(elocs{iEloc})
                    if ~isempty(elocs{iEloc}.X)
                        newEloc.X=newEloc.X+elocs{iEloc}.X;
                        newEloc.Y=newEloc.X+elocs{iEloc}.Y;
                        newEloc.Z=newEloc.X+elocs{iEloc}.Z;
                        elocNum=elocNum+1;
                    end
                end
                if ~isempty(implicits{iEloc})
                    if ~isempty(implicits{iEloc}.X)
                        newImplicit(1).X=newImplicit(1).X+implicits{iEloc}.X;
                        newImplicit(1).Y=newImplicit(1).X+implicits{iEloc}.Y;
                        newImplicit(1).Z=newImplicit(1).X+implicits{iEloc}.Z;
                        implicitNum=implicitNum+1;
                    end
                end
            end
            if ~isempty(newEloc)
                [newEloc.X]=deal(newEloc.X/elocNum);
                [newEloc.Y]=deal(newEloc.Y/elocNum);
                [newEloc.Z]=deal(newEloc.Z/elocNum);
                EPdata.eloc = convertlocs(newEloc, 'cart2all');
            end
            if ~isempty(newImplicit)
                [newImplicit(1).X]=deal(newImplicit(1).X/implicitNum);
                [newImplicit(1).Y]=deal(newImplicit(1).Y/implicitNum);
                [newImplicit(1).Z]=deal(newImplicit(1).Z/implicitNum);
                EPdata.implicit = convertlocs(newImplicit, 'cart2all');
            end
        case 3
            disp('Will interpolate all of them to MNI canonical head space.')
            if ~isempty(baseEloc)
                [baseEloc.X]=deal(baseEloc.cX);
                [baseEloc.Y]=deal(baseEloc.cY);
                [baseEloc.Z]=deal(baseEloc.cZ);
                EPdata.eloc = convertlocs(baseEloc, 'cart2all');
            end
            if ~isempty(baseImplicit)
                [baseImplicit.X]=deal(baseImplicit.cX);
                [baseImplicit.Y]=deal(baseImplicit.cY);
                [baseImplicit.Z]=deal(baseImplicit.cZ);
                EPdata.implicit = convertlocs(baseImplicit, 'cart2all');
            end
        otherwise
            error('Programmer error: elocFlag not recognized.')
    end 
end

if any(strcmp(methodName,{'meanSME','meanERA'}))
    EPdata=SMEoutFiles;
else
    if ~isempty(inputData.freqNames) && ~any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))
        %assume all the input files were comparable since this function checks for that.
        EPdata.noise=[]; %+/- noise estimate does not work for FFT data since all the power values will be positive.
    end

    if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))
        EPdata.noise=[];
        EPdata.covAVE=[];
    end

    if all(strcmp('n/a',EPdata.sessNames))
        EPdata.sessNames=cell(0);
        EPdata.sessNums=[];
    end

    %ensure fields are in standard order.
    modelData=ep_newFile;
    if ~isequal(fieldnames(modelData),fieldnames(EPdata))
        EPdata = orderfields(EPdata, modelData);
    end

    if all(isnan(EPdata.data),'all')
        msg{1}=['Error: No data in the resulting average file.  Did you use the wrong settings for the bad data controls?'];
        [msg]=ep_errorMsg(msg);
        return
    end

    [err]=ep_checkEPfile(EPdata);
end
ep_tictoc('end');
EPdataOut=EPdata;