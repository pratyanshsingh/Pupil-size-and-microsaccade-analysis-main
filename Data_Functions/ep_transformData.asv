function outputFiles=ep_transformData(inputFiles,inputFormat,fileType,outputFormat,referenceMethod,transform,domainName,methodName,dataMode,BOSC)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% outputFiles=ep_transformData(inputFiles,inputFormat,fileType,outputFormat,referenceMethod,transform,domainName,methodName,dataMode,BOSC)
% Rereferences, baseline corrects data, filters, and performs spectral analysis on files.
% Will refuse to operate on a factor file as it would be invalid.  The PCA results are affected by whether the
% data are baseline corrected or how it is referenced so such operations should be applied prior to the PCA.
%
%	Reads in specified data files, rereferences them and baseline corrects them.
%   Saves the resulting output data.
%
%Inputs
%   inputFiles: cell array of file names to correct.  Assumes active directory if path not specified.  (default: will ask for files)
%   inputFormat: input file format.
%   fileType: input file type.
%   outputFormat: output file format.
%   referenceMethod: Type of referencing: 'none','average','traditional'.
%   transform
%       refChan1: First channel used for traditional referencing.  Zero for not used.
%       refChan2: Second channel used for traditional referencing.  Zero for not used.
%       baselineStart: Left side of sample starting baseline period in msec.  Empty if no baseline correction
%       baselineEnd: Right side of sample ending baseline period in msec.  Empty if no baseline correction
%       preStim: The number of msec the start of the epoch is positioned with respect to the stimulus (pos. means before stimulus).
%       smoothing: Frequency smoothing for frequency domain analysis.
%       cfgFilter: configuration settings for filtering.
%   domainName: Domain of analysis: 'Time','Frequency','Time-Frequency'.
%   methodName: Method used to carry out transformation.
%   dataMode: Data collection mode to which to apply transforms (EEG, MEG, pupil, ECG, ANS)
%   BOSC: information for BOSC analysis. (optional)
%       cell: cell to use for background estimate
%       width: width of wavelet in cycles
%       duration: number of cycles to be dubbed significant
%       threshold: percentile threshold to be considered large enough
%
%Outputs
%   outputFiles:  Cell array of output files.
%	Writes transformed file.
%
% BOSC:
% Whitten, T. A., Hughes, A. M., Dickson, C. T., & Caplan, J. B. (2011). A better oscillation detection method robustly extracts EEG rhythms across brain state changes: The human alpha rhythm as a test case. NeuroImage, 54(2), 860?874. https://doi.org/10.1016/j.neuroimage.2010.08.064
%
% Hughes, A. M., Whitten, T. A., Caplan, J. B., & Dickson, C. T. (2012). BOSC: A better oscillation detection method, extracts both sustained and transient rhythms from rat hippocampal recordings. Hippocampus, 22(6), 1417?1428. https://doi.org/10.1002/hipo.20979
%
% eBOSC
% Kosciessa, J. Q., Grandy, T. H., Garrett, D. D., & Werkle-Bergner, M. (2020). Single-trial characterization of neural rhythms: Potential and challenges. NeuroImage, 206, 116331. https://doi.org/10.1016/j.neuroimage.2019.116331

%
% History:
%
% by Joseph Dien (7/20/09)
% jdien07@mac.com
%
% bugfix 1/27/10 JD
% Update baseline field when using Postprocess function to baseline correct data.
%
% modified 2/16/10 JD
% analysis fields no longer optional.
% Eliminated chantype field for implicit channels.
%
% bugfix 2/27/10 JD
% Eliminated updating of baseline field.  The part of the segment used for baseline correction may not necessarily
% correspond to the prestimulus period.
%
% bugfix 5/26/10 JD
% Fixed crash when rereferencing and there are no implicit channels.
%
% modified 2/15/12 JD
% Added support for frequency and time-frequency analysis
%
% modified 1/25/12 JD
% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.
%
% modified 2/22/12 JD
% Noise and std fields no longer optional.  Now set to empty if not used.
%
% modified 2/23/12 JD
% Adds suffix number if file already exists rather than overwriting.
%
% modified 6/6/12 JD
% Added prestim field.
%
% bugfix 8/4/12 JD
% Fixed overwriting existing file if the output file format differed from the input file format.
%
% modified 8/6/12 JD
% Added suport for coherence and phase locking measures.
%
% bugfix 11/4/12 JD
% Fixed not updating reference type to REG or AVG when referencing.
%
% modified 1/11/13 JD
% Added option to do internal calculations of frequency data in either amplitude or power form.
%
% modified & bugfix 1/15/13 JD
% Added frequency filtering (low pass, high pass, bandpass, bandstop, notch).
% Fixed not changing prestimulus period when reference set to "none."
% Added detrend option.
%
% bugfix 2/4/13 JD
% Fixed running baseline correction even on frequency domain data even though baseline fields are grayed out.
% 
% modified 9/25/13 JD
% Restricted rereferencing to EEG channels.
%
% bugfix 10/10/13 JD
% Update history field.
%
% modified 11/13/13 JD
% Filtering will not cross boundaries.
%
% bugfix 11/22/13 JD
% Fixed frequency domain transform of continuous data not generating proper recTime field, resulting in later crashes.
%
% modified 4/18/14 JD
% Allows choosing either Hanning or multi-taper methods for spectral measures.
% Eliminated upper bound to smoothing as no longer seems to apply.
%
% modified 6/9/14 JD
% Transforms can be applied to non-EEG channel types and which data mode can be specified.
%
% bugfix 6/9/14 JD
% Fixed crash when filtering continuous data and there are no boundary events present.
%
% modified 7/8/14 JD
% Changed filter parameters to allow for full range of FieldTrip filter
% settings by using using config as the input variable.
%
% modified 8/12/14 JD
% Added support for PARE-corrected average reference.
%
% bugfix 8/12/14 JD
% Set std field to empty rather than trying to rereference.
%
% modified 8/31/14 JD
% Added support for adding additional keys information to events in continuous data and trial specs in single-trial
% data.
%
% modified 9/17/14 JD
% Adding event output for files that don't support events.
%
% modified 10/16/14 JD
% Passes screen size to ep_readData call.
%
% bugfix 12/12/14 JD
% Fixed crash when frequency transforming and there are non EEG channels
% present.
%
% bugfix 1/7/14 JD
% Fixed losing electrode coordinates when filtering data from an mff file.
%
% modified 7/4/15 JD
% Performs average reference prior to performing PARE correction.
%
% bugfix 8/31/15 JD
% Changed the frequency bins so that the first one starts at the frequency
% resolution (e.g., 2hz if the bins are 2Hz wide) rather than always at 1.
% Fixed crash when signal processing toolbox is installed and using
% multi-taper method for time-frequency transform.
%
% bugfix 9/28/15 JD
% Transform function not applying electrode coordinate rotation and text
% file preference settings.
%
% modified 1/15/16 JD
% Amplitude FFT data are represented in complex form.
%
% bugfix 1/22/16 JD
% Fixed crash when performing frequency transform on continuous data files.
%
% modified 3/8/16 JD
% Eliminated support for .power field.
%
% bugfix & modified 10/10/16 JD
% Fixed crash when performing time-frequency transform with dpss multi-taper on continuous data or segments longer than .5 seconds and default smoothing of one second.
% Fixed time-frequency transform being applied only to first one second of continuous data.
% Time-frequency transform no longer drops non-EEG/MEG channels.
% Event times now updated to new sample times when performing TFT with Transform Data funcion.
%
% modified 11/5/16 JD
% Added support for reading and writing subject spec text files.
%
% bugfix & modified 6/19/17 JD
% Fixed crash when performing time-frequency transform on single-trial data files.
% When performing time-frequency transform on continuous data files, lops off data at ends in increments of one second to that edit epochs still align properly.
% Previously would either crash or the edit epochs would end up misaligned by half of the T-F window (which was .5 seconds by default).
% Also, since the T-F transform reaches into the adjoining epochs, if they were bad data then the current epoch is also marked as being bad (both for trial and for channels).
% Allow baseline correction to be applied to TFT data.
%
% modified 2/11/18 JD
% Added support for stdCM field.
%
% bugfix 8/7/18 JD
% Fixed TFT so it does not result in NaN at the ends of the resulting output when the sampling rate of segmented data is an even multiple of 250Hz.
%
% modified 12/12/18 JD
% Added support for specifying sample rate for text data.
%
% bugfix 1/11/19 JD
% workaround for Fieldtrip bug that can cause FFT transform to fail.
% Fixed crash when TFT applied to data segments less than 500 ms long.
%
% bugfix 7/19/19 JD
% Fixed crash.
%
% bugfix 10/22/19 JD
% Fixed BAD CED option not working for batch files.
%
% modified 1/14/20 JD
% Upgraded support of std information by adding .covAVE and .GAVsubs fields and eliminating .std and .stdCM fields.
% Now ignores bad channels during rereferencing and marks as a bad trial/average if all the reference channes are bad.
% Fixed crash when running CSD in Transform.
%
% bugfix & modified 3/11/20 JD
% Added support for BOSC analysis option.
% Fixed crash when rereferencing data and there are no good reference channels in a given epoch.
%
% modified 7/2/20 JD
% Removed preference option to rotate electrode coordinates when importing mff or eeglab files that have internal coordinates as no longer needed.
%
% bugfix 1/30/21 JD
% Fixed baseline and rereference options not being robust to presence of NaN values.
% Fixed crash if baseline field is set to empty.
%
% modified 2/13/21 JD
% Added option to fix mains noise.
%
% bugfix 8/4/21 JD
% Fixed crash when using mains noise correction option in the Transform function on segmented data that is less than one second long.
%
% modified 7/24/22 JD
% Added support for reading Matlab .mat files.
%
% bugfix 11/24/22 JD
% Fixed not automatically adjusting bad smoothing values for wavelet multiplication and wavelet convolution options for FFT and TFT transforms.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Copyright (C) 1999-2025  Joseph Dien
%
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

global EPmain EPtictoc

cfg=[];

ep_tictoc('begin');

refChan1=transform.refChan1;
refChan2=transform.refChan2;
baselineStart=transform.baselineStart;
baselineEnd=transform.baselineEnd;
preStim=transform.preStim;
smoothing=transform.smoothing;
doDetrend=transform.detrend;
mainsFix=transform.mainsFix;

textPrefs.firstRow=EPmain.preferences.general.firstRow;
textPrefs.lastRow=EPmain.preferences.general.lastRow;
textPrefs.firstCol=EPmain.preferences.general.firstCol;
textPrefs.lastCol=EPmain.preferences.general.lastCol;
textPrefs.orientation=EPmain.preferences.general.orientation;
textPrefs.sampleRate=EPmain.preferences.general.sampleRate;

if isempty(inputFiles)
    [inputFiles, activeDirectory]=ep_getFilesUI(inputFormat);
    if isempty(inputFiles)
        return
    end
    if inputFiles{1}==0
        msg{1}='No filenames selected. You have to click on a name';
        [msg]=ep_errorMsg(msg);
        return
    end
    for theFile=1:size(inputFiles,2)
        inputFiles{theFile}=[activeDirectory inputFiles{theFile}];
    end
else
    files=dir;
    for theFile=1:size(inputFiles,2)
        [activeDirectory, name, ext] = fileparts(inputFiles{theFile});
        if isempty(activeDirectory)
            activeDirectory=pwd;
            inputFiles{theFile}=[activeDirectory filesep inputFiles{theFile}];
        end
        if ~exist(inputFiles{theFile},'file')
            msg{1}=['Error: The file ' inputFiles{theFile} ' is not in the directory.'];
            [msg]=ep_errorMsg(msg);
            return
        end
    end
end

inputFiles=inputFiles';
sessionNum = size(inputFiles,1);

readArg{1}='format';
readArg{2}=inputFormat;
readArg{3}='screenSize';
readArg{4}=EPmain.scrsz;
readArg{5}='FontSize';
readArg{6}=EPmain.fontsize;
readArg{7}='textPrefs';
readArg{8}=textPrefs;
if ~strcmp(inputFormat,'ep_mat')
    readArg{end+1}='type';
    readArg{end+1}=fileType;
end
SMIsuffix=EPmain.preferences.general.SMIsuffix;
if ~isempty(SMIsuffix)
    readArg{end+1}='SMIsuffix';
    readArg{end+1}=SMIsuffix;
end
specSuffix=EPmain.preferences.general.specSuffix;
if ~isempty(specSuffix)
    readArg{end+1}='specSuffix';
    readArg{end+1}=specSuffix;
end
subjectSpecSuffix=EPmain.preferences.general.subjectSpecSuffix;
if ~isempty(subjectSpecSuffix)
    readArg{end+1}='subjectSpecSuffix';
    readArg{end+1}=subjectSpecSuffix;
end
BVheader=EPmain.preferences.general.BVheader;
if ~isempty(BVheader)
    readArg{end+1}='BVheader';
    readArg{end+1}=BVheader;
end
noInternal=EPmain.preferences.general.noInternal;
if ~isempty(noInternal)
    readArg{end+1}='noInternal';
    readArg{end+1}=noInternal;
end

%assume the first session file is representative of the rest.
Name=deblank(inputFiles{1});
thisReadArg=readArg;
thisReadArg{end+1}='file';
%[pathstr, fileName, ext]=fileparts(Name);
thisReadArg{end+1}=Name;
thisReadArg{end+1}='silent';
thisReadArg{end+1}='on';
[data, origEloc, outInfo]=ep_readData(thisReadArg);
if EPtictoc.stop;return;end
if isempty(data) || isempty(data.data)
    msg{1}=['Error: The file ' inputFiles{1} ' was not read successfully.'];
    [msg]=ep_errorMsg(msg);
    return
end

if isempty(data.eloc)
    msg{1}=['Error: The file ' inputFiles{1} ' has no information on channel locations.  .ced file needed.'];
    [msg]=ep_errorMsg(msg);
    return
end

if ~strcmp(referenceMethod,'none') && ~isempty(data.freqNames)
    msg{1}=['Error: The file ' inputFiles{1} ' cannot be rereferenced as it has already been frequency transformed.'];
    [msg]=ep_errorMsg(msg);
    return
end

if strcmp(domainName,{'Time-Frequency','Frequency'})
    if ~isempty(ismember(inpuData.chanTypes,{'EEG','REG'})) && ~isempty(ismember(inpuData.chanTypes,{'MGM','MGA','MGP'}))
        disp('EP Toolkit must spectrally analyze both EEG and MEG channels if present and so will do so.');
    end
    if length(find(ismember(inpuData.chanTypes,{'EEG','REG','MGM','MGA','MGP'}))) ~= length(inpuData.chanTypes)
        disp('Channel types other than EEG and MEG will be dropped when performing spectral analysis upon file.');
    end    
end

%Check to make sure the files all have the same number of channels.
if sessionNum > 1
    disp('Checking files for consistency.');
end
for theFile=2:sessionNum
    ep_tictoc;if EPtictoc.stop;return;end
    Name2=deblank(inputFiles{theFile});
    thisReadArg2=readArg;
    thisReadArg2{end+1}='file';
    %[pathstr, fileName, ext]=fileparts(Name2);
    thisReadArg2{end+1}=Name2;
    thisReadArg2{end+1}='silent';
    thisReadArg2{end+1}='on';
    thisReadArg2{end+1}='ced';
    thisReadArg2{end+1}=data.ced; %assume they all have the same channel coordinates
    thisReadArg2{end+1}='montage';
    thisReadArg2{end+1}=data.montage; %assume they all have the same montage
%     thisReadArg2{end+1}='eloc';
%     thisReadArg2{end+1}=data.eloc; %assume they all have the same channel coordinates
    SMIsuffix=EPmain.preferences.general.SMIsuffix;
    if ~isempty(SMIsuffix)
        thisReadArg2{end+1}='SMIsuffix';
        thisReadArg2{end+1}=SMIsuffix;
    end
    specSuffix=EPmain.preferences.general.specSuffix;
    if ~isempty(specSuffix)
        thisReadArg2{end+1}='specSuffix';
        thisReadArg2{end+1}=specSuffix;
    end
    subjectSpecSuffix=EPmain.preferences.general.subjectSpecSuffix;
    if ~isempty(subjectSpecSuffix)
        thisReadArg2{end+1}='subjectSpecSuffix';
        thisReadArg2{end+1}=subjectSpecSuffix;
    end
    BVheader=EPmain.preferences.general.BVheader;
    if ~isempty(BVheader)
        thisReadArg2{end+1}='BVheader';
        thisReadArg2{end+1}=BVheader;
    end
    noInternal=EPmain.preferences.general.noInternal;
    if ~isempty(noInternal)
        thisReadArg2{end+1}='noInternal';
        thisReadArg2{end+1}=noInternal;
    end
    if strcmp(inputFormat,'matlab_mat')
        thisReadArg2{end+1}='matlabDims';
        thisReadArg2{end+1}=outInfo.matlabDims;
    end

    [data2, origEloc, outInfo]=ep_readData(thisReadArg2);
    if EPtictoc.stop;return;end
    if isempty(data2) || isempty(data2.data)
        msg{1}=['Error: The file ' Name2 ' was not read successfully.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if (length(data.chanNames) ~= length(data2.chanNames))
        msg{1}=['Error: The file ' inputFiles{theFile} ' has a different set of channels from the other files.  Aborting batch so you can take a look at it.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    if ~strcmp(referenceMethod,'none') && ~isempty(data2.freqNames)
        msg{1}=['Error: The file ' inputFiles{theFile} ' cannot be rereferenced as it has already been frequency transformed.'];
        [msg]=ep_errorMsg(msg);
        return
    end
end

if length(inputFiles) > 1
    disp('Suppressing Command Window file reading output for all files past the first one.')
end

%Start processing files
outputFiles=cell(length(inputFiles),1);
for iFile=1:length(inputFiles)
    tic
    ep_tictoc;if EPtictoc.stop;return;end
    Name=deblank(inputFiles{iFile});
    thisReadArg=readArg;
    thisReadArg{end+1}='file';
    thisReadArg{end+1}=Name;
    if iFile > 1
        thisReadArg{end+1}='silent';
        thisReadArg{end+1}='on';
    end
    thisReadArg{end+1}='ced';
    thisReadArg{end+1}=data.ced; %assume they all have the same channel coordinates so doesn't have to keep asking the user for the coordinates
    thisReadArg{end+1}='montage';
    thisReadArg{end+1}=data.montage; %assume they all have the same montage
%     thisReadArg{end+1}='eloc';
%     thisReadArg{end+1}=data.eloc; %assume they all have the same channel coordinates
    if strcmp(inputFormat,'matlab_mat')
        thisReadArg{end+1}='matlabDims';
        thisReadArg{end+1}=outInfo.matlabDims;
    end
    
    Name=deblank(inputFiles{iFile});
    [pathstr, fileName, ext]=fileparts(Name);
    disp(['Working on #' num2str(iFile) ': ' fileName '.']);
    [inputData, origEloc, outInfo]=ep_readData(thisReadArg);
    ep_tictoc;if EPtictoc.stop;return;end
    
    if isempty(inputData) || isempty(inputData.data)
        return
    end
    
    if length(inputData.facNames) > 1
        msg{1}=['Error: The file ' fileName ' is a factor file.'];
        [msg]=ep_errorMsg(msg);
        return
    end
    
    switch inputData.dataType
        case 'continuous'
            theSegment = 'one second epoch';
        case 'single_trial'
            theSegment = 'trial';
        case 'average'
            theSegment = 'cell';
        otherwise
            error('Programmer error')
    end
                
    numChans=length(inputData.chanNames);
    EEGchans=find(strcmp('EEG',inputData.chanTypes));
    EEGREGchans=find(ismember(inputData.chanTypes,{'EEG','REG'}));
    numEEGchans=length(EEGchans);
    numPoints=length(inputData.timeNames);
    numCells=length(unique(inputData.cellNames));
    numWaves=length(inputData.cellNames);
    numSubs=length(inputData.subNames);
    numFreqs=length(inputData.freqNames);
    numFacs=length(inputData.facNames);
    if isempty(inputData.facData)
        numCMBfacs=0;
    else
        numCMBfacs=size(inputData.facData,5);
    end
    numSGLfacs=max(numFacs-numCMBfacs,1);
    suffix=[];
    
    switch dataMode
        case 'EEG'
            modeChans=find(ismember(inputData.chanTypes,{'EEG','REG'}));
        case 'MEG'
            modeChans=find(ismember(inputData.chanTypes,{'MGM','MGA','MGP'}));
        case 'pupil'
            modeChans=find(strcmp('PPL',inputData.chanTypes));
        case 'ECG'
            modeChans=find(strcmp('ECG',inputData.chanTypes));
        case 'ANS'
            modeChans=find(strcmp('ANS',inputData.chanTypes));
        otherwise
            disp('Oops: programmer error.');
            return
    end
    
    
    %Change prestim period
    
    if ~isempty(preStim)
        if isempty(inputData.baseline)
            inputData.baseline=0;
        end
        inputData.timeNames=(((0:length(inputData.timeNames)-1)+inputData.baseline)*(1000/inputData.Fs))';
        inputData.baseline=preStim/(1000/inputData.Fs);
        inputData.timeNames=(((0:length(inputData.timeNames)-1)-inputData.baseline)*(1000/inputData.Fs))';
    end
    
    if ~strcmp(referenceMethod,'none')
        disp(['Rereferencing data using method: ' referenceMethod '.'])
        %make implicit reference channel explicit
        if ~isempty(inputData.implicit)
            theRef=find(strcmp({inputData.implicit.type},'REF'));
        else
            theRef=[];
        end
        if length(theRef) == 1 %can't make implicit reference explicit if there is more than one such ref site
            inputData.data(end+1,:,:,:,:)=zeros(1,numPoints,numWaves,numSubs,numSGLfacs);
            if ~isempty(inputData.facData)
                inputData.facData(end+1,:,:,:,:)=zeros(1,numPoints,numWaves,numSubs,numCMBfacs);
            end
            if ~isempty(inputData.noise)
                inputData.noise(end+1,:,:,:,:)=zeros(1,numPoints,numWaves,numSubs,numFacs);
            end
            if ~isempty(inputData.covAVE)
                if size(inputData.covAVE,7)==1
                    inputData.covAVE(end+1,:,:,:,:,:,:)=0;
                else
                    inputData.covAVE(end+1,:,:,:,:,:,end+1)=0;
                end
            end
            inputData.chanNames{end+1}=inputData.implicit(theRef).labels;
            inputData.chanTypes{end+1}='EEG';
            theEloc=inputData.implicit(theRef);
            inputData.eloc(end+1)=theEloc;
            inputData.implicit=inputData.implicit([1:theRef-1 theRef+1:end]);
            inputData.analysis.badChans(:,:,end+1)=zeros(numSubs,numWaves);
            numChans=numChans+1;
        end
        
        %rereference data
        switch referenceMethod
            case 'Average'
                inputData.reference.type='AVG';
                suffix=[suffix 'r'];
            case 'Traditional'
                refChans=[];
                if ~isempty(refChan1)
                    if (refChan1 > 0) && (refChan1 <= numChans)
                        refChans=[refChans refChan1];
                        inputData.reference.current(1)=refChan1;
                    end
                end
                if ~isempty(refChan2)
                    if (refChan2 > 0) && (refChan2 <= numChans)
                        refChans=[refChans refChan2];
                        inputData.reference.current(2)=refChan2;
                    end
                end
                if isempty(refChans)
                    msg{1}=['Error: Reference channels ' num2str(refChan1) ' and ' num2str(refChan2) ' invalid.'];
                    [msg]=ep_errorMsg(msg);
                    return
                end
                inputData.reference.type='REG';
                suffix=[suffix 'r'];
            case 'CSD'
                if strcmp(inputData.reference.type,'CSD')
                    msg{1}=['Error: The file ' fileName ' is already a CSD file.'];
                    [msg]=ep_errorMsg(msg);
                    return
                end
                if any(strcmp('REG',inputData.chanTypes))
                    disp(['Stripping out regional channels as they will not CSD properly.']);
                end
                [inputData]=ep_stripAdds(inputData,{'SGLchan','SGLcell','CMBcell','RAW','AVG','GAV','SGLfac','CMBfac'});
                disp('Using FieldTrip function ft_scalpcurrentdensity to perform CSD.');
                numChans=length(inputData.chanNames);
                switch dataMode
                    case 'EEG'
                        modeChans=find(ismember(inputData.chanTypes,{'EEG','REG'}));
                    case 'MEG'
                        modeChans=find(ismember(inputData.chanTypes,{'MGM','MGA','MGP'}));
                    case 'pupil'
                        modeChans=find(strcmp('PPL',inputData.chanTypes));
                    case 'ECG'
                        modeChans=find(strcmp('ECG',inputData.chanTypes));
                    case 'ANS'
                        modeChans=find(strcmp('ANS',inputData.chanTypes));
                    otherwise
                        disp('Oops: programmer error.');
                        return
                end
                inputData.covAVE=[]; %CSD is non-linear measure so can't determine
                inputData.noise=[]; %CSD is non-linear measure so can't determine
                inputData.reference.type='CSD';
                inputData.reference.current=[];
                cfg=[];
                cfg.method='spline';
                cfg.trials='all';
                cfg.elec.pnt=zeros(numEEGchans,3);
                for chan=1:numEEGchans
                    cfg.elec.label{chan}=inputData.chanNames{chan};
                    cfg.elec.pnt(chan,1)=inputData.eloc(chan).X;
                    cfg.elec.pnt(chan,2)=inputData.eloc(chan).Y;
                    cfg.elec.pnt(chan,3)=inputData.eloc(chan).Z;
                end
                suffix=[suffix 'c'];
                fprintf('%60s\n',' ' );
            case 'PARE'
                inputData.reference.type='PAR';
                suffix=[suffix 'r'];
            otherwise
                msg{1}=['Error: Reference method ' referenceMethod ' not recognized.'];
                [msg]=ep_errorMsg(msg);
                return
        end
        
        GAVcount=0;
        for iSub=1:numSubs
            if strcmp(inputData.subTypes,'GAV')
                GAVcount=GAVcount+1;
            end
            for iWave=1:numWaves
                ep_tictoc;if EPtictoc.stop;return;end
                if any(strcmp(inputData.dataType,{'continuous','single_trial'}))
                    badChans=find(inputData.analysis.badChans(iSub,iWave,:)==-1);
                else
                    badChans=find(isnan(inputData.analysis.badChans(iSub,iWave,:)));
                end
                if length(badChans)==num
                switch referenceMethod
                    case 'Average'
                        goodRefs=setdiff(EEGchans,badChans);
                        if isempty(goodRefs)
                            if any(strcmp(inputData.dataType,{'continuous','single_trial'}))
                                inputData.analysis.badTrials(iSub,iWave)=1;
                            else
                                inputData.avgNum(iSub,iWave)=-1;
                            end
                        else
                            referenceData=mean(inputData.data(goodRefs,:,iWave,iSub,:,:),1,'omitnan');
                            for iChan=1:length(EEGREGchans)
                                theChan=EEGREGchans(iChan);
                                inputData.data(theChan,:,iWave,iSub,:)=inputData.data(theChan,:,iWave,iSub,:)-referenceData;
                            end
                            if ~isempty(inputData.facData)
                                referenceData=mean(inputData.facData(goodRefs,:,iWave,iSub,:,:),1,'omitnan');
                                for iChan=1:length(EEGREGchans)
                                    theChan=EEGREGchans(iChan);
                                    inputData.facData(theChan,:,iWave,iSub,:)=inputData.facData(theChan,:,iWave,iSub,:)-referenceData;
                                end
                            end
                            if ~isempty(inputData.noise)
                                referenceData=mean(inputData.noise(goodRefs,:,iWave,iSub,:,:),1,'omitnan');
                                for iChan=1:length(EEGREGchans)
                                    theChan=EEGREGchans(iChan);
                                    inputData.noise(theChan,:,iWave,iSub,:)=inputData.noise(theChan,:,iWave,iSub,:)-referenceData;
                                end
                            end
                            if ~isempty(inputData.covAVE)
                                if size(inputData.covAVE,7)==1
                                    inputData.covAVE=[]; %can't be rereferenced without covariance information.
                                else
                                    for iPoint=1:numPoints
                                        ep_tictoc;if EPtictoc.stop;return;end
                                        for iFac=1:max(numFacs,1)
                                            for iFreq=1:max(numFreqs,1)
                                                [inputData.covAVE(EEGREGchans,iPoint,iWave,iSub,iFac,iFreq,EEGREGchans)]=ep_covMat(squeeze(inputData.covAVE(EEGREGchans,iPoint,iWave,iSub,iFac,iFreq,EEGREGchans)), find(ismember(EEGREGchans,EEGchans)), 'rereference');
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                    case 'Traditional'
                        goodRefs=setdiff(refChans,badChans);
                        if isempty(goodRefs)
                            if any(strcmp(inputData.dataType,{'continuous','single_trial'}))
                                inputData.analysis.badTrials(iSub,iWave)=1;
                            else
                                inputData.avgNum(iSub,iWave)=-1;
                            end
                        else
                            referenceData=mean(inputData.data(goodRefs,:,iWave,iSub,:),1,'omitnan');
                            for iChan=1:length(EEGREGchans)
                                theChan=EEGREGchans(iChan);
                                inputData.data(theChan,:,iWave,iSub,:)=inputData.data(theChan,:,iWave,iSub,:)-referenceData;
                            end
                            if ~isempty(inputData.facData)
                                referenceData=mean(inputData.facData(goodRefs,:,iWave,iSub,:),1,'omitnan');
                                for iChan=1:length(EEGREGchans)
                                    theChan=EEGREGchans(iChan);
                                    inputData.facData(theChan,:,iWave,iSub,:)=inputData.facData(theChan,:,iWave,iSub,:)-referenceData;
                                end
                            end
                            if ~isempty(inputData.noise)
                                referenceData=mean(inputData.noise(goodRefs,:,iWave,iSub,:),1,'omitnan');
                                for iChan=1:length(EEGREGchans)
                                    theChan=EEGREGchans(iChan);
                                    inputData.noise(theChan,:,iWave,iSub,:)=inputData.noise(theChan,:,iWave,iSub,:)-referenceData;
                                end
                            end
                            if ~isempty(inputData.covAVE)
                                if size(inputData.covAVE,7)==1
                                    inputData.covAVE=[]; %can't be rereferenced without covariance information.
                                else
                                    for iPoint=1:numPoints
                                        ep_tictoc;if EPtictoc.stop;return;end
                                        for iFac=1:max(numFacs,1)
                                            for iFreq=1:max(numFreqs,1)
                                                [inputData.covAVE(EEGREGchans,iPoint,iWave,iSub,iFac,iFreq,EEGREGchans)]=ep_covMat(squeeze(inputData.covAVE(EEGREGchans,iPoint,iWave,iSub,iFac,iFreq,EEGREGchans)), find(ismember(EEGREGchans,goodRefs)), 'rereference');
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                    case 'CSD'
                        goodChans=setdiff(EEGchans,badChans);
                        if strcmp(inputData.dataType,'continuous')
                            whichTrial=[];
                            disp('Applying CSD to entire data length.');
                        else
                            whichTrial=iWave;
                            fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Applying CSD to ' theSegment '# '], iWave, numWaves))
                        end
                        
                        for theFactor = 1:numSGLfacs
                            outputData=zeros(length(goodChans),numPoints,1,1,1,numFreqs);
                            try
                                evalc('[csdData] = ft_scalpcurrentdensity(cfg, ep_ep2ft(ep_selectData(inputData,{goodChans,[],whichTrial,iSub,theFactor,[]})));');
                            catch
                                lasterr
                                msg{1}=['Error: CSD did not work.  One possibility is that this is a Mac and the Developer package has not been installed from the installation disk.  See tutorial.'];
                                [msg]=ep_errorMsg(msg);
                                return
                            end
                            if isfield(csdData,'trial')
                                outputData(:,:,:,:,theFactor,1) = csdData.trial{1};
                            elseif isfield(csdData,'avg')
                                outputData(:,:,:,:,theFactor,1) = csdData.avg;
                            else
                                msg{1}=['Error: CSD did not work.'];
                                [msg]=ep_errorMsg(msg);
                                return
                            end
%                             if ~isempty(setdiff([1:numChans],goodChans)) %put non-EEG channels back in.
%                                 tempData=ep_selectData(inputData,{setdiff([1:numChans],goodChans),[],whichTrial,iSub,theFactor,[]});
%                                 outputData(setdiff([1:numChans],goodChans),:,:,:,theFactor,1) = tempData.data;
%                             end
                        end
                        inputData.data(goodChans,:,iWave,iSub,:)=outputData;
                        
                    case 'PARE'
                        goodRefs=setdiff(EEGchans,badChans);
                        if isempty(goodRefs)
                            if any(strcmp(inputData.dataType,{'continuous','single_trial'}))
                                inputData.analysis.badTrials(iSub,iWave)=1;
                            else
                                inputData.avgNum(iSub,iWave)=-1;
                            end
                        else
                            %next average reference the data
                            referenceData=mean(inputData.data(goodRefs,:,iWave,iSub,:,:),1,'omitnan');
                            for iChan=1:length(EEGREGchans)
                                theChan=EEGREGchans(iChan);
                                inputData.data(theChan,:,iWave,iSub,:)=inputData.data(theChan,:,iWave,iSub,:)-referenceData;
                            end
                            if ~isempty(inputData.facData)
                                referenceData=mean(inputData.facData(goodRefs,:,iWave,iSub,:,:),1,'omitnan');
                                for iChan=1:length(EEGREGchans)
                                    theChan=EEGREGchans(iChan);
                                    inputData.facData(theChan,:,iWave,iSub,:)=inputData.facData(theChan,:,iWave,iSub,:)-referenceData;
                                end
                            end
                            if ~isempty(inputData.noise)
                                referenceData=mean(inputData.noise(goodRefs,:,iWave,iSub,:,:),1,'omitnan');
                                for iChan=1:length(EEGREGchans)
                                    theChan=EEGREGchans(iChan);
                                    inputData.noise(theChan,:,iWave,iSub,:)=inputData.noise(theChan,:,iWave,iSub,:)-referenceData;
                                end
                            end
                            
                            %finally apply the PARE correction
                            nSides=10;
                            [sphereCoords, elecInSphere]=ep_sphereHead(nSides, inputData.eloc);
                            disp('Applying PARE.  This is a very slow process.');
                            for iPoint=1:numPoints
                                fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('Applying PARE to point #%4d of %4d in epoch %4d of %4d',iPoint, numPoints, iWave, numWaves))
                                for iFactor=1:numSGLfacs
                                    if numSGLfacs > 1
                                        disp(['Factor #' num2str(iFactor) ' of ' num2str(numSGLfacs)]);
                                    end
                                    theData=squeeze(inputData.data(EEGchans,iPoint,iWave,iSub,iFactor,:,:));
                                    sphereValues=ep_interpolateHead(theData, elecInSphere, sphereCoords);
                                    referenceData=mean(mean(sphereValues,'omitnan'),'omitnan');
                                    inputData.data(EEGREGchans,iPoint,iWave,iSub,iFactor,:,:)=inputData.data(EEGREGchans,iPoint,iWave,iSub,iFactor,:,:)-referenceData;
                                    for iChan=1:length(EEGREGchans)
                                        theChan=EEGREGchans(iChan);
                                        inputData.data(theChan,:,iWave,iSub,:)=inputData.data(theChan,:,iWave,iSub,:)-referenceData;
                                    end
                                    if ~isempty(inputData.noise)
                                        theData=squeeze(inputData.noise(EEGchans,iPoint,iWave,iSub,iFactor));
                                        sphereValues=ep_interpolateHead(theData, elecInSphere, sphereCoords);
                                        referenceData=mean(mean(sphereValues,'omitnan'),'omitnan');
                                        inputData.noise(EEGREGchans,iPoint,iWave,iSub,iFactor)=inputData.noise(EEGREGchans,iPoint,iWave,iSub,iFactor)-referenceData;
                                    end
                                end
                                for iFactor=1:numCMBfacs
                                    if numCMBfacs > 1
                                        disp(['Combined Factor #' num2str(iFactor) ' of ' num2str(numCMBfacs)]);
                                    end
                                    theData=squeeze(inputData.facData(EEGchans,iPoint,iWave,iSub,iFactor));
                                    sphereValues=ep_interpolateHead(theData, elecInSphere, sphereCoords);
                                    sphereValues=sphereValues(:);
                                    sphereValues=sphereValues(nSides+1:end-nSides);
                                    referenceData=mean(mean(sphereValues,'omitnan'),'omitnan');
                                    inputData.facData(EEGREGchans,iPoint,iWave,iSub,iFactor)=inputData.facData(EEGREGchans,iPoint,iWave,iSub,iFactor)-referenceData;
                                end
                            end
                            fprintf('%60s\n',' ' );
                        end
                        inputData.covAVE=[]; %no way to determine PARE reference site covariances
                    otherwise
                        msg{1}=['Error: Reference method ' referenceMethod ' not recognized.'];
                        [msg]=ep_errorMsg(msg);
                        return
                end
            end
        end
%         fprintf('%60s\n',' ' );
    end
    
    %detrend data
    if doDetrend
        if ~isempty(inputData.freqNames) && strcmp(dataMode,'EEG')
            msg{1}=['Error: The file ' fileName ' is already an FFT file.  Detrending cannot be performed upon it'];
            [msg]=ep_errorMsg(msg);
            return
        else
            fprintf('%60s\n',' ' );
            for theTrial=1:numWaves
                fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Applying detrending to ' theSegment '# '], theTrial, numWaves))
                for theSubject=1:numSubs
                    for theFactor = 1:max(numSGLfacs,1)
                        theData=inputData.data(modeChans,:,theTrial,theSubject,theFactor);
                        theData=detrend(theData')';
                        inputData.data(modeChans,:,theTrial,theSubject,theFactor)=theData;
                    end
                end
            end
            fprintf('%60s\n',' ' );
            suffix=[suffix 'd'];
        end
    end
    
    %baseline correct data
%     if (~isempty(baselineStart) && ~isempty(baselineEnd)) && ~any(strcmp(domainName,{'Frequency','Time-Frequency'}))
    if (~isempty(baselineStart) && ~isempty(baselineEnd)) && ~strcmp(domainName,'Frequency')
        if isnumeric(baselineStart) && isnumeric(baselineEnd)
            if (baselineEnd >= inputData.timeNames(1)) && (baselineStart <= inputData.timeNames(end))
                baseline=find((inputData.timeNames >= baselineStart)&(inputData.timeNames < baselineEnd));
                if isempty(baseline)
                    msg{1}=['Error: Baseline period invalid.  No time points within baseline specified.'];
                    [msg]=ep_errorMsg(msg);
                    return
                else
                    disp(['Baseline correcting data.'])
                    for iChan=1:length(modeChans)
                        ep_tictoc;if EPtictoc.stop;return;end
                        theChan=modeChans(iChan);
                        baselineData=mean(inputData.data(theChan,baseline,:,:,:),2,'omitnan');
                        for thePoint=1:numPoints
                            inputData.data(theChan,thePoint,:,:,:)=inputData.data(theChan,thePoint,:,:,:)-baselineData;
                        end
                    end
                    if ~isempty(inputData.facData)
                        for iChan=1:length(modeChans)
                            ep_tictoc;if EPtictoc.stop;return;end
                            theChan=modeChans(iChan);
                            baselineData=mean(inputData.facData(theChan,baseline,:,:,:),2,'omitnan');
                            for thePoint=1:numPoints
                                inputData.facData(theChan,thePoint,:,:,:)=inputData.facData(theChan,thePoint,:,:,:)-baselineData;
                            end
                        end
                    end
                    if ~isempty(inputData.noise)
                        for iChan=1:length(modeChans)
                            ep_tictoc;if EPtictoc.stop;return;end
                            theChan=modeChans(iChan);
                            baselineData=mean(inputData.noise(theChan,baseline,:,:,:),2,'omitnan');
                            for thePoint=1:numPoints
                                inputData.noise(theChan,thePoint,:,:,:)=inputData.noise(theChan,thePoint,:,:,:)-baselineData;
                            end
                        end
                    end
                    suffix=[suffix 'b'];
                end
            else
                msg{1}=['Error: Baseline period invalid.  Note that Prestim should be positive for prior to event.'];
                [msg]=ep_errorMsg(msg);
                return
            end
        else
            msg{1}=['Error: Baseline period invalid.'];
            [msg]=ep_errorMsg(msg);
            return
        end
    end
    
    %fix mains noise
    if ~isempty(mainsFix) && ~strcmp(mainsFix,'None')
        disp('Using PREP pipeline cleanLineNoise function to perform mains noise correction.');
        disp('Bigdely-Shamlo, N., Mullen, T., Kothe, C., Su, K.-M., & Robbins, K. A. (2015). The PREP pipeline: Standardized preprocessing for large-scale EEG analysis. Frontiers in Neuroinformatics, 9. https://doi.org/10.3389/fninf.2015.00016');
        
        if length(inputData.timeNames) < inputData.Fs
            msg{1}=['Error: Cannot run cleanLine when the number of time points (' num2str(length(inputData.timeNames)) ') is less than one second (' num2str(inputData.Fs) ').'];
            [msg]=ep_errorMsg(msg);
            return
        end
        
        mainsFreq=str2double(EPmain.transform.mainsFix);
        lineNoiseIn.fPassBand=[0, inputData.Fs/2];
        lineNoiseIn.Fs=inputData.Fs;
        lineNoiseIn.fScanBandWidth=2;
        lineNoiseIn.lineFrequencies=[mainsFreq:mainsFreq:floor(inputData.Fs/2)]; %include harmonics up to the Nyquist.
        lineNoiseIn.lineNoiseChannels=EEGchans';
        lineNoiseIn.maximumIterations=10;
        lineNoiseIn.p = 0.01;
        lineNoiseIn.pad=0;
        lineNoiseIn.taperBandWidth=2;
        lineNoiseIn.tau=100;
        
        for iCell=1:length(inputData.cellNames)
            for iSub=1:numSubs
                for iFac = 1:max(numSGLfacs,1)
                    ep_tictoc;if EPtictoc.stop;return;end
                    if strcmp(inputData.dataType,'continuous')
                        [ALLEEG]=ep_ep2alleeg(ep_selectData(inputData,{EEGchans,[],[],[],[],[]}));
                        SlidingWinLength=round(min(numPoints,inputData.Fs*3)/inputData.Fs);
                        SlidingWinStep=round(SlidingWinLength/2);
                    else
                        [ALLEEG]=ep_ep2alleeg(ep_selectData(inputData,{EEGchans,[],iCell,iSub,iFac,[]}));
                        SlidingWinLength=round(numPoints/inputData.Fs);
                        SlidingWinStep=SlidingWinLength;
                    end
                    lineNoiseIn.taperWindowSize=SlidingWinLength;
                    lineNoiseIn.taperWindowStep=SlidingWinStep;
                    [ALLEEG(1), ~] = cleanLineNoise(ALLEEG(1), lineNoiseIn);
                    inputData.data(EEGchans,:,iCell,iSub,iFac,:,:)=ALLEEG(1).data;
                end
            end
        end
        suffix=[suffix 'm'];
    end
    
    %filter data
    if ~isempty(transform.cfgFilter)
        inputData=ep_filterData(inputData,transform.cfgFilter,modeChans);
        if ~isempty(inputData.covAVE)
            inputData.covAVE=[]; %no way to determine filtered reference site covariances
            disp('Standard deviation information deleted as it was based on the unfiltered data.');
        end
        suffix=[suffix 'f'];
    end
    
    %spectral analysis of data
    spectralChans=find(ismember(inputData.chanTypes,{'MGM','MGA','MGP','EEG','REG'}));
    spectralChans=setdiff(spectralChans,find(ismember(inputData.chanNames,{'Hsaccade','Vsaccade'})));
    nonSpecChans=setdiff([1:numChans],spectralChans);
    switch domainName
        case 'Time'
            outputData=inputData.data;
        case 'Frequency'
            if ~isempty(inputData.freqNames)
                msg{1}=['Error: The file ' fileName ' is already an FFT file.'];
                [msg]=ep_errorMsg(msg);
                return
            end
            disp('Using FieldTrip function ft_freqanalysis to perform spectral analysis.');
            cfg=[];
            cfg.method='mtmfft';
            cfg.output='fourier';

            switch methodName
                case 'Hanning'
                    cfg.taper='hanning'; %Fieldtrip recommends Hanning for frequencies below 30Hz
                case {'multi-taper';'wavelet multiplication';'wavelet convolution'}
                    if ~isempty(which('dpss'))
                        cfg.taper='dpss';
                        if smoothing < (inputData.Fs/numPoints)
                            disp(['Increasing smoothing to minimum value allowed for dpss taper: ' num2str(inputData.Fs/numPoints)]);
                            smoothing=(inputData.Fs/numPoints);
                        end
                        %                         if numPoints/(numPoints*(smoothing/inputData.Fs)) >= (numPoints/2)
                        %                             disp(['Decreasing smoothing to maximum value allowed for dpss taper: ' num2str(2*(inputData.Fs/numPoints)-.1)]);
                        %                             smoothing=2*(inputData.Fs/numPoints)-.1;
                        %                         end
                        cfg.tapsmofrq=smoothing;
                    else
                        cfg.taper='hanning';
                        disp('Signal Processing Toolkit not installed so taper defaulting to Hanning');
                    end
            end
            if strcmp(inputData.dataType,'continuous')
                deltaT=min(numPoints/inputData.Fs,1); %time window in seconds
                numWaves=max(1,floor(numPoints/inputData.Fs));
                epochLength=[1:min(inputData.Fs,numPoints)];
            else
                deltaT=numPoints/inputData.Fs; %time window in seconds
                epochLength=[];
            end
            deltaF=1/deltaT; %frequency resolution
            cfg.foi=[deltaF:deltaF:inputData.Fs/2];
            cfg.foi=cfg.foi(1:end-1); %workaround for Fieldtrip bug
            cfg.pad='nextpow2';
            cfg.feedback='no';

            inputData=ep_selectData(inputData,{spectralChans,[],[],[],[],[]});
            outputData=zeros(size(inputData.data,1),1,numWaves,numSubs,numSGLfacs,length(cfg.foi));

            fprintf('%60s\n',' ' );
            for theTrial=1:numWaves
                ep_tictoc;if EPtictoc.stop;return;end
                fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Applying Fourier transform to ' theSegment '# '], theTrial, numWaves))
                for theSubject=1:numSubs
                    for theFactor = 1:max(numSGLfacs,1)
                        evalc('[freq] = ft_freqanalysis(cfg, ep_ep2ft(ep_selectData(inputData,{[],epochLength,theTrial,theSubject,theFactor,[]})));'); %amplitude spectrum
                        outputData(:,1,theTrial,theSubject,theFactor,:) = freq.fourierspctrm;
                    end
                end
            end
            fprintf('%60s\n',' ' );

            %             if any(find(EPtopos.totalData < -100 ))
            %                 EPtopos.totalData(find(EPtopos.totalData < -100)) = -100;
            %                 EPtopos.plotMVmin = -100;
            %                 disp('To avoid plotting problems with -Inf values, negative numbers are being truncated at -100.');
            %             end
            if strcmp(inputData.dataType,'continuous')
                %turns file type into single trial data where each one second segment becomes a different trial and the
                %leftover points are just dropped.
                inputData.dataType='single_trial';
                inputData.trialNames=[1:numWaves]';
                theCellNames=cell(numWaves,1);
                theCellTypes=cell(numWaves,1);
                for i=1:numWaves
                    theCellNames(i)=inputData.cellNames(1);
                    theCellTypes(i)=inputData.cellTypes(1);
                end
                inputData.cellNames=theCellNames;
                inputData.cellTypes=theCellTypes;
                inputData.avgNum(1,1:numWaves)=inputData.avgNum;
                inputData.subNum(1,1:numWaves)=inputData.subNum;
                inputData.trialSpecs=cell(numWaves,0);
                inputData.trialSpecNames=cell(0);
                inputData.events=cell(1,numWaves);
                inputData.recTime=[0:numWaves-1]'*inputData.Fs+1;
                disp('Dropping event information since spectral analysis is eliminating time point information.');
            end
            inputData.timeNames=[];
            inputData.freqNames=freq.freq;
            inputData.noise=[];
            inputData.covAVE=[]; %no way to determine spectral reference site covariances
            disp('Standard deviation information deleted as it was based on the time-domain data.');
            suffix=[suffix 's'];

        case 'Time-Frequency'
            if ~isempty(inputData.freqNames)
                msg{1}=['Error: The file ' fileName ' is already an FFT file.'];
                [msg]=ep_errorMsg(msg);
                return
            end
            disp('Using FieldTrip function ft_freqanalysis to perform spectral analysis.');
            cfg=[];
            cfg.method='mtmconvol';
            cfg.output='fourier';
            deltaT=min(.5,((numPoints/2)/inputData.Fs)); %time window in seconds, no more than 500 ms, no less than half the segment.
            switch methodName
                case 'Hanning'
                    cfg.taper='hanning'; %Fieldtrip recommends Hanning for frequencies below 30Hz
                case {'multi-taper';'wavelet multiplication';'wavelet convolution'}
                    if ~isempty(which('dpss'))
                        cfg.taper='dpss';

                        if smoothing < (1/deltaT)
                            smoothing=1/deltaT;
                            disp(['Increasing smoothing to minimum value allowed for dpss taper: ' num2str(smoothing)]);
                        end
                        if numPoints/(numPoints*(smoothing/inputData.Fs)) >= (numPoints/2)
                            disp(['Decreasing smoothing to maximum value allowed for dpss taper: ' num2str(2*(inputData.Fs/numPoints)-.1)]);
                            smoothing=2*(inputData.Fs/numPoints)-.1;
                        end
                        cfg.tapsmofrq=smoothing;
                    else
                        cfg.taper='hanning';
                        disp('Signal Processing Toolkit not installed so taper defaulting to Hanning');
                    end
            end
            cfg.pad='nextpow2';
            cfg.feedback='no';
            cfg.keeptrials='yes';
            cfg.keeptapers='yes';
            resT=50; %50 ms sliding window
            deltaF=1/deltaT; %frequency resolution
            %cfg.foi          = deltaF:deltaF:50; %50 ms sliding window
            cfg.foi=[deltaF:deltaF:inputData.Fs/2];
            cfg.foi=cfg.foi(1:end-1); %workaround for Fieldtrip bug
            cfg.t_ftimwin    = ones(1,length(cfg.foi)).*deltaT;
            cfg.tapsmofrq=ones(1,length(cfg.foi))*smoothing;

            spectralData=ep_selectData(inputData,{spectralChans,[],[],[],[],[]});

            if strcmp(inputData.dataType,'continuous')
                %continuous data has the problem that half the deltaT is lopped off each end, resulting in the .analysis edit epochs being misaligned.
                %will therefore lop off more off each end so that exactly one second is gone and the original epochs can remain aligned.
                %a separate issue is that since the T-F transform goes into the adjoining epochs, bad data markings should also propagate as the previously good epoch will now be contaminated by bad data.
                dropSamps=(ceil(deltaT)*inputData.Fs)+1;
                cfg.toi=(inputData.timeNames(dropSamps):resT:inputData.timeNames(numPoints-dropSamps))/1000;
                numPoints2=length(cfg.toi);
                outputData=zeros(numChans,numPoints2,numWaves,numSubs,numSGLfacs,length(cfg.foi));
                disp('Applying wavelet transform to entire continuous dataset')
                for theFactor = 1:numSGLfacs
                    ep_tictoc;if EPtictoc.stop;return;end
                    evalc('[freq] = ft_freqanalysis(cfg, ep_ep2ft(ep_selectData(spectralData,{[],[],[],1,theFactor,[]})));'); %amplitude spectrum
                    for theTime=1:numPoints2
                        outputData(spectralChans,theTime,1,1,theFactor,:) = squeeze(freq.fourierspctrm(1,:,:,theTime));
                    end
                    for iChan=1:length(nonSpecChans)
                        theChan=nonSpecChans(iChan);
                        outputData(theChan,:,1,1,theFactor,:)=repmat(interp1(inputData.timeNames+(inputData.baseline*(1000/inputData.Fs)),inputData.data(theChan,:,1,1,theFactor,:)',cfg.toi*1000,'linear','extrap')',1,1,length(cfg.foi));
                    end
                end
                sampleConversion=(1000/inputData.Fs)/resT;
                for iEvent=1:length(inputData.events{1})
                    inputData.events{1}(iEvent).sample=ceil(inputData.events{1}(iEvent).sample*sampleConversion)-dropSamps;
                end
                inputData.events{1}(find(([inputData.events{1}.sample]<1)|([inputData.events{1}.sample]>numPoints2)))=[];
                badTrialList=find(inputData.analysis.badTrials);
                for iTrial=1:length(badTrialList)
                    ep_tictoc;if EPtictoc.stop;return;end
                    theTrial=badTrialList(iTrial);
                    if theTrial>1
                        inputData.analysis.badTrials(1,theTrial-1)=1;
                    end
                    if theTrial<length(inputData.analysis.badTrials)
                        inputData.analysis.badTrials(1,theTrial+1)=1;
                    end
                end
                newBadChans=inputData.analysis.badChans;
                for iTrial=1:size(inputData.analysis.badChans,2)
                    ep_tictoc;if EPtictoc.stop;return;end
                    if iTrial>1
                        newBadChans(1,iTrial-1,find(inputData.analysis.badChans(1,iTrial,:)==-1))=-1;
                    end
                    if theTrial<length(inputData.analysis.badTrials)
                        newBadChans(1,iTrial+1,find(inputData.analysis.badChans(1,iTrial,:)==-1))=-1;
                    end
                end
                inputData.analysis.badChans=newBadChans;
                firstEpoch=2;
                lastEpoch=floor(numPoints2/(1000/resT))+1;
                inputData.analysis.blinkTrial=inputData.analysis.blinkTrial(1,firstEpoch:lastEpoch);
                inputData.analysis.saccadeTrial=inputData.analysis.saccadeTrial(1,firstEpoch:lastEpoch);
                inputData.analysis.saccadeOnset=inputData.analysis.saccadeOnset(1,firstEpoch:lastEpoch);
                inputData.analysis.moveTrial=inputData.analysis.moveTrial(1,firstEpoch:lastEpoch);
                inputData.analysis.badTrials=inputData.analysis.badTrials(1,firstEpoch:lastEpoch);
                inputData.analysis.badChans=inputData.analysis.badChans(1,firstEpoch:lastEpoch,:);
            else
                cfg.toi=(inputData.timeNames(ceil(deltaT*inputData.Fs*.5+.001)):resT:inputData.timeNames(numPoints-ceil(deltaT*inputData.Fs*.5+.001)))/1000;
                outputData=zeros(numChans,length(cfg.toi),numWaves,numSubs,numSGLfacs,length(cfg.foi));
                fprintf('%60s\n',' ' );
                for theTrial=1:numWaves
                    fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Applying wavelet transform to ' theSegment '# '], theTrial, numWaves))
                    for theSubject=1:numSubs
                        for theFactor = 1:numSGLfacs
                            ep_tictoc;if EPtictoc.stop;return;end
                            evalc('[freq] = ft_freqanalysis(cfg, ep_ep2ft(ep_selectData(spectralData,{[],[],theTrial,theSubject,theFactor,[]})));'); %amplitude spectrum
                            for theTime=1:length(cfg.toi)
                                outputData(spectralChans,theTime,theTrial,theSubject,theFactor,:) = squeeze(freq.fourierspctrm(1,:,:,theTime));
                            end
                            for iChan=1:length(nonSpecChans)
                                theChan=nonSpecChans(iChan);
                                outputData(theChan,:,theTrial,theSubject,theFactor,:)=repmat(interp1(inputData.timeNames+(inputData.baseline*(1000/inputData.Fs)),inputData.data(theChan,:,theTrial,theSubject,theFactor,:)',cfg.toi*1000,'linear','extrap')',1,1,length(cfg.foi));
                            end
                            sampleConversion=(1000/inputData.Fs)/resT;
                            for iEvent=1:length(inputData.events{theSubject,theTrial})
                                inputData.events{theSubject,theTrial}(iEvent).sample=ceil(inputData.events{theSubject,theTrial}(iEvent).sample*sampleConversion);
                            end
                        end
                    end
                end
                fprintf('%60s\n',' ' );
            end

            %firstGood=min(find(isfinite(squeeze(mean(outputData(:,:,1,1,1,1),1)))));
            %lastGood=max(find(isfinite(squeeze(mean(outputData(:,:,1,1,1,1),1)))));
            inputData.Fs=1000/resT;
            inputData.timeNames=cfg.toi*1000;
            inputData.timeNames=inputData.timeNames(:);
            inputData.baseline=floor(-inputData.timeNames(1)/resT); %when baseline falls within the epoch, shift to left side of epoch
            %inputData.baseline=((inputData.baseline*(1000/inputData.Fs))/50);
            inputData.freqNames=freq.freq;
            inputData.noise=[];
            inputData.covAVE=[]; %no way to determine spectral reference site covariances
            disp('Standard deviation information deleted as it was based on the time-domain data.');
            suffix=[suffix 'w'];

        case {'BOSC','eBOSC'}
            if ~isempty(inputData.freqNames)
                msg{1}=['Error: The file ' fileName ' is already an FFT file.'];
                [msg]=ep_errorMsg(msg);
                return
            end
            disp('Using Better OSCillation detection (BOSC) library by Jeremy B. Caplan, Adam M. Hughes, Tara A. Whitten and Clayton T. Dickson.');
            %code in this BOSC section adapted from BOSC tutorial code under GNU license version 3.
            disp('with extended BOSC (eBOSC) library by Kosciessa, Grandy, Garrett, and Werkle-Bergner.');

            F=[1:inputData.Fs/2]; %not log-based so as to be more interpretable.
            shoulder=ceil((BOSC.width+BOSC.duration)*inputData.Fs./min(F));
            inputData.timeNames=inputData.timeNames(shoulder+1:end-shoulder);
            inputData.freqNames=F;
            numPoints=length(inputData.timeNames);
            numFreqs=length(F);
            numSpectChans=length(spectralChans);
            backTrials=find(strcmp(BOSC.cellList(BOSC.cell),inputData.cellNames));
            dataTrials=find(~strcmp(BOSC.cellList(BOSC.cell),inputData.cellNames));
            outputData=zeros(numChans,numPoints,numWaves,numSubs,numSGLfacs,numFreqs);

            [B,T]=BOSC_tf(inputData.data(1,:,1,1,1,1,1),F,inputData.Fs,BOSC.width);
            backgroundSpec=zeros(size(B,1),size(B,2));

            fprintf('%60s\n',' ' );
            for iChan=1:numSpectChans
                ep_tictoc;if EPtictoc.stop;return;end
                theChan=spectralChans(iChan);
                inputData.chanTypes{theChan}='BSC';
                for iSubject=1:numSubs
                    for iFactor = 1:numSGLfacs
                        %estimate the background activity
                        B2=zeros(size(B,1),size(B,2),length(backTrials));
                        for iTrial=1:length(backTrials)
                            theTrial=backTrials(iTrial);
                            [B2(:,:,iTrial),~]=BOSC_tf(inputData.data(theChan,:,iTrial,iSubject,iFactor,:,:),F,inputData.Fs,BOSC.width); % Compute the time-frequency (wavelet) spectrogram
                            backgroundSpec(:,:)=mean(B2,3);
                            if strcmp(domainName,'BOSC')
                                [pv,meanpower]=BOSC_bgfit(F,backgroundSpec(:,shoulder+1:end-shoulder));
                            else
                                [pv,meanpower]=eBOSC_bgfit_robust(F,backgroundSpec(:,shoulder+1:end-shoulder));
                            end
                            [powthresh,durthresh]=BOSC_thresholds(inputData.Fs,BOSC.threshold,BOSC.duration,F,meanpower);
                        end

                        %compute BOSC results
                        numDataTrials=length(dataTrials);
                        for iTrial=1:numDataTrials
                            fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('Computing channel # %4d of %4d in trial #%4d of %4d.',iChan, numSpectChans, iTrial, numDataTrials))
                            ep_tictoc;if EPtictoc.stop;return;end
                            theTrial=dataTrials(iTrial);
                            for iFreq=1:length(F)
                                theFreq=F(iFreq);
                                targetsignal=inputData.data(iChan,:,theTrial,iSubject,iFactor,:,:); %note that unlike the BOSC tutorial, shoulders extending outside the period of interest are not used as that would contaminate the results
                                % compute the time-frequency (wavelet) spectrogram, aka "scalogram"
                                [Btarget,Ttarget]=BOSC_tf(targetsignal,F(iFreq),inputData.Fs,BOSC.width);

                                % detect oscillations
                                detected=BOSC_detect(Btarget,powthresh(iFreq),durthresh(iFreq),inputData.Fs);
                                if strcmp(domainName,'eBOSC')
                                    %it was not entirely clear to me what settings were used in the 2020 article for edgeOnly and effSignal so I chose settings that seemed reasonable.  They didn't seem important enough to add controls to the GUI.
                                    cfg.eBOSC.pt          = powthresh;
                                    cfg.eBOSC.F           = F; %frequency resolution of B (log-scaled!)
                                    cfg.eBOSC.fsample     = inputData.Fs; %sampling frequency
                                    cfg.eBOSC.wavenumber  = theFreq; %wavenumber in time-frequency analysis
                                    cfg.eBOSC.npnts       = numPoints; %length of data (in data points)
                                    cfg.eBOSC.fstp        = deltaF; %maximal step size of frequencies from one time point to the next (steps refer to vector entries in .F)
                                    cfg.eBOSC.ncyc        = repmat(3, 1, numel(cfg.eBOSC.F)); %minimum number of cycles of the average freqency of that segment
                                    cfg.eBOSC.BiasCorrection='yes'; %apply bias correction
                                    cfg.eBOSC.method        ='MaxBias'; %method to use for bias correction; options: 'MaxBias', 'FWHM'; see Kosciessa et al. supplement for more infos
                                    cfg.eBOSC.edgeOnly      ='no'; %correct for wavelet bias only at segment edges ('yes') or also within detected segments ('no')
                                    cfg.eBOSC.effSignal     ='PT'; %signal to base wavelet correaction on: 'all' - entire signal including background; 'PT' - only signal above the power threshold
                                    [detected2,episodes] = eBOSC_createEpisodes(B,detected,cfg);
                                    outputData(theChan,:,theTrial,iSubject,iFactor,iFreq,:)=detected2(iFreq,shoulder+1:end-shoulder);
                                else
                                    outputData(theChan,:,theTrial,iSubject,iFactor,iFreq,:)=detected(shoulder+1:end-shoulder);
                                end
                            end
                        end
                    end
                end
            end
            fprintf('%60s\n',' ' );

            %non-spectral channels
            for iTrial=1:numWaves
                ep_tictoc;if EPtictoc.stop;return;end
                for iSubject=1:numSubs
                    for iChan=1:length(nonSpecChans)
                        theChan=nonSpecChans(iChan);
                        for iFactor = 1:numSGLfacs
                            outputData(theChan,:,iTrial,iSubject,iFactor,:)=repmat(inputData.data(theChan,shoulder+1:end-shoulder,iTrial,iSubject,iFactor,:),1,1,length(F));
                        end
                    end
                    for iEvent=1:length(inputData.events{iSubject,iTrial})
                        inputData.events{iSubject,iTrial}(iEvent).sample=inputData.events{iSubject,iTrial}(iEvent).sample-shoulder;
                    end
                end
            end
    end

    %calculate the .cov field
    if strcmp(inputData.dataType,'single_trial') && isempty(inputData.cov) && (strcmp(referenceMethod,'CSD') || any(strcmp(domainName,{'Frequency','Time-Frequency'})))
        goodChans=setdiff([1:numChans],any(isnan(squeeze(inputData.analysis.badChans(1,:,:))))); %if channel entirely bad in any of the cells, then leave out of cov calculation
        covData=[];
        EEGchans=find(strcmp('EEG',inputData.chanTypes));
        goodChans=intersect(EEGchans,goodChans);
        for iCell=1:size(inputData.data,3)
            if ~any(inputData.analysis.badChans(1,iCell,:) < 0) && ~inputData.analysis.badTrials(1,iCell)
                theData=squeeze(inputData.data(goodChans,:,iCell,1,:,:));
                if inputData.baseline
                    theData=theData-diag(squeeze(mean(theData(:,1:min(inputData.baseline,size(theData,2))),2,'omitnan')))*ones(length(goodChans),size(theData,2)); %baseline the data prior to calculating the cov matrix
                end
                for iPoint=1:size(theData,2)
                    theData(:,iPoint)=theData(:,iPoint)-mean(theData(:,iPoint),1,'omitnan'); %average reference prior to cov calculation
                end
                covData=[covData, theData];
            end
        end
        Nq=size(covData,2);
        inputData.cov.covMatrix=zeros(1,length(inputData.chanNames),length(inputData.chanNames));
        inputData.cov.covMatrix(1,goodChans,goodChans)=(covData*covData')./Nq; %per MNE recommended procedure, the cov is calculated as an SSCP matrix where the variables have been baseline corrected for each epoch.
        inputData.cov.Nq=Nq; %degrees of freedom, for weighting cov matrices when later combined.
        if strcmp(inputData.dataType,'single_trial')
            inputData.covNum=ones(1,size(outputData,3));
        end
    end

    inputData.data=outputData;

    %     if any(any(any(any(any(any(isnan(inputData.data)))))))
    %         disp(['Warning: Non-numbers were generated for the file ' inputFiles{iFile} ' so the output file will not be saved.']);
    %         suffix=[];
    %     end

    %     inputData.history{end+1} = {'ep_transformData',inputFiles,inputFormat,fileType,outputFormat,referenceMethod,transform,domainName};

    if ~isempty(suffix)
        [pathstr, name, ext] = fileparts(inputFiles{iFile});
        [fileSuffix,formatName]=ep_fileExtensions(outputFormat);

        sameName=1;
        theNumber=0;
        fileNameSuffix=[pathstr filesep name '_' suffix fileSuffix{1}];
        while sameName
            sameName=0;
            if exist(fileNameSuffix,'file')
                sameName=1;
            end
            if sameName
                theNumber=theNumber+1;
                fileNameSuffix=[pathstr filesep name '_' suffix '-' num2str(theNumber) fileSuffix{1}];
            end
        end

        if ~strcmp(inputFormat,'ep_mat')
            theDescription=['Imported the file ' inputFiles{iFile} '.'];
            inputData.history=ep_addHistory(inputData.history, EPmain.preferences.records, theDescription, EPmain.handles.hMainWindow, EPmain.preferences, EPmain.preferences.EPver,inputFiles);
        end
        theDescription=['Transformed the file ' inputFiles{iFile} '.'];
        inputData.history=ep_addHistory(inputData.history, EPmain.preferences.records, theDescription, EPmain.handles.hMainWindow, EPmain.preferences, EPmain.preferences.EPver,inputFiles);

        [err]=ep_writeData(inputData,fileNameSuffix,EPmain.preferences.general.specSuffix,EPmain.preferences.general.subjectSpecSuffix,outputFormat);
    end
    disp(['The subject took ' sprintf('%5.2f',toc/60) ' minutes to process.']);
    outputFiles{iFile}=fileNameSuffix;
end

ep_tictoc('end');
