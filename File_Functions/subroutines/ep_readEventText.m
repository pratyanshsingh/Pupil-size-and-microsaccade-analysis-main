function EPdata = ep_readEventText(EPdata, specFileName, theDelim)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% EPdata = ep_readEventText(EPdata, specFileName, theDelim) - reads in events text file
% and replaces events structure in EPdata with the new events information.
%
%	Reads in events text file for file formats that do not support such
%	information.
%
%Inputs
%   EPdata         : Structured array with the data and accompanying information.  See readData.
%	specFileName: file name for events text file, including path and suffix.
%   theDelim:   the text delimiter.  Optional.  Will guess if not provided.
%
%Outputs
%   EPdata         : Structured array with the data and accompanying information.  See readData.
%
% History:
%
% by Joseph Dien (12/14)
% jdien07@mac.com
%
% bugfix 12/12/18 JD
% Fixed crash when reading an events text file and there is a problem with it.
%
% modified 11/30/19 JD
% Enabled reading of text files with a greater range of variations in character encoding, end-of-line markers, and field separation markers.
%
% bugfix & modified 7/11/20 JD
% Fixed crash when reading an events text file with keys.
% Now supports evt text files generated by NetStation 4.1.2 for continuous files.
% Added option to specify the delimiter.
%
% bugfix 11/8/20 JD
% Fixed crash when reading an events text file with key codes.
%
% bugfix 2/26/21 JD
% No longer treats as error when there is no event data to add.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Copyright (C) 1999-2025  Joseph Dien
%
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

global EPtictoc

if ~exist('theDelim','var')
    theDelim='';
end

numSubs=length(EPdata.subNames);
numWaves=length(EPdata.cellNames);
keyNames={'code';'data';'datatype';'description'};

[theHeader, theData, theDelim] = ep_textScan(specFileName,2,0,0,0,theDelim);
ep_tictoc;if EPtictoc.stop;EPtictoc.stop=0;ep('start');return;end
specNames={'subject';'cell';'type';'sample';'value';'duration'};
evtFormat='EP';
if length(theHeader{1})==1
    %assume it is a NetStation 4.1.2 event file.
    evtFormat='NS';
    [theHeader, theData, theDelim] = ep_textScan(specFileName,1,0,0,0,char(9));
    ep_tictoc;if EPtictoc.stop;EPtictoc.stop=0;ep('start');return;end
    theHeader=cell(0);
    theHeader{1}=theData(2,:);
    theData=theData(3:end,:);
    specNames={'Code';'Label';'Type';'Track';'Onset';'Duration'};
    keyNames={'code';'data'};
    if isempty(theHeader{1}{length(specNames)+1})
        for iSpec=length(specNames)+1:size(theData,2)
            theHeader{1}{iSpec}=keyNames{rem(iSpec-length(specNames)-1,length(keyNames))+1};
        end
    end
end
numKeyNames=length(keyNames);
if isempty(theData)
    disp('No event data to add.');
else
    numRows=size(theData,1);
    numSpecs=size(theData,2);
    numKeys=(numSpecs-length(specNames))/length(keyNames);
    if mod(numSpecs-length(specNames),length(keyNames)) ~=0
        disp(['Error: Number of spec fields in the events text file is incorrect.']);
    else
        badSpecNames=0;
        for iSpec=1:length(specNames)
            if ~strcmp(theHeader{1}{iSpec},specNames{iSpec})
                badSpecNames=iSpec;
            end
        end
        if badSpecNames
            disp(['Error: The spec name ' specNames{badSpecNames} ' in the events text file does not conform to the expected format.']);
        else
            badSpecNames=0;
            if strcmp(evtFormat,'EP')
                for iSpec=length(specNames)+1:numKeyNames:numSpecs
                    theKey=mod((iSpec-length(specNames)-1),numKeyNames)+1;
                    if (length(theHeader{1}{iSpec})<length(keyNames{theKey}) || ~strcmp(theHeader{1}{iSpec}(1:length(keyNames{theKey})),keyNames{theKey}))
                        badSpecNames=iSpec;
                    end
                end
            end
            if badSpecNames
                disp(['Error: The spec name ' theHeader{1}{badSpecNames} ' in the events text file does not conform to the expected format.']);
            else
                badSub=0;
                badCell=0;
                if strcmp(evtFormat,'EP')
                    for iEvent=1:numRows
                        theSub=str2double(theData{iEvent,1});
                        if isnan(theSub) || (theSub < 1) || (theSub > numSubs)
                            badSub=1;
                        end
                        theCell=str2double(theData{iEvent,2});
                        if isnan(theCell) || (theCell < 1) || (theCell > numWaves)
                            badCell=1;
                        end
                    end
                end
                if badSub || badCell
                    disp(['Error: The subject and/or cell numbers in the events text file have a problem.']);
                else
                    newEvents=cell(numSubs,numWaves);
                    for iEvent=1:numRows
                        theSub=1;
                        theCell=1;
                        if strcmp(evtFormat,'EP')
                            theSub=str2double(theData{iEvent,1});
                            theCell=str2double(theData{iEvent,2});
                            oneEvent=[];
                            oneEvent.type=theData{iEvent,3};
                            oneEvent.sample=str2double(theData{iEvent,4});
                            oneEvent.value=theData{iEvent,5};
                            oneEvent.duration=str2double(theData{iEvent,6});
                            if numKeys
                                for iKey=1:numKeys
                                    theSpec=((iKey-1)*length(keyNames))+length(specNames)+1;
                                    if ~isempty(theData{iEvent,theSpec})
                                        oneEvent.keys(iKey).code=theData{iEvent,theSpec};
                                        oneEvent.keys(iKey).data=theData{iEvent,theSpec+1};
                                        oneEvent.keys(iKey).datatype=theData{iEvent,theSpec+2};
                                        oneEvent.keys(iKey).description=theData{iEvent,theSpec+3};
                                    else
                                        oneEvent.keys(iKey)=struct('code','','data','','datatype','','description','');
                                    end
                                end
                            else
                                oneEvent.keys=struct('code','','data','','datatype','','description','');
                            end
                        elseif strcmp(evtFormat,'NS')
                            oneEvent=[];
                            oneEvent.type=theData{iEvent,1};
                            oneEvent.sample=str2double(theData{iEvent,5});
                            oneEvent.value=theData{iEvent,8}; %cell
                            oneEvent.duration=str2double(theData{iEvent,6});
                            oneEvent.keys=[];
                            if numKeys
                                for iKey=1:numKeys
                                    theSpec=((iKey-1)*length(keyNames))+length(specNames)+1;
                                    if ~isempty(theData{iEvent,theSpec}) && ~strcmp(theData{iEvent,theSpec},' ')
                                        oneEvent.keys(end+1).code=theData{iEvent,theSpec};
                                        oneEvent.keys(end).data=theData{iEvent,theSpec+1};
                                        oneEvent.keys(end).datatype='';
                                        oneEvent.keys(end).description='';
                                    end
                                end
                            else
                                oneEvent.keys=struct('code','','data','','datatype','','description','');
                            end
                        end
                        newEvents{theSub,theCell}(end+1)=oneEvent;
                    end
                    events=newEvents;
                    disp('Replacing current contents of events structure with contents of the events text file.');
                    EPdata.events=events;
                end
            end
        end
    end
end

